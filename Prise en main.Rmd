---
title: "Prise_en_main"
output: html_document
date: "2024-06-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

## Prise en maain des données

```{r}
library(sf)
library(dplyr)
library(lubridate)
library(mapview)
library(DBI)
library(ggplot2)
library(purrr)
library(webshot)
# webshot::install_phantomjs()
source(file = "connexion_db.R")
conn<-connecter()
DBI::dbListTables(conn)
```

```{r}
DBI::dbListFields(conn,"parc_85")
DBI::dbListFields(conn,"parc_85_23")
```

```{r}
parcelle_24<-st_read(conn, query = "SELECT * FROM parc_85;")
parcelle_23<-st_read(conn, query = "SELECT * FROM parc_85_23;")
commune<-st_read(conn, query = "SELECT * FROM com_85;")

ajout_parc_tot <- parcelle_24 %>% 
  filter(!idu %in% parcelle_23$idu)

supp_parc_tot <- parcelle_23 %>% 
  filter(!idu %in% parcelle_24$idu)
```

```{r}
create_extended_borders <- function(commune, buffer_distance) {
  buffer_positive <- st_buffer(commune, buffer_distance)
  buffer_negative <- st_buffer(commune, -buffer_distance)
  suppressWarnings({
    buffer_difference <- st_difference(buffer_positive, buffer_negative)
  })
  return(buffer_difference)
}

bordure <- commune %>%
  group_by(code_insee) %>%  
  do(extended = create_extended_borders(., 50))

bordure <- do.call(rbind, bordure$extended) %>%
  select(-c(4,5,6)) %>% 
  st_sf()

inter_parc_24 <- parcelle_24 %>%
  st_filter(bordure, .predicate = st_intersects)

inter_parc_23 <- parcelle_23 %>%
  st_filter(bordure, .predicate = st_intersects)

#ajout_parc_bad <- inter_parc_24 %>% 
#  filter(!idu %in% inter_parc_23$idu)
# Parcelle modifié n'étant plus dans la zone tampon considérée comme ajoutée

ajout_parc <- ajout_parc_tot %>%
  st_filter(bordure, .predicate = st_intersects) %>% 
  arrange(nom_com)

#supp_parc_bad <- inter_parc_23 %>% 
#  filter(!idu %in% inter_parc_24$idu)
# Parcelle modifié n'étant plus dans la zone tampon considérée comme supprimée

supp_parc <- supp_parc_tot %>%
  st_filter(bordure, .predicate = st_intersects) %>% 
  arrange(nom_com)

```


```{r}
plot <- ggplot() +
  geom_sf(data = commune, aes(fill = "Communes"), color = "black", alpha = 0.5) +  
  geom_sf(data = bordure, aes(fill = "Bordures étendues"), fill = "lightblue", alpha = 0.5, color = "lightblue") +  
  geom_sf(data = inter_parc_24, aes(fill = "Parcelles croisées"), alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", "Parcelles croisées" = "purple")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales (2024) croisant les frontières étendues des communes de Vendée", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 50m de chaque côté de celles définies par l'IGN")

# ggsave("parcelles_croisant_bordures_85.png", plot = plot, width = 12, height = 8, dpi = 300)
plot
```




```{r}
# Méthode au niveau de la géomètrie des parcelles

df_geom <- inter_parc_24 %>%
  filter(!idu %in% ajout_parc$idu) %>% 
  st_filter(inter_parc_23, .predicate = st_equals)
# Parcelles n'ayant pas été modifiées
# Attention : doit etre invariant en changeant l'ordre des tables

apres_geom <- inter_parc_24 %>% 
  filter(!idu %in% df_geom$idu & !idu %in% ajout_parc$idu) %>% 
  arrange(nom_com)

avant_geom <- inter_parc_23 %>% 
  filter(!idu %in% df_geom$idu & !idu %in% supp_parc$idu) %>% 
  arrange(nom_com)

```

```{r}
plot <- ggplot() +
  geom_sf(data = commune, aes(fill = "Communes"),color = "black", alpha = 0.5) +  
  geom_sf(data = bordure, aes(fill = "Bordures étendues"), fill = "lightblue", alpha = 0.5, color = "lightblue") +  
  geom_sf(data = apres_geom, aes(fill = "Parcelles modifiées (2024)"), alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = avant_geom, aes(fill = "Parcelles modifiées (2023)"), alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = ajout_parc, aes(fill = "Parcelles ajoutées"), alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = supp_parc, aes(fill = "Parcelles supprimées"), alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", "Parcelles modifiées (2024)" = "purple",
                               "Parcelles modifiées (2023)" = "pink", "Parcelles ajoutées" = "green", "Parcelles supprimées" = "red")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales croisant les frontières étendues des communes en Vendée, modifiés au niveau de la geometry en 2024", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 50m de chaque côté de celles définies par l'IGN")

# ggsave("parcelles_bordures_modifiées_85.png", plot = plot, width = 12, height = 8, dpi = 300)
# plot
```


```{r}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(apres_geom, layer.name = "Parcelles modifiées (état 2024)", col.regions = "purple", alpha.regions = 0.5) +
  mapview(avant_geom, layer.name = "Parcelles modifiées (état 2023)", col.regions = "pink", alpha.regions = 0.5) +
  mapview(ajout_parc, layer.name = "Parcelles ajoutées", col.regions = "lightgreen", alpha.regions = 0.5) +
  mapview(supp_parc, layer.name = "Parcelles supprimées", col.regions = "red", alpha.regions = 0.5)

mapshot(map, url = "parcelles_modifiées_bordure_85.html")
```





```{r}
identical(apres_geom %>% st_drop_geometry() %>% arrange(across(everything())),
          avant_geom %>% st_drop_geometry() %>% arrange(across(everything())))

df1_sorted <- apres_geom %>% select(!contenance) %>%  st_drop_geometry() %>% arrange(across(everything()))
df2_sorted <- avant_geom %>% select(!contenance) %>% st_drop_geometry() %>% arrange(across(everything()))

# Récupérer les lignes de df1 non présentes dans df2
diff_df1 <- anti_join(df1_sorted, df2_sorted, by = colnames(df1_sorted))

# Récupérer les lignes de df2 non présentes dans df1
diff_df2 <- anti_join(df2_sorted, df1_sorted, by = colnames(df2_sorted))

# Combiner les deux résultats pour obtenir toutes les lignes différentes
diff_all <- bind_rows(diff_df1, diff_df2)
# Cas de parcelles n'etant plus dans la zone tampon suite à la modification
```


```{r}
inter_parc_24 %>% filter(idu == "451260000E0146")
inter_parc_23 %>% filter(idu == "451260000E0146")
ajout_parc_tot %>% filter(idu == "451260000E0146")
ajout_parc %>% filter(idu == "451260000E0146")

parcelle_24 %>% filter(idu == "451260000E0146")
parcelle_23 %>% filter(idu == "451260000E0146")
```


```{r}
ajout_parc <- ajout_parc %>% 
  arrange(nom_com)

supp_parc <- supp_parc %>% 
  arrange(nom_com)
```





```{r}
# Méthode au niveau de la superficie des parcelles

df_sup <- full_join(inter_parc_24 %>% select(idu, contenance) %>% as.data.frame(), 
                    inter_parc_23 %>% select(idu, contenance) %>% as.data.frame(),
                    by = "idu", suffix = c(".df1", ".df2")) %>%
  filter(is.na(contenance.df1) | is.na(contenance.df2) | contenance.df1 != contenance.df2) %>%
  mutate(
    contenance.df1 = ifelse(is.na(contenance.df1), "Manquant", contenance.df1),
    contenance.df2 = ifelse(is.na(contenance.df2), "Manquant", contenance.df2)
  )

df_sup <- df_sup %>% 
  mutate(typo = case_when(
    contenance.df1 == "Manquant" ~ "Suppression",
    contenance.df2 == "Manquant" ~ "Ajout",
    contenance.df1 != contenance.df2 ~ "Modification"
  ))

# Problème : il arrive que des parcelles ne contiennent pas la superficie
# A revoir car typologie fausse
table(df_sup$typo)

apres_sup <- inter_parc_24 %>% 
  filter(idu %in% df_sup[filter(typo == "Ajout"),]$idu)

avant_sup <- inter_parc_23 %>% 
  filter(idu %in% df_sup[filter(typo == "Suppression"),]$idu)
```


```{r}
plot <- ggplot() +
  geom_sf(data = commune, aes(fill = "Communes"),color = "black", alpha = 0.5) +  
  geom_sf(data = bordure, aes(fill = "Bordures étendues"), fill = "lightblue", alpha = 0.5, color = "lightblue") +  
  geom_sf(data = apres_sup, aes(fill = "Parcelles ajoutées"), alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = avant_sup, aes(fill = "Parcelles supprimées"), alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", "Parcelles ajoutées" = "lightgreen",
                               "Parcelles supprimées" = "red")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales croisant les frontières étendues des communes du Loiret, modifiées en 2024 au sens de la superficie", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 50m de chaque côté de celles définies par l'IGN")
plot
```

```{r}
mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(apres_sup, layer.name = "Parcelles ajoutées", col.regions = "lightgreen", alpha.regions = 0.5) +
  mapview(avant_sup, layer.name = "Parcelles supprimées", col.regions = "red", alpha.regions = 0.5)
```





```{r}
df_comp <- inter_parc_24 %>% 
  st_filter(inter_parc_23, .predicate = st_equals)

df_comp_2 <- inter_parc_23 %>% 
  st_filter(inter_parc_24, .predicate = st_equals)

merged_df <- merge(df_comp %>% st_drop_geometry(), 
                   df_comp_2 %>% st_drop_geometry(), 
                   by = "idu", all = TRUE)
# Parcelles n'ayant pas été modifiés + ajoutés + supprimés 

ajout_parc <- anti_join(df_comp %>% st_drop_geometry(),
                        df_comp_2 %>% st_drop_geometry(),
                        by = "idu")

supp_parc <- anti_join(df_comp_2 %>% st_drop_geometry(),
                       df_comp %>% st_drop_geometry(),
                       by = "idu")

# FAUX
```

```{r}
ajout_parc_direct %>% filter(!idu %in% meth_sup$idu) %>% select(idu)

df_comp_2 %>% filter(idu == "45024000AH0028")

inter_parc_23 %>% filter(idu == "45024000AC0001")
```

```{r}

ajout_parc_direct <- inter_parc_24 %>% 
  filter(!idu %in% inter_parc_23$idu)

ajout_parc_tot <- parcelle_24 %>% 
  filter(!idu %in% parcelle_23$idu)

ajout_parc_bis <- ajout_parc_tot %>%
  st_filter(extended_borders, .predicate = st_intersects)

supp_parc_direct <- inter_parc_23 %>% 
  filter(!idu %in% inter_parc_24$idu)

supp_parc_tot <- parcelle_23 %>% 
  filter(!idu %in% parcelle_24$idu)

supp_parc_bis <- supp_parc_tot %>%
  st_filter(extended_borders, .predicate = st_intersects)

df_comp <- inter_parc_24 %>%
  filter(!idu %in% ajout_parc_direct$idu) %>% 
  st_filter(inter_parc_23, .predicate = st_equals)
# Parcelles n'ayant pas été modifiées

meth_geom <- inter_parc_24 %>% 
  filter(!idu %in% df_comp$idu & !idu %in% ajout_parc_direct$idu)
# Parcelles ayant été modifiées + ajoutées
```









```{r}
parcelles_85<-st_read("./cadastre-85-parcelles.json")
parcelles_85_2023 <- st_read("./cadastre-85-parcelles-2023.json")

# Renseigne la geometry (Multypolygon)
# dimension: XY fait référence à un système de coordonnées dans un espace euclidien
# bbox: désigne les coordonnées du cadre contenant/entourant nos objets spaciaux
# CRS: désigne le système de projection à travers son code EPSG

# Problème de géomètrie invalide ??
valid_parcelles <- st_is_valid(parcelles_45_2023)
# Affichez le nombre de géométries invalides
print(length(parcelles_45_2023[!valid_parcelles, ]))
parcelles_45_2023 <- st_make_valid(parcelles_45_2023)

valid_parcelles <- st_is_valid(parcelles_45)
# Affichez le nombre de géométries invalides
print(length(parcelles_45[!valid_parcelles, ]))
parcelles_45 <- st_make_valid(parcelles_45)

rm(valid_parcelles)
```

```{r}

parcelles_45$created <- ymd(parcelles_45$created)
parcelles_45$updated <- ymd(parcelles_45$updated)

parcelles_45_2023$created <- ymd(parcelles_45_2023$created)
parcelles_45_2023$updated <- ymd(parcelles_45_2023$updated)

date_millésime <-  "2023-04-01"
# max(parcelles_45_2023$updated)

chgt <- parcelles_45 %>% 
  filter(updated >= as.Date(date_millésime))

cree <- chgt %>% 
  filter(updated == created)

evol <- chgt %>% 
  filter(updated != created)

supp <- parcelles_45_2023 %>% 
  filter(!id %in% parcelles_45$id)
```

```{r}
mapview(list(chgt %>% st_buffer(dist = 5000), chgt), legend = FALSE, 
        layer.name = c("Loire-Atlantique avec un buffer de 5 km", "Loire-Atlantique"), col.regions = list("#440154FF", "#FDE725FF"))
```




