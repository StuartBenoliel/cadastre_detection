---
title: "Prise_en_main"
output: html_document
date: "2024-06-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

## Prise en maain des données

```{r}
library(sf)
library(dplyr)
library(lubridate)
library(mapview)
library(DBI)
library(ggplot2)
library(purrr)
source(file = "connexion_db.R")
conn<-connecter()
DBI::dbListTables(conn)
```

```{r}
DBI::dbListFields(conn,"parc_45")
DBI::dbListFields(conn,"parc_45_23")
```

```{r}
parcelle_get<-st_read(conn, query = "SELECT * FROM parc_45;")
commune_get<-st_read(conn, query = "SELECT * FROM com_45;")

```

```{r}
create_extended_borders <- function(commune, buffer_distance) {
  buffer_positive <- st_buffer(commune, buffer_distance)
  buffer_negative <- st_buffer(commune, -buffer_distance)
  buffer_difference <- st_difference(buffer_positive, buffer_negative)
  return(buffer_difference)
}

buffer_distance <- 50  

extended_borders <- commune_get %>%
  group_by(code_insee) %>%  
  do(extended = create_extended_borders(., buffer_distance))

extended_borders <- do.call(rbind, extended_borders$extended) %>%
  select(-c(4,5,6)) %>% 
  st_sf()

intersected_parcelles <- parcelle_get %>%
  st_filter(extended_borders, .predicate = st_intersects)

plot <- ggplot() +
  geom_sf(data = commune_get, aes(fill = "Communes"),color = "black", alpha = 0.5) +  
  geom_sf(data =  extended_borders , aes(fill = "Bordures étendues"), fill = "lightblue", alpha = 0.5, color = "lightblue") +  
  geom_sf(data = intersected_parcelles, aes(fill = "Parcelles croisées"), alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", "Parcelles croisées" = "purple")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales croisant les frontières étendues des communes du Loiret", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 50m de chaque côté de celles définies par l'IGN")

ggsave("parcelles_croisant_bordures.png", plot = plot, width = 12, height = 8, dpi = 300)
plot
```



```{r}
parcelles_45<-st_read("./cadastre-45-parcelles.json")
parcelles_45_2023 <- st_read("./cadastre-45-parcelles-2023.json")

# Renseigne la geometry (Multypolygon)
# dimension: XY fait référence à un système de coordonnées dans un espace euclidien
# bbox: désigne les coordonnées du cadre contenant/entourant nos objets spaciaux
# CRS: désigne le système de projection à travers son code EPSG

# Problème de géomètrie invalide ??
valid_parcelles <- st_is_valid(parcelles_45_2023)
# Affichez le nombre de géométries invalides
print(length(parcelles_45_2023[!valid_parcelles, ]))
parcelles_45_2023 <- st_make_valid(parcelles_45_2023)

valid_parcelles <- st_is_valid(parcelles_45)
# Affichez le nombre de géométries invalides
print(length(parcelles_45[!valid_parcelles, ]))
parcelles_45 <- st_make_valid(parcelles_45)

rm(valid_parcelles)
```

```{r}

parcelles_45$created <- ymd(parcelles_45$created)
parcelles_45$updated <- ymd(parcelles_45$updated)

parcelles_45_2023$created <- ymd(parcelles_45_2023$created)
parcelles_45_2023$updated <- ymd(parcelles_45_2023$updated)

date_millésime <-  "2023-04-01"
# max(parcelles_45_2023$updated)

chgt <- parcelles_45 %>% 
  filter(updated >= as.Date(date_millésime))

cree <- chgt %>% 
  filter(updated == created)

evol <- chgt %>% 
  filter(updated != created)

supp <- parcelles_45_2023 %>% 
  filter(!id %in% parcelles_45$id)
```

```{r}
mapview(list(chgt %>% st_buffer(dist = 5000), chgt), legend = FALSE, 
        layer.name = c("Loire-Atlantique avec un buffer de 5 km", "Loire-Atlantique"), col.regions = list("#440154FF", "#FDE725FF"))
```




