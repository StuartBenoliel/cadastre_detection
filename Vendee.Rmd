---
title: "Prise_en_main"
output: html_document
date: "2024-06-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

## Prise en maain des données

```{r package message=FALSE, warning=FALSE}
library(sf)
library(dplyr)
library(lubridate)
library(mapview)
library(DBI)
library(ggplot2)
library(purrr)
library(webshot)
library(pracma)
library(RColorBrewer)
library(tidyr)
library(stringr)
# webshot::install_phantomjs()
source(file = "connexion_db.R")
conn<-connecter()
DBI::dbListTables(conn)
```

```{r import}
parcelle_24 <- st_read(conn, query = "SELECT * FROM parc_85;")
parcelle_23 <- st_read(conn, query = "SELECT * FROM parc_85_23;")
commune <- st_read(conn, query = "SELECT * FROM com_85;")

ajout_parc_tot <- parcelle_24 %>% 
  filter(!idu %in% parcelle_23$idu)

supp_parc_tot <- parcelle_23 %>% 
  filter(!idu %in% parcelle_24$idu)
```

```{r bordure, message=FALSE}
create_extended_borders <- function(commune, buffer_distance) {
  buffer_positif <- st_buffer(commune, buffer_distance)
  buffer_negatif <- st_buffer(commune, -buffer_distance)
  suppressWarnings({
    buffer_difference <- st_difference(buffer_positif, buffer_negatif)
  })
  return(buffer_difference)
}
# Problème de parcelles au niveau du contour désormais

bordure <- commune %>%
  group_by(code_insee) %>%  
  do(extended = create_extended_borders(., 250))

bordure <- do.call(rbind, bordure$extended) %>%
  select(-c(4,5,6)) %>% 
  st_sf()

inter_parc_24 <- parcelle_24 %>%
  st_filter(bordure, .predicate = st_intersects)

inter_parc_23 <- parcelle_23 %>%
  st_filter(bordure, .predicate = st_intersects)

#ajout_parc_bad <- inter_parc_24 %>% 
#  filter(!idu %in% inter_parc_23$idu)
# Parcelle modifié n'étant plus dans la zone tampon considérée comme ajoutée

ajout_parc <- ajout_parc_tot %>%
  st_filter(bordure, .predicate = st_intersects) %>% 
  arrange(nom_com)

#supp_parc_bad <- inter_parc_23 %>% 
#  filter(!idu %in% inter_parc_24$idu)
# Parcelle modifié n'étant plus dans la zone tampon considérée comme supprimée

supp_parc <- supp_parc_tot %>%
  st_filter(bordure, .predicate = st_intersects) %>% 
  arrange(nom_com)

```

```{r ggplot bordure}
plot <- ggplot() +
  geom_sf(data = commune, aes(fill = "Communes"), color = "black", alpha = 0.5) +  
  geom_sf(data = bordure, aes(fill = "Bordures étendues"), fill = "lightblue", alpha = 0.5, color = "lightblue") +  
  geom_sf(data = inter_parc_24, aes(fill = "Parcelles croisées"), alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", "Parcelles croisées" = "purple")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales (2024) croisant les frontières étendues des communes de Vendée", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 250m de chaque côté de celles définies par l'IGN")

# ggsave("parcelles_croisant_bordures_85.png", plot = plot, width = 12, height = 8, dpi = 300)
# plot
```

```{r focus parcelle la tardiere}

map <- mapview(commune %>% 
                 filter(code_insee == "85289"), 
               layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure %>% 
            filter(code_insee == "85289"), 
          layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(parcelle_24 %>% 
            filter(code_com == "289"), 
          layer.name = "Parcelles (état 2024)", col.regions = "purple", alpha.regions = 0.5) +
  mapview(parcelle_23 %>% 
            filter(code_com %in% c("289", "053", "037")), 
          layer.name = "Parcelles (état 2023)", col.regions = "lightgreen", alpha.regions = 0.5)

# mapshot(map, url = "parcelles_tardiere.html")
```

```{r methode geometry base}
# Méthode au niveau de la géomètrie des parcelles
df_geom <- inter_parc_24 %>%
  filter(!idu %in% ajout_parc$idu) %>% 
  st_filter(inter_parc_23, .predicate = st_equals)
# Parcelles n'ayant pas été modifiées
# Attention : doit etre invariant en changeant l'ordre des tables

apres_geom <- inter_parc_24 %>% 
  filter(!idu %in% df_geom$idu & !idu %in% ajout_parc$idu) %>% 
  st_filter(bordure, .predicate = st_within) %>% 
  arrange(nom_com)

avant_geom <- inter_parc_23 %>% 
  filter(!idu %in% df_geom$idu & !idu %in% supp_parc$idu) %>% 
  st_filter(bordure, .predicate = st_within) %>% 
  arrange(nom_com)

identical_columns <- c()
# Comparer les colonnes communes
for (col in intersect(names(avant_geom), names(apres_geom))) {
  merged <- full_join(
    select(avant_geom %>% as.data.frame(), idu, !!sym(col)),
    select(apres_geom, idu, !!sym(col)),
    by = "idu",
    suffix = c("_avant", "_apres")
  )
  # Vérifier si les colonnes sont identiques
  if (all(merged[[paste0(col, "_avant")]] == merged[[paste0(col, "_apres")]], na.rm = TRUE)) {
    identical_columns <- c(identical_columns, col)
  }
}

modif_geom <- avant_geom %>% as.data.frame() %>% 
  full_join(apres_geom, by = identical_columns, suffix = c("_avant", "_apres"))

```

```{r ggplot methode geometry}
plot <- ggplot() +
  geom_sf(data = commune, aes(fill = "Communes"),color = "black", alpha = 0.5) +  
  geom_sf(data = bordure, aes(fill = "Bordures étendues"), fill = "lightblue", alpha = 0.5, color = "lightblue") +  
  geom_sf(data = apres_geom, aes(fill = "Parcelles modifiées (2024)"), alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = avant_geom, aes(fill = "Parcelles modifiées (2023)"), alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = ajout_parc, aes(fill = "Parcelles ajoutées"), alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = supp_parc, aes(fill = "Parcelles supprimées"), alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", "Parcelles modifiées (2024)" = "purple",
                               "Parcelles modifiées (2023)" = "pink", "Parcelles ajoutées" = "green", "Parcelles supprimées" = "red")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales croisant les frontières étendues des communes en Vendée, modifiés au niveau de la geometry en 2024", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 50m de chaque côté de celles définies par l'IGN")

ggsave("parcelles_bordures_modifiées_85.png", plot = plot, width = 12, height = 8, dpi = 300)
# plot
```


```{r mapview methode geometry}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(apres_geom, layer.name = "Parcelles modifiées (état 2024)", col.regions = "purple", alpha.regions = 0.5) +
  mapview(avant_geom, layer.name = "Parcelles modifiées (état 2023)", col.regions = "pink", alpha.regions = 0.5) +
  mapview(ajout_parc, layer.name = "Parcelles ajoutées", col.regions = "lightgreen", alpha.regions = 0.5) +
  mapview(supp_parc, layer.name = "Parcelles supprimées", col.regions = "red", alpha.regions = 0.5)

mapshot(map, url = "parcelles_modifiées_bordure_85.html")
```


```{r iou}

calculate_iou <- function(geometry_avant, geometry_apres) {
  if (!st_is_empty(geometry_avant) & !st_is_empty(geometry_apres)) {
    
    intersection <- st_intersection(geometry_avant, geometry_apres)
    
    if (length(intersection) == 0) {
      return(0) # Si les géométries ne s'intersectent pas du tout, IoU est 0
    }
    
    area_intersection <- st_area(intersection)
    union <- st_union(geometry_avant, geometry_apres)
    area_union <- st_area(union)
    
    return(as.numeric(area_intersection / area_union))
  } else {
    return(NA)
  }
}

calculate_iou_ajust <- function(geometry_avant, geometry_apres) {
  if (!st_is_empty(geometry_avant) & !st_is_empty(geometry_apres)) {
    # Calculer l'ajustement de la géométrie_avant
    centroid_apres <- st_centroid(geometry_apres)
    centroid_avant <- st_centroid(geometry_avant)
    translation_vector <- st_coordinates(centroid_apres)[1, 1:2] - st_coordinates(centroid_avant)[1, 1:2]
    geometry_avant_ajust <- st_geometry(geometry_avant) + translation_vector
    iou_ajust <- calculate_iou(st_set_crs(geometry_avant_ajust, 2154), geometry_apres)
    
    return(iou_ajust)
  } else {
    return(NA)
  }
}

modif_geom <- modif_geom %>%
  rowwise() %>% 
  mutate(
    iou = calculate_iou(st_geometry(geometry_avant), st_geometry(geometry_apres)),
    iou_ajust = calculate_iou_ajust(st_geometry(geometry_avant), st_geometry(geometry_apres)),
  )

modif_geom <- modif_geom %>% 
  filter(iou < 0.99)

quantiles <- quantile(modif_geom$iou_ajust, probs = c(0.01, 0.03, 0.05, 0.1), na.rm = TRUE)

apres_geom <- modif_geom %>% select(idu, iou, iou_ajust) %>%
  left_join(apres_geom, by = "idu") %>% 
  st_as_sf() %>% 
  st_set_crs(2154) %>% 
  ungroup()

avant_geom <- modif_geom %>% select(idu, iou, iou_ajust) %>% 
  left_join(avant_geom, by = "idu") %>% 
  st_as_sf() %>% 
  st_set_crs(2154) %>% 
  ungroup()

translation_apres <- apres_geom %>% 
  filter(iou_ajust > 0.99) %>% 
  select(-iou) %>% 
  mutate(idu_translate = idu)

redef_contours_apres <- apres_geom %>% 
  filter(iou > 0.95 & iou_ajust < 0.99) %>% 
  mutate(iou_multi = iou,
         participants_avant = idu,
         participants_apres = idu)

redef_contours_et_translation <- apres_geom %>% 
  filter(iou < 0.95 & iou_ajust > 0.95 & iou_ajust < 0.99) %>% 
  select(-iou) %>% 
  mutate(idu_translate = idu)

apres_geom <- apres_geom %>%
  filter(!idu %in% translation_apres$idu) %>% 
  filter(!idu %in% redef_contours_apres$idu) %>% 
  filter(!idu %in% redef_contours_et_translation$idu) %>% 
  filter(!is.na(iou))

avant_geom <- avant_geom %>%
  filter(!idu %in% translation_apres$idu) %>% 
  filter(!idu %in% redef_contours_apres$idu) %>% 
  filter(!idu %in% redef_contours_et_translation$idu)
```


```{r distib iou}
plot <- ggplot(na.omit(modif_geom), aes(x = iou_ajust)) +
  geom_histogram(aes(y = after_stat(density)), binwidth = 0.005, fill = "skyblue", color = "black", alpha = 0.7) +
  geom_segment(x = quantiles[1], xend = quantiles[1], y = 0, yend = 9, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[2], xend = quantiles[2], y = 0, yend = 12, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[3], xend = quantiles[3], y = 0, yend = 15, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[4], xend = quantiles[4], y = 0, yend = 19, color = "blue", linetype = "dashed", linewidth = 0.6) +
  annotate("text", x = quantiles[1], y = 10, label = paste0("1% Quantile: ", round(quantiles[1], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[2], y = 13, label = paste0("3% Quantile: ", round(quantiles[2], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[3], y = 16, label = paste0("5% Quantile: ", round(quantiles[3], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[4], y = 20, label = paste0("10% Quantile: ", round(quantiles[4], 2)), color = "blue", vjust = -1.5) +
  labs(title = "Histogramme de la variable iou_ajust avec quantiles",
       x = "iou_ajust",
       y = "Fréquence") +
  theme_bw()

# ggsave("Distribution_iou.png", plot = plot, width = 12, height = 8, dpi = 300)
```


```{r focus parcelle fusion}

ajout_parc <- ajout_parc %>% 
  st_filter(bordure, .predicate = st_within) %>% 
  arrange(nom_com)

supp_parc <- supp_parc %>% 
  st_filter(bordure, .predicate = st_within) %>% 
  arrange(nom_com)

parc_com_abs_apres <- ajout_parc %>% 
  filter(com_abs != "000") %>%
  mutate(idu_avant = paste0(substr(idu,1,2),
                            com_abs, 
                            "000", 
                            substr(idu,9,14))
  )

parc_com_abs_avant <- supp_parc %>% 
  filter(idu %in% parc_com_abs_apres$idu_avant)

parc_com_abs_apres <- parc_com_abs_apres %>% 
  filter(idu_avant %in% parc_com_abs_avant$idu)
# Parcelles n'ayant pas été modifiées mise à part le nom de commune
```

```{r focus parcelle changement de communes}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(parc_com_abs_apres_bis, layer.name = "Parcelles abs_bis (état 2024)", col.regions = "purple", alpha.regions = 0.5) +
  mapview(parc_com_abs_avant, layer.name = "Parcelles abs (état 2023)", col.regions = "lightgreen", alpha.regions = 0.5) +
  mapview(df_abs, layer.name = "Parcelles df_abs (état 2024)", col.regions = "purple", alpha.regions = 0.5)

# mapshot(map, url = "parcelles_abs.html")
```

```{r geometry 2}
# Méthode au niveau de la géomètrie des parcelles
df_geom_a <- ajout_parc %>%
  st_filter(supp_parc, .predicate = st_equals)
# Parcelles n'ayant pas été modifiées

df_geom_s <- supp_parc %>%
  st_filter(ajout_parc, .predicate = st_equals)

ajout_parc <- ajout_parc %>% 
  filter(!idu %in% df_geom_a$idu) %>% 
  arrange(nom_com)

supp_parc <- supp_parc %>% 
  filter(!idu %in% df_geom_s$idu) %>% 
  arrange(nom_com)
```

```{r iou ajout/sup}
calculate_iou_for_polygon <- function(polygon, ajout_parc) {
  
  intersecting_geoms <- ajout_parc %>%
    st_filter(st_buffer(polygon, -1), .predicate = st_intersects)
  
  # Récupérer les noms des polygones participants
  names_participants <- intersecting_geoms$idu
  if (isempty(names_participants)) {
    return(list(iou = NA, participants = NA))
  }
  
  # Faire l'union des géométries
  combined_geom <- st_union(intersecting_geoms)
  
  # Calculer l'IOU
  iou_value <- calculate_iou(combined_geom, polygon)
  
  list(iou = iou_value, participants = paste(names_participants, collapse = ", "))
}

supp_parc <- supp_parc %>%
  rowwise() %>%
  mutate(result = list(calculate_iou_for_polygon(geometry, ajout_parc))) %>%
  mutate(iou = result$iou,
         participants = result$participants) %>%
  ungroup() %>%
  select(-result)

ajout_parc <- ajout_parc %>%
  rowwise() %>%
  mutate(result = list(calculate_iou_for_polygon(geometry, supp_parc))) %>%
  mutate(iou = result$iou,
         participants = result$participants) %>%
  ungroup() %>%
  select(-result)

fusion <- ajout_parc %>% 
  filter(iou > 0.99 & nchar(participants) != 14)
# 32
# 42 

subdiv <- supp_parc %>% 
  filter(iou > 0.99 & nchar(participants) != 14)
# 225
# 498

ajout_parc <- ajout_parc %>%
  filter(!idu %in% unlist(str_split(subdiv$participants, ",\\s*"))) %>% 
  filter(!idu %in% fusion$idu & iou < 0.99 | is.na(iou))

# 1039
# 238
supp_parc <- supp_parc %>%
  filter(!idu %in% unlist(str_split(fusion$participants, ",\\s*"))) %>% 
  filter(!idu %in% subdiv$idu & iou < 0.99 | is.na(iou))

# 590
# 244
```

```{r découpage compliquée}

calculate_iou_multi_polygon <- function(polygon, supp_parc, ajout_parc) {
  
  n <- 0
  names_participants_avant <- NULL
  repeat {
    # Trouver les polygones dans supp_parc qui intersectent avec le polygon actuel
    intersecting_geoms_avant <- supp_parc %>%
      st_filter(polygon, .predicate = st_intersects)
    
    if (nrow(intersecting_geoms_avant) == n) break
    
    # Mettre à jour le polygon en faisant l'union des géométries trouvées
    polygon <- st_union(intersecting_geoms_avant)
    names_participants_avant <- intersecting_geoms_avant$idu
    n <- nrow(intersecting_geoms_avant)
  }
  
  intersecting_geoms_apres <- ajout_parc %>%
    st_filter(st_buffer(polygon, -1), .predicate = st_intersects)
  
  # Récupérer les noms des polygones participants
  names_participants_apres <- intersecting_geoms_apres$idu
  if (isempty(names_participants_apres)) {
    return(list(iou = NA, participants_avant = NA, participants_apres = NA))
  }
  
  # Faire l'union des géométries
  combined_geom_apres <- st_union(intersecting_geoms_apres)
  
  # Calculer l'IOU
  iou_value <- calculate_iou(combined_geom_apres, polygon)
  
  list(iou = iou_value, participants_avant = paste(names_participants_avant, collapse = ", "),
       participants_apres = paste(names_participants_apres, collapse = ", "))
}

supp_parc <- supp_parc %>%
  rowwise() %>%
  mutate(result = list(calculate_iou_multi_polygon(geometry, supp_parc, ajout_parc))) %>%
  mutate(iou_multi = result$iou,
         participants_avant = result$participants_avant,
         participants_apres= result$participants_apres) %>%
  ungroup() %>%
  select(-result)

multi_subdiv <- supp_parc %>% 
  filter(iou_multi > 0.99 & nchar(participants_avant) != nchar(participants_apres))

redef_contours <- supp_parc %>% 
  filter((iou_multi > 0.95 & nchar(participants_avant) == nchar(participants_apres)) | nchar(participants_avant) == 14 & nchar(participants_apres) == 14)

ajout_parc <- ajout_parc %>%
  filter(!idu %in% unlist(str_split(multi_subdiv$participants_apres, ",\\s*"))) %>% 
  filter(!idu %in% unlist(str_split(redef_contours$participants_apres, ",\\s*")))

supp_parc <- supp_parc %>%
  filter(!idu %in% unlist(str_split(multi_subdiv$participants_avant, ",\\s*"))) %>% 
  filter(!idu %in% unlist(str_split(redef_contours$participants_avant, ",\\s*")))

```

```{r changement forme + ou découpage compliquée}
supp_parc <- supp_parc %>%
  rowwise() %>%
  mutate(result = list(calculate_iou_multi_polygon(geometry, supp_parc, ajout_parc))) %>%
  mutate(iou_multi = result$iou,
         participants_avant = result$participants_avant,
         participants_apres= result$participants_apres) %>%
  ungroup() %>%
  select(-result)

# Cas d'une parcelle spécial 850040000F0149
redef_contours <- supp_parc %>% 
  filter(nchar(participants_avant) == 14 & nchar(participants_apres) == 14) %>% 
  rbind(redef_contours)

redef_contours <- supp_parc %>% 
  filter(iou_multi > 0.95 & nchar(participants_avant) == nchar(participants_apres)) %>% 
  rbind(redef_contours)

veritable_ajout <- ajout_parc %>%
  filter(is.na(iou))

veritable_supp <- supp_parc %>%
  filter(is.na(iou))

ajout_parc <- ajout_parc %>%
  filter(!idu %in% unlist(str_split(redef_contours$participants_apres, ",\\s*"))) %>%
  filter(!is.na(iou))

supp_parc <- supp_parc %>%
  filter(!idu %in% unlist(str_split(redef_contours$participants_avant, ",\\s*"))) %>%
  filter(!is.na(iou))

redef_contours_et_transfo <- supp_parc %>% 
  filter(iou_multi > 0.95)

ajout_parc <- ajout_parc %>%
  filter(!idu %in% unlist(str_split(redef_contours_et_transfo$participants_apres, ",\\s*")))

supp_parc <- supp_parc %>%
  filter(!idu %in% unlist(str_split(redef_contours_et_transfo$participants_avant, ",\\s*")))

```

```{r parcelles en translation enquiquinante}

calculate_iou_for_polygon_translate <- function(polygon, ajout_parc) {
  
  intersecting_geoms <- ajout_parc %>%
    st_filter(st_buffer(polygon, -1), .predicate = st_intersects)
  
  # Récupérer les noms des polygones participants
  names_participants <- intersecting_geoms$idu
  if (isempty(names_participants)) {
    return(list(iou_ajust = NA, idu_translate = NA))
  }
  
  max_iou <- -Inf
  best_idu <- NA
  
  # Boucler sur chaque polygone intersectant
  for (i in seq_len(nrow(intersecting_geoms))) {
    current_geom <- intersecting_geoms[i, ]
    
    # Calculer l'IoU entre le polygone courant et le polygone initial
    iou_value <- suppressWarnings({calculate_iou(current_geom, polygon)})
    
    # Si l'IoU courant est plus élevé que l'IoU maximum trouvé jusqu'à présent
    if (iou_value > max_iou) {
      max_iou <- iou_value
      best_indice <- i
      best_idu <- current_geom$idu
    }
  }
  geom <- intersecting_geoms[best_indice, ]
  iou_ajust <- calculate_iou_ajust(geom, polygon)
  
  list(iou_ajust = iou_ajust, idu_translate = geom$idu)
}

ajout_parc <- ajout_parc %>%
  rowwise() %>%
  mutate(result = list(calculate_iou_for_polygon_translate(geometry, supp_parc))) %>%
  mutate(iou_ajust = result$iou_ajust,
         idu_translate = result$idu_translate) %>%
  ungroup() %>%
  select(-result)
  
translation_apres <- ajout_parc %>% 
  filter(iou_ajust > 0.99) %>% 
  select(-iou,-participants) %>% 
  rbind(translation_apres)

redef_contours_et_translation <- ajout_parc %>% 
  filter(iou_ajust > 0.95 & iou_ajust < 0.99) %>% 
  select(-iou,-participants) %>% 
  rbind(redef_contours_et_translation)

ajout_parc<- ajout_parc %>%
  filter(!idu %in% translation_apres$idu) %>% 
  filter(!idu %in% redef_contours_et_translation$idu)

supp_parc <- supp_parc %>%
  filter(!idu %in% translation_apres$idu_translate)%>% 
  filter(!idu %in% redef_contours_et_translation$idu_translate)
```


```{r}
apres_geom <- apres_geom %>%
  rowwise() %>%
  mutate(result = list(calculate_iou_multi_polygon(geometry, apres_geom, avant_geom))) %>%
  mutate(iou_multi = result$iou,
         participants_avant = result$participants_avant,
         participants_apres= result$participants_apres) %>%
  ungroup() %>%
  select(-result)

redef_contours_apres <- apres_geom %>% 
  filter(iou_multi > 0.95 & nchar(participants_avant) == nchar(participants_apres) | 
           nchar(participants_avant) == 14 & nchar(participants_apres) == 14 & iou > iou_ajust) %>% 
  rbind(redef_contours_apres)

redef_contours_et_translation <- apres_geom %>% 
  filter(nchar(participants_avant) == 14 & nchar(participants_apres) == 14 & iou < iou_ajust |
           is.na(iou_multi)) %>% 
  select(-iou, -participants_avant, -participants_apres, -iou_multi) %>% 
  mutate(idu_translate = idu) %>% 
  rbind(redef_contours_et_translation)

apres_geom <- apres_geom %>%
  filter(!idu %in% redef_contours_apres$idu) %>% 
  filter(!idu %in% redef_contours_et_translation$idu) %>% 
  filter(!is.na(iou))

avant_geom <- avant_geom %>%
  filter(!idu %in% redef_contours_apres$idu) %>% 
  filter(!idu %in% redef_contours_et_translation$idu)

```


```{r mapview iou}

map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5,
               homebutton = F) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5,
          homebutton = F) +
  mapview(apres_geom,
          z=c("iou_ajust"), layer.name = "Parcelles modifiées restantes (état 2024)", 
          alpha.regions = 0.5,
          homebutton = F) +
  mapview(avant_geom, 
          z=c("iou_ajust"), layer.name = "Parcelles modifiées restantes (état 2023)", 
          alpha.regions = 0.5,
          homebutton = F) +
  mapview(translation_apres,
          z=c("iou_ajust"), layer.name = "Parcelles translatées (état 2024)", 
          alpha.regions = 0.5,
          homebutton = F) +
  mapview(inter_parc_23 %>%
            filter(idu %in% translation_apres$idu_translate), 
          layer.name = "Parcelles translatées (état 2023)", 
          alpha.regions = 0.5,
          homebutton = F) +
  mapview(fusion, layer.name = "Parcelles fusionnéees (état 2024)", col.regions = "orange", alpha.regions = 0.5,
          homebutton = F) +
  mapview(supp_parc_tot %>%
            filter(idu %in% unlist(str_split(fusion$participants, ",\\s*"))),  
          layer.name = "Parcelles avant fusion (état 2023)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(ajout_parc_tot %>%
            filter(idu %in% unlist(str_split(subdiv$participants, ",\\s*"))),  
          layer.name = "Parcelles subdivisées (état 2024)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(subdiv,  layer.name = "Parcelles avant subdivision (état 2023)", col.regions = "orange", alpha.regions = 0.5,
          homebutton = F) +
  mapview(ajout_parc_tot %>%
            filter(idu %in% unlist(str_split(multi_subdiv$participants_apres, ",\\s*"))),  
          layer.name = "Parcelles après multi-subdivision (état 2024)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(multi_subdiv,  layer.name = "Parcelles avant multi-subdivision (état 2023)", col.regions = "orange", alpha.regions = 0.5,
          homebutton = F) +
  mapview(ajout_parc_tot %>%
            filter(idu %in% unlist(str_split(redef_contours$participants_apres, ",\\s*"))),  
          layer.name = "Parcelles après évolution forme (état 2024)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(redef_contours,  layer.name = "Parcelles avant évolution forme (état 2023)", col.regions = "purple", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(redef_contours_apres,  
          layer.name = "Parcelles après évolution forme (état 2024)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(inter_parc_23 %>%
            filter(idu %in% redef_contours_apres$idu),  
          layer.name = "Parcelles avant évolution forme (état 2023)", col.regions = "purple", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_parc_tot %>%
            filter(idu %in% unlist(str_split(redef_contours_et_transfo$participants_apres, ",\\s*"))),  
          layer.name = "Parcelles ayant transfo + évolution forme (état 2024)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(redef_contours_et_transfo,
          layer.name = "Parcelles ayant transfo + évolution forme (état 2023)", col.regions = "orange", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(redef_contours_et_translation,  
          layer.name = "Parcelles ayant translatées + évolution forme (état 2024)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(inter_parc_23 %>%
            filter(idu %in% redef_contours_et_translation$idu_translate),
          layer.name = "Parcelles ayant translatées + évolution forme (état 2023)", col.regions = "orange", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(parc_com_abs_apres,  layer.name = "Parcelles après fusion de communes (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(parc_com_abs_avant,  layer.name = "Parcelles avant fusion de communes (état 2023)", col.regions = "purple", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(veritable_ajout, layer.name = "Parcelles véritablement ajoutées", alpha.regions = 0.5,
          col.regions = "green", homebutton = F) +
  mapview(veritable_supp, layer.name = "Parcelles véritablement supprimées", alpha.regions = 0.5,
          col.regions = "red", homebutton = F) +
  mapview(ajout_parc, z=c("iou"), layer.name = "Parcelles restantes (état 2024)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(supp_parc, z=c("iou"), layer.name = "Parcelles restantes (état 2023)", alpha.regions = 0.5,
          homebutton = F)

mapshot(map, url = "parcelles_iou_inside_bordure_85.html")
```


```{r evolution superficie}
evol_sup <- modif_geom %>% 
  mutate(superficie_apres = st_area(geometry_apres),
         superficie_avant = st_area(geometry_avant)) %>% 
  group_by(code_com) %>% 
  summarise(modif_superficie_apres = round(sum(superficie_apres),2),
            modif_superficie_avant = round(sum(superficie_avant),2),
            modif_evolution_superficie = modif_superficie_apres - modif_superficie_avant)

ajout_sup <- ajout_parc %>% 
  mutate(superficie = st_area(geometry)) %>% 
  group_by(code_com) %>% 
  summarise(superficie_ajoute = round(sum(superficie),2)) %>% 
  st_drop_geometry()

supprime_sup <- supp_parc %>% 
  mutate(superficie = st_area(geometry)) %>% 
  group_by(code_com) %>% 
  summarise(superficie_supprime = round(sum(superficie),2)) %>% 
  st_drop_geometry()

evol_sup <- evol_sup %>% 
  full_join(ajout_sup, by = "code_com") %>% 
  full_join(supprime_sup, by = "code_com") %>% 
  mutate(across(everything(), ~ replace_na(.x, units::set_units(0, m*m)))) %>% 
  mutate(tot_evolution_superficie = round(modif_evolution_superficie + superficie_ajoute - superficie_supprime,2))
```

