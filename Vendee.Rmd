---
title: "Prise_en_main"
output: html_document
date: "2024-06-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
install.packages("webshot")
install.packages("pracma")
```

## Prise en maain des données

```{r package message=FALSE, warning=FALSE}
library(sf)
library(dplyr)
library(lubridate)
library(mapview)
library(DBI)
library(ggplot2)
library(purrr)
library(webshot)
library(pracma)
library(RColorBrewer)
library(tidyr)
library(stringr)
# webshot::install_phantomjs()
source(file = "connexion_db.R")
conn<-connecter()
DBI::dbListTables(conn)
```

```{r import}
parcelle_24 <- st_read(conn, query = "SELECT * FROM parc_85;")
parcelle_23 <- st_read(conn, query = "SELECT * FROM parc_85_23;")
commune <- st_read(conn, query = "SELECT * FROM com_85;")

ajout_parc_tot <- parcelle_24 %>% 
  filter(!idu %in% parcelle_23$idu)

supp_parc_tot <- parcelle_23 %>% 
  filter(!idu %in% parcelle_24$idu)
```

```{r bordure, message=FALSE}
create_extended_borders <- function(commune, buffer_distance) {
  buffer_positif <- st_buffer(commune, buffer_distance)
  buffer_negatif <- st_buffer(commune, -buffer_distance)
  suppressWarnings({
    buffer_difference <- st_difference(buffer_positif, buffer_negatif)
  })
  return(buffer_difference)
}
# Problème de parcelles au niveau du contour désormais

bordure <- commune %>%
  group_by(code_insee) %>%  
  do(extended = create_extended_borders(., 250))

bordure <- do.call(rbind, bordure$extended) %>%
  select(-c(4,5,6)) %>% 
  st_sf()

inter_parc_24 <- parcelle_24 %>%
  st_filter(bordure, .predicate = st_intersects)

inter_parc_23 <- parcelle_23 %>%
  st_filter(bordure, .predicate = st_intersects)

#ajout_parc_bad <- inter_parc_24 %>% 
#  filter(!idu %in% inter_parc_23$idu)
# Parcelle modifié n'étant plus dans la zone tampon considérée comme ajoutée

ajout_parc <- ajout_parc_tot %>%
  st_filter(bordure, .predicate = st_intersects) %>% 
  arrange(nom_com)

#supp_parc_bad <- inter_parc_23 %>% 
#  filter(!idu %in% inter_parc_24$idu)
# Parcelle modifié n'étant plus dans la zone tampon considérée comme supprimée

supp_parc <- supp_parc_tot %>%
  st_filter(bordure, .predicate = st_intersects) %>% 
  arrange(nom_com)

```


```{r ggplot bordure}
plot <- ggplot() +
  geom_sf(data = commune, aes(fill = "Communes"), color = "black", alpha = 0.5) +  
  geom_sf(data = bordure, aes(fill = "Bordures étendues"), fill = "lightblue", alpha = 0.5, color = "lightblue") +  
  geom_sf(data = inter_parc_24, aes(fill = "Parcelles croisées"), alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", "Parcelles croisées" = "purple")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales (2024) croisant les frontières étendues des communes de Vendée", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 250m de chaque côté de celles définies par l'IGN")

# ggsave("parcelles_croisant_bordures_85.png", plot = plot, width = 12, height = 8, dpi = 300)
# plot
```

```{r focus parcelle changement de communes}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(inter_parc_24, layer.name = "Parcelles (état 2024)", col.regions = "purple", alpha.regions = 0.5) +
  mapview(inter_parc_23, layer.name = "Parcelles (état 2023)", col.regions = "lightgreen", alpha.regions = 0.5) +
  mapview(ajout_parc, layer.name = "Parcelles ajoutées", col.regions = "purple", alpha.regions = 0.5) +
  mapview(supp_parc, layer.name = "Parcelles supprimées", col.regions = "lightgreen", alpha.regions = 0.5)

mapshot(map, url = "parcelles_tot.html")
```

```{r methode geometry base}
# Méthode au niveau de la géomètrie des parcelles
df_geom <- inter_parc_24 %>%
  filter(!idu %in% ajout_parc$idu) %>% 
  st_filter(inter_parc_23, .predicate = st_equals)
# Parcelles n'ayant pas été modifiées
# Attention : doit etre invariant en changeant l'ordre des tables

apres_geom <- inter_parc_24 %>% 
  filter(!idu %in% df_geom$idu & !idu %in% ajout_parc$idu) %>% 
  st_filter(bordure, .predicate = st_within) %>% 
  arrange(nom_com)

avant_geom <- inter_parc_23 %>% 
  filter(!idu %in% df_geom$idu & !idu %in% supp_parc$idu) %>% 
  st_filter(bordure, .predicate = st_within) %>% 
  arrange(nom_com)

identical_columns <- c()
# Comparer les colonnes communes
for (col in intersect(names(avant_geom), names(apres_geom))) {
  merged <- full_join(
    select(avant_geom %>% as.data.frame(), idu, !!sym(col)),
    select(apres_geom, idu, !!sym(col)),
    by = "idu",
    suffix = c("_avant", "_apres")
  )
  # Vérifier si les colonnes sont identiques
  if (all(merged[[paste0(col, "_avant")]] == merged[[paste0(col, "_apres")]], na.rm = TRUE)) {
    identical_columns <- c(identical_columns, col)
  }
}

modif_geom <- avant_geom %>% as.data.frame() %>% 
  full_join(apres_geom, by = identical_columns, suffix = c("_avant", "_apres"))

evol_sup <- modif_geom %>% 
  mutate(superficie_apres = st_area(geometry_apres),
         superficie_avant = st_area(geometry_avant)) %>% 
  group_by(code_com) %>% 
  summarise(modif_superficie_apres = round(sum(superficie_apres),2),
            modif_superficie_avant = round(sum(superficie_avant),2),
            modif_evolution_superficie = modif_superficie_apres - modif_superficie_avant)

ajout_sup <- ajout_parc %>% 
  mutate(superficie = st_area(geometry)) %>% 
  group_by(code_com) %>% 
  summarise(superficie_ajoute = round(sum(superficie),2)) %>% 
  st_drop_geometry()

supprime_sup <- supp_parc %>% 
  mutate(superficie = st_area(geometry)) %>% 
  group_by(code_com) %>% 
  summarise(superficie_supprime = round(sum(superficie),2)) %>% 
  st_drop_geometry()

evol_sup <- evol_sup %>% 
  full_join(ajout_sup, by = "code_com") %>% 
  full_join(supprime_sup, by = "code_com") %>% 
  mutate(across(everything(), ~ replace_na(.x, units::set_units(0, m*m)))) %>% 
  mutate(tot_evolution_superficie = round(modif_evolution_superficie + superficie_ajoute - superficie_supprime,2))

```

```{r ggplot methode geometry}
plot <- ggplot() +
  geom_sf(data = commune, aes(fill = "Communes"),color = "black", alpha = 0.5) +  
  geom_sf(data = bordure, aes(fill = "Bordures étendues"), fill = "lightblue", alpha = 0.5, color = "lightblue") +  
  geom_sf(data = apres_geom, aes(fill = "Parcelles modifiées (2024)"), alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = avant_geom, aes(fill = "Parcelles modifiées (2023)"), alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = ajout_parc, aes(fill = "Parcelles ajoutées"), alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = supp_parc, aes(fill = "Parcelles supprimées"), alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", "Parcelles modifiées (2024)" = "purple",
                               "Parcelles modifiées (2023)" = "pink", "Parcelles ajoutées" = "green", "Parcelles supprimées" = "red")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales croisant les frontières étendues des communes en Vendée, modifiés au niveau de la geometry en 2024", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 50m de chaque côté de celles définies par l'IGN")

ggsave("parcelles_bordures_modifiées_85.png", plot = plot, width = 12, height = 8, dpi = 300)
# plot
```


```{r mapview methode geometry}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(apres_geom, layer.name = "Parcelles modifiées (état 2024)", col.regions = "purple", alpha.regions = 0.5) +
  mapview(avant_geom, layer.name = "Parcelles modifiées (état 2023)", col.regions = "pink", alpha.regions = 0.5) +
  mapview(ajout_parc, layer.name = "Parcelles ajoutées", col.regions = "lightgreen", alpha.regions = 0.5) +
  mapview(supp_parc, layer.name = "Parcelles supprimées", col.regions = "red", alpha.regions = 0.5)

mapshot(map, url = "parcelles_modifiées_bordure_85.html")
```


```{r iou}

calculate_iou <- function(geometry_avant, geometry_apres) {
  if (!st_is_empty(geometry_avant) & !st_is_empty(geometry_apres)) {
    
    intersection <- st_intersection(geometry_avant, geometry_apres)
    
    if (length(intersection) == 0) {
      return(0) # Si les géométries ne s'intersectent pas du tout, IoU est 0
    }
    
    area_intersection <- st_area(intersection)
    union <- st_union(geometry_avant, geometry_apres)
    area_union <- st_area(union)
    
    return(as.numeric(area_intersection / area_union))
  } else {
    return(NA)
  }
}

calculate_iou_ajust <- function(geometry_avant, geometry_apres) {
  if (!st_is_empty(geometry_avant) & !st_is_empty(geometry_apres)) {
    # Calculer l'ajustement de la géométrie_avant
    centroid_apres <- st_centroid(geometry_apres)
    centroid_avant <- st_centroid(geometry_avant)
    translation_vector <- st_coordinates(centroid_apres)[1, 1:2] - st_coordinates(centroid_avant)[1, 1:2]
    geometry_avant_ajust <- st_geometry(geometry_avant) + translation_vector
    iou_ajust <- calculate_iou(st_set_crs(geometry_avant_ajust, 2154), geometry_apres)
    
    return(iou_ajust)
  } else {
    return(NA)
  }
}

modif_geom <- modif_geom %>%
  rowwise() %>% 
  mutate(
    iou_ajust = calculate_iou_ajust(st_geometry(geometry_avant), st_geometry(geometry_apres)),
  )

quantiles <- quantile(modif_geom$iou_ajust, probs = c(0.01, 0.03, 0.05, 0.1), na.rm = TRUE)

plot <- ggplot(na.omit(modif_geom), aes(x = iou_ajust)) +
  geom_histogram(aes(y = after_stat(density)), binwidth = 0.005, fill = "skyblue", color = "black", alpha = 0.7) +
  geom_segment(x = quantiles[1], xend = quantiles[1], y = 0, yend = 9, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[2], xend = quantiles[2], y = 0, yend = 12, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[3], xend = quantiles[3], y = 0, yend = 15, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[4], xend = quantiles[4], y = 0, yend = 19, color = "blue", linetype = "dashed", linewidth = 0.6) +
  annotate("text", x = quantiles[1], y = 10, label = paste0("1% Quantile: ", round(quantiles[1], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[2], y = 13, label = paste0("3% Quantile: ", round(quantiles[2], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[3], y = 16, label = paste0("5% Quantile: ", round(quantiles[3], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[4], y = 20, label = paste0("10% Quantile: ", round(quantiles[4], 2)), color = "blue", vjust = -1.5) +
  labs(title = "Histogramme de la variable iou_ajust avec quantiles",
       x = "iou_ajust",
       y = "Fréquence") +
  theme_bw()

# ggsave("Distribution_iou.png", plot = plot, width = 12, height = 8, dpi = 300)

avant_geom <- avant_geom %>% 
  left_join(modif_geom %>% select(idu, iou_ajust), by = "idu")

apres_geom <- apres_geom %>% 
  left_join(modif_geom %>% select(idu, iou_ajust), by = "idu")
```

```{r focus parcelle changement de communes}

ajout_parc <- ajout_parc %>% 
  st_filter(bordure, .predicate = st_within) %>% 
  arrange(nom_com)

supp_parc <- supp_parc %>% 
  st_filter(bordure, .predicate = st_within) %>% 
  arrange(nom_com)

parc_com_abs_apres <- ajout_parc %>% 
  filter(com_abs != "000") %>%
  mutate(idu_avant = paste0(substr(idu,1,2),
                            com_abs, 
                            "000", 
                            substr(idu,9,14))
  )

parc_com_abs_avant <- supp_parc %>% 
  filter(idu %in% parc_com_abs_apres$idu_avant)

df_abs <- parc_com_abs_apres %>%
  st_filter(parc_com_abs_avant, .predicate = st_equals)
# Parcelles n'ayant pas été modifiées mise à part le nom de commune

parc_com_abs_apres <- parc_com_abs_apres %>% 
  filter(!idu %in% df_abs$idu)

parc_com_abs_avant <- parc_com_abs_avant %>% 
  filter(!idu %in% df_abs$idu_avant)

# Attention cas de parcelles crées (n'existant pas avant) mais ayant le numéro de 
# com_abs
```

```{r focus parcelle changement de communes}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(parc_com_abs_apres, layer.name = "Parcelles abs (état 2024)", col.regions = "purple", alpha.regions = 0.5) +
  mapview(parc_com_abs_avant, layer.name = "Parcelles abs (état 2023)", col.regions = "lightgreen", alpha.regions = 0.5) +
  mapview(ajout_parc, layer.name = "Parcelles ajoutées", col.regions = "purple", alpha.regions = 0.5) +
  mapview(supp_parc, layer.name = "Parcelles supprimées", col.regions = "lightgreen", alpha.regions = 0.5)

mapshot(map, url = "parcelles_abs.html")
```

```{r geometry 2}

# Méthode au niveau de la géomètrie des parcelles
df_geom_a <- ajout_parc %>%
  st_filter(supp_parc, .predicate = st_equals)
# Parcelles n'ayant pas été modifiées

df_geom_s <- supp_parc %>%
  st_filter(ajout_parc, .predicate = st_equals)

ajout_parc <- ajout_parc %>% 
  filter(!idu %in% df_geom_a$idu) %>% 
  st_filter(bordure, .predicate = st_within) %>% 
  arrange(nom_com)

supp_parc <- supp_parc %>% 
  filter(!idu %in% df_geom_s$idu) %>% 
  st_filter(bordure, .predicate = st_within) %>% 
  arrange(nom_com)
```

```{r iou ajout/sup}
calculate_iou_for_polygon <- function(polygon, ajout_parc) {
  
  intersecting_geoms <- ajout_parc %>%
    st_filter(st_buffer(polygon, -1), .predicate = st_intersects)
  
  # Récupérer les noms des polygones participants
  names_participants <- intersecting_geoms$idu
  if (isempty(names_participants)) {
    return(list(iou = NA, participants = NA))
  }
  
  # Faire l'union des géométries
  combined_geom <- st_union(intersecting_geoms)
  
  # Calculer l'IOU
  iou_value <- calculate_iou(combined_geom, polygon)
  
  list(iou = iou_value, participants = paste(names_participants, collapse = ", "))
}

supp_parc <- supp_parc %>%
  rowwise() %>%
  mutate(result = list(calculate_iou_for_polygon(geometry, ajout_parc))) %>%
  mutate(iou = result$iou,
         participants = result$participants) %>%
  ungroup() %>%
  select(-result)

ajout_parc <- ajout_parc %>%
  rowwise() %>%
  mutate(result = list(calculate_iou_for_polygon(geometry, supp_parc))) %>%
  mutate(iou = result$iou,
         participants = result$participants) %>%
  ungroup() %>%
  select(-result)

fusion <- ajout_parc %>% 
  filter(iou > 0.99 & nchar(participants) != 14)
# 32
# 42 

subdiv <- supp_parc %>% 
  filter(iou > 0.99 & nchar(participants) != 14)
# 225
# 498

ajout_parc <- ajout_parc %>%
  filter(!idu %in% unlist(str_split(subdiv$participants, ",\\s*"))) %>% 
  filter(!idu %in% fusion$idu & iou < 0.99)

# 1039
# 238
supp_parc <- supp_parc %>%
  filter(!idu %in% unlist(str_split(fusion$participants, ",\\s*"))) %>% 
  filter(!idu %in% subdiv$idu & iou < 0.99)

# 590
# 244
```

```{r découpage compliquée}

calculate_iou_multi_polygon <- function(polygon, supp_parc, ajout_parc) {
  
  n <- 0
  names_participants_avant <- NULL
  repeat {
    # Trouver les polygones dans supp_parc qui intersectent avec le polygon actuel
    intersecting_geoms_avant <- supp_parc %>%
      st_filter(polygon, .predicate = st_intersects)
    
    if (nrow(intersecting_geoms_avant) == n) break
    
    # Mettre à jour le polygon en faisant l'union des géométries trouvées
    polygon <- st_union(intersecting_geoms_avant)
    names_participants_avant <- intersecting_geoms_avant$idu
    n <- nrow(intersecting_geoms_avant)
  }
  
  intersecting_geoms_apres <- ajout_parc %>%
    st_filter(st_buffer(polygon, -1), .predicate = st_intersects)
  
  # Récupérer les noms des polygones participants
  names_participants_apres <- intersecting_geoms_apres$idu
  if (isempty(names_participants_apres)) {
    return(list(iou = NA, participants_avant = NA, participants_apres = NA))
  }
  
  # Faire l'union des géométries
  combined_geom_apres <- st_union(intersecting_geoms_apres)
  
  # Calculer l'IOU
  iou_value <- calculate_iou(combined_geom_apres, polygon)
  
  list(iou = iou_value, participants_avant = paste(names_participants_avant, collapse = ", "),
       participants_apres = paste(names_participants_apres, collapse = ", "))
}

supp_parc <- supp_parc %>%
  rowwise() %>%
  mutate(result = list(calculate_iou_multi_polygon(geometry, supp_parc, ajout_parc))) %>%
  mutate(iou_multi = result$iou,
         participants_avant = result$participants_avant,
         participants_apres= result$participants_apres) %>%
  ungroup() %>%
  select(-result)

multi_subdiv <- supp_parc %>% 
  filter(iou_multi > 0.99 & nchar(participants_avant) != nchar(participants_apres))

redef_contours <- supp_parc %>% 
  filter((iou_multi > 0.95 & nchar(participants_avant) == nchar(participants_apres)) | nchar(participants_avant) == 14 & nchar(participants_apres) == 14)

ajout_parc <- ajout_parc %>%
  filter(!idu %in% unlist(str_split(multi_subdiv$participants_apres, ",\\s*"))) %>% 
  filter(!idu %in% unlist(str_split(redef_contours$participants_apres, ",\\s*")))

supp_parc <- supp_parc %>%
  filter(!idu %in% unlist(str_split(multi_subdiv$participants_avant, ",\\s*"))) %>% 
  filter(!idu %in% unlist(str_split(redef_contours$participants_avant, ",\\s*")))

```

```{r changement forme + ou découpage compliquée}
supp_parc <- supp_parc %>%
  rowwise() %>%
  mutate(result = list(calculate_iou_multi_polygon(geometry, supp_parc, ajout_parc))) %>%
  mutate(iou_multi = result$iou,
         participants_avant = result$participants_avant,
         participants_apres= result$participants_apres) %>%
  ungroup() %>%
  select(-result)

# Cas d'une parcelle spécial 850040000F0149
redef_contours <- supp_parc %>% 
  filter(nchar(participants_avant) == 14 & nchar(participants_apres) == 14) %>% 
  rbind(redef_contours)

redef_contours <- supp_parc %>% 
  filter(iou_multi > 0.95 & nchar(participants_avant) == nchar(participants_apres)) %>% 
  rbind(redef_contours)


#decoupage_et_redef_contours <- supp_parc %>% 
#  filter(iou_multi > 0.95 )

```


```{r mapview iou}

apres_filtre <- apres_geom %>% filter(iou_ajust < quantiles[3] | is.na(iou_ajust))
avant_filtre <- avant_geom %>% filter(iou_ajust < quantiles[3] | is.na(iou_ajust))

map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5,
               homebutton = F) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5,
          homebutton = F) +
  mapview(apres_filtre,
          z=c("iou_ajust"), layer.name = "Parcelles modifiées iou < Q_5% = 0.934 (état 2024)", 
          alpha.regions = 0.5,
          homebutton = F) +
  mapview(avant_filtre, 
          z=c("iou_ajust"), layer.name = "Parcelles modifiées iou < Q_5% = 0.934 (état 2023)", 
          alpha.regions = 0.5,
          homebutton = F) +
  mapview(fusion, layer.name = "Parcelles fusionnéees (état 2024)", col.regions = "red", alpha.regions = 0.5,
          homebutton = F) +
  mapview(supp_parc_tot %>%
            filter(idu %in% unlist(str_split(fusion$participants, ",\\s*"))),  
          layer.name = "Parcelles avant fusion (état 2023)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(ajout_parc_tot %>%
            filter(idu %in% unlist(str_split(subdiv$participants, ",\\s*"))),  
          layer.name = "Parcelles subdivisées (état 2024)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(subdiv,  layer.name = "Parcelles avant subdivision (état 2023)", col.regions = "red", alpha.regions = 0.5,
          homebutton = F) +
  mapview(ajout_parc_tot %>%
            filter(idu %in% unlist(str_split(multi_subdiv$participants_apres, ",\\s*"))),  
          layer.name = "Parcelles après multi-subdivision (état 2024)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(multi_subdiv,  layer.name = "Parcelles avant multi-subdivision (état 2023)", col.regions = "red", alpha.regions = 0.5,
          homebutton = F) +
  mapview(ajout_parc_tot %>%
            filter(idu %in% unlist(str_split(redef_contours$participants_apres, ",\\s*"))),  
          layer.name = "Parcelles après évolution forme (état 2024)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(redef_contours,  layer.name = "Parcelles avant évolution forme (état 2023)", col.regions = "purple", 
          alpha.regions = 0.5,homebutton = F) +
  mapview(ajout_parc, z=c("iou"), layer.name = "Parcelles restantes (état 2024)", alpha.regions = 0.5,
          homebutton = F) +
  mapview(supp_parc, z=c("iou"), layer.name = "Parcelles restantes (état 2023)", alpha.regions = 0.5,
          homebutton = F)

mapshot(map, url = "parcelles_iou_inside_bordure_85.html")
```

