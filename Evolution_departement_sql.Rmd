---
title: "Evolution departement parcelles"
output: html_document
date: "2024-06-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

# Import package + fonction utilisés après

```{r package message=FALSE, warning=FALSE}
library(sf)
library(dplyr)
library(mapview)
library(DBI)
library(ggplot2)
library(webshot)
library(stringr)
# webshot::install_phantomjs()
source(file = "connexion_db.R")
conn <- connecter()
DBI::dbListTables(conn)
source(file = "fonction_sql.R")
dbExecute(conn, "SET client_min_messages TO NOTICE;")

indic_bordure <- F
num_departement <- 85
temps_apres <- 24
temps_avant <- 23
```

```{r supprimer toutes les tables temporaires}
# Exécution de la requête pour obtenir les noms des tables temporaires
tables_temporaires <- dbGetQuery(conn, "
  SELECT 
      tablename
  FROM 
      pg_tables
  WHERE 
      schemaname LIKE 'pg_temp_%';
")

# Générer les commandes de suppression
drop_queries <- lapply(tables_temporaires$tablename, function(table) {
  paste("DROP TABLE IF EXISTS", table, "CASCADE;")
})

# Exécution des commandes de suppression
for (query in drop_queries) {
  cat("Exécution de la requête : ", query, "\n")
  tryCatch({
    dbExecute(conn, query)
  }, error = function(e) {
    cat("Erreur lors de l'exécution de la requête : ", query, "\n")
    cat("Message d'erreur : ", e$message, "\n")
  })
}
rm(tables_temporaires, drop_queries)

dbExecute(conn, "
  CREATE TEMP TABLE multi_calcul_cache (
      participants_avant text,
      participants_apres text,
      iou_multi numeric,
      participants_avant_hash text PRIMARY KEY
  );
")

dbExecute(conn, "CREATE INDEX idx_participants_avant_hash ON multi_calcul_cache (participants_avant_hash);")
```

```{r voir les index}
dbGetQuery(conn, " SELECT 
    tablename, 
    indexname, 
    indexdef 
FROM 
    pg_indexes 
WHERE 
    schemaname LIKE 'pg_temp_%' 
    OR schemaname = 'public';
           ")
```

```{r voir les tables temporaires}
dbGetQuery(conn, " SELECT 
    schemaname AS schema_name,
    tablename AS table_name
FROM 
    pg_tables
WHERE 
    schemaname LIKE 'pg_temp_%'
ORDER BY 
    schemaname, tablename;
           ")
```

# Importation des parcelles sur l'ensemble du département et des périodes données

```{r ajout/supp_tot sql}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_tot, supp_tot CASCADE;")

query <- paste0("
  CREATE TEMP TABLE ajout_tot AS
  SELECT * 
  FROM parc_",
  num_departement,
  "_",
  temps_apres, " parc_apres
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_",
  num_departement,
  "_",
  temps_avant," parc_avant
    WHERE parc_apres.idu = parc_avant.idu
  );
")

dbExecute(conn, query)

query <- paste0("
  CREATE TEMP TABLE supp_tot AS
  SELECT * 
  FROM parc_",
  num_departement,
  "_",
  temps_avant, " parc_avant
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_",
  num_departement,
  "_",
  temps_apres," parc_apres
    WHERE parc_avant.idu = parc_apres.idu
  );
")

dbExecute(conn, query)

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ajout_tot_geometry ON ajout_tot USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_tot_geometry ON supp_tot USING GIST(geometry);")

```


```{r import commune}
commune <- st_read(conn, query = paste0("SELECT code_insee, nom_com, geometry FROM com_", num_departement, ";"))
ajout_tot <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, geometry FROM ajout_tot;")
supp_tot <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, geometry FROM supp_tot;")
```

# Définition de la bordure dans laquelle je considère que mes parcelles doivent apartenir entièrement

```{r creation bordure et avec ou sans}
dbExecute(conn, "DROP TABLE IF EXISTS bordure, ins_parc_apres, ins_parc_avant, ajout, supp CASCADE;")

query <- paste0("
  CREATE TEMP TABLE bordure AS
  SELECT
      code_insee, nom_com, code_dep,
      ST_Simplify(ST_Difference(ST_Buffer(geometry, 250), ST_Buffer(geometry, -250)), 10) AS geometry
  FROM
      com_", num_departement, ";"
)

dbExecute(conn, query)

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_bordure_geometry ON bordure USING GIST(geometry);")

query <- paste0("
  CREATE TEMP TABLE ins_parc_avant AS
  SELECT DISTINCT
      parc_avant.*
  FROM
      parc_",
  num_departement,
  "_",
  temps_avant, 
  " parc_avant", 
  ifelse(indic_bordure, "
  JOIN
      bordure
  ON
      ST_WITHIN(parc_avant.geometry, bordure.geometry);", ";"))

dbExecute(conn, query)

query <- paste0("
  CREATE TEMP TABLE ins_parc_apres AS
  SELECT DISTINCT
      parc_apres.*
  FROM
      parc_",
  num_departement,
  "_",
  temps_apres, 
  " parc_apres", 
  ifelse(indic_bordure, "
  JOIN
      bordure
  ON
      ST_WITHIN(parc_apres.geometry, bordure.geometry);", ";"))

dbExecute(conn, query)

query <- paste0("
  CREATE TEMP TABLE ajout AS
  SELECT DISTINCT
      ajout_tot.*
  FROM
      ajout_tot", 
  ifelse(indic_bordure, "
  JOIN
      bordure
  ON
      ST_WITHIN(ajout_tot.geometry, bordure.geometry)
  ORDER BY ajout_tot.nom_com;", ";"))

dbExecute(conn, query)

query <- paste0("
  CREATE TEMP TABLE supp AS
  SELECT DISTINCT
      supp_tot.*
  FROM
      supp_tot", 
  ifelse(indic_bordure, "
  JOIN
      bordure
  ON
      ST_WITHIN(supp_tot.geometry, bordure.geometry)
  ORDER BY supp_tot.nom_com;", ";"))

dbExecute(conn, query)

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ins_parc_apres_geometry ON ins_parc_apres USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ins_parc_avant_geometry ON ins_parc_avant USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ajout_geometry ON ajout USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_geometry ON supp USING GIST(geometry);")
```


```{r bordure sql}
bordure <- st_read(conn, query = "SELECT code_insee, nom_com, geometry FROM bordure;") %>%
  mutate(geometry = st_cast(geometry, "MULTIPOLYGON"))

ins_parc_avant <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, geometry FROM ins_parc_avant;")

ins_parc_apres <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, geometry FROM ins_parc_apres;")

dbExecute(conn, "DROP TABLE IF EXISTS bordure;")
```

# Focus sur les parcelles dont je peux comparer l'état sur les deux périodes facilement (cad parcelles ayant conservé leur identifiant)

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r modif geometry egal sql}
dbExecute(conn, "DROP TABLE IF EXISTS identique, modif_apres, modif_avant, modif;")

dbExecute(conn, "
  CREATE TEMP TABLE identique AS
  SELECT ins_parc_apres.*
  FROM ins_parc_apres
  WHERE NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE ins_parc_apres.idu = ajout.idu
  )
  AND EXISTS (
      SELECT 1
      FROM ins_parc_avant 
      WHERE ins_parc_apres.idu = ins_parc_avant.idu
      AND ST_Equals(
          ST_SnapToGrid(ins_parc_apres.geometry, 0.0001), 
          ST_SnapToGrid(ins_parc_avant.geometry, 0.0001)
      )
  );
")

dbExecute(conn, "
  CREATE TEMP TABLE modif_avant AS
  SELECT ins_parc_avant.*
  FROM ins_parc_avant
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE ins_parc_avant.idu = identique.idu
  )
  AND NOT EXISTS (
      SELECT 1
      FROM supp
      WHERE ins_parc_avant.idu = supp.idu
  );
")

dbExecute(conn, "
  CREATE TEMP TABLE modif_apres AS
  SELECT ins_parc_apres.*
  FROM ins_parc_apres
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE ins_parc_apres.idu = identique.idu
  )
  AND NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE ins_parc_apres.idu = ajout.idu
  );
")

dbExecute(conn, "
  CREATE TEMP TABLE modif AS
  SELECT
      COALESCE(avant.idu, apres.idu) AS idu,
      avant.geometry AS geometry_avant,
      apres.geometry AS geometry_apres,
      calcul_iou(apres.geometry, avant.geometry) AS iou,
      calcul_iou_ajust(apres.geometry, avant.geometry) AS iou_ajust
  FROM
      modif_avant avant
  FULL JOIN
      modif_apres apres ON avant.idu = apres.idu;
")

dbExecute(conn, "DROP TABLE IF EXISTS identique;")
```

```{r drop iou null sql}
# Elimine les parcelles "sans changement manifeste" plus les parcelles sans iou = parcelles n'étant plus entièrement dans la bordure lors d'un changement d'une année sur l'autre
dbExecute(conn, "
  DELETE FROM modif
  WHERE iou > 0.99 OR iou IS NULL;
")
```


```{r quantile}
# 85130000AH0055 et 85130000AH0017 supplémentaire dans sql
# modif <- st_read(conn, query = "SELECT * FROM modif;")
```

## Reconnaissances des cas de translation, modification de contour et les deux à la fois

```{r translation, contour_apres, contour_translation}
dbExecute(conn, "DROP TABLE IF EXISTS modif_apres_iou, modif_avant_iou, 
          translation, contour_avant, contour_translation;")

dbExecute(conn, "
  CREATE TEMP TABLE modif_avant_iou AS
  SELECT modif_avant.*, modif.iou, modif.iou_ajust
  FROM modif
  LEFT JOIN modif_avant ON modif.idu = modif_avant.idu;
")

dbExecute(conn, "
  CREATE TEMP TABLE modif_apres_iou AS
  SELECT modif_apres.*, modif.iou, modif.iou_ajust
  FROM modif
  LEFT JOIN modif_apres ON modif.idu = modif_apres.idu;
")

dbExecute(conn, "
  CREATE TEMP TABLE translation AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         idu AS idu_translate
  FROM modif_avant_iou
  WHERE iou_ajust > 0.99;
")

dbExecute(conn, "
  CREATE TEMP TABLE contour_avant AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         iou AS iou_multi,
         idu AS participants_avant,
         idu AS participants_apres
  FROM modif_avant_iou
  WHERE iou > 0.95 AND iou_ajust < 0.99;
")

dbExecute(conn, "
  CREATE TEMP TABLE contour_translation AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         idu AS idu_translate
  FROM modif_avant_iou
  WHERE iou < 0.95 AND iou_ajust > 0.95 AND iou_ajust < 0.99;
")

dbExecute(conn, "
  DELETE FROM modif_avant_iou
  WHERE idu IN (SELECT idu FROM translation)
    OR idu IN (SELECT idu FROM contour_avant)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbExecute(conn, "
  DELETE FROM modif_apres_iou
  WHERE idu IN (SELECT idu FROM translation)
    OR idu IN (SELECT idu FROM contour_avant)
    OR idu IN (SELECT idu FROM contour_translation);
")
```

```{r modif iou_ajust -> translation}
translation_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, idu_translate, geometry FROM translation;")

contour_avant_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, iou_multi, participants_avant, participants_apres, geometry FROM contour_avant;")

contour_translation_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, idu_translate, geometry FROM contour_translation;")

modif_avant_sql <- st_read(conn, query = "SELECT * FROM modif_avant_iou;")
```

## Cas plus compliqués de détection des mêmes cas

```{r meme cas sql}
# NE PAS RELANCER
dbExecute(conn, "DROP TABLE IF EXISTS modif_avant_iou_multi;")
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache;")

dbExecute(conn, "
  CREATE TEMP TABLE modif_avant_iou_multi AS
  SELECT modif_avant_iou.*, 
    (calcul_iou_multi(modif_avant_iou.idu, modif_avant_iou.geometry, 'modif_avant_iou' , 'modif_apres_iou')).*
  FROM modif_avant_iou;
")

dbExecute(conn, "
  INSERT INTO contour_avant
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         iou_multi, participants_avant, participants_apres
  FROM modif_avant_iou_multi
  WHERE (iou_multi > 0.95 AND LENGTH(participants_avant) = LENGTH(participants_apres))
     OR (LENGTH(participants_avant) = 14 AND LENGTH(participants_apres) = 14 AND iou > iou_ajust);
")

dbExecute(conn, "
  INSERT INTO contour_translation
  SELECT avant.idu, avant.numero, avant.feuille, avant.section, avant.code_dep, 
         avant.nom_com, avant.code_com, avant.com_abs, 
         avant.code_arr, avant.contenance, avant.iou_ajust, apres.geometry, 
         avant.idu AS idu_translate
  FROM modif_avant_iou_multi AS avant
  LEFT JOIN modif_apres apres ON avant.idu = apres.idu
  WHERE ((LENGTH(participants_avant) = 14 AND LENGTH(participants_apres) = 14 AND iou < iou_ajust))
     OR iou_multi IS NULL;
")

dbExecute(conn, "
  DELETE FROM modif_avant_iou_multi
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour_avant)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbExecute(conn, "
  DELETE FROM modif_apres_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour_avant)
    OR idu IN (SELECT idu FROM contour_translation);
")
```


```{r modif iou_multi -> translation, modification de contour et les deux à la fois bis}
contour_avant_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, iou_multi, participants_avant, participants_apres, geometry FROM contour_avant;")

contour_translation_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, idu_translate, geometry FROM contour_translation;")

modif_avant_sql <- st_read(conn, query = "SELECT * FROM modif_avant_iou_multi;")
```

```{r enveloppe convexe}
# NE PAS RELANCER
dbExecute(conn, "DROP TABLE IF EXISTS modif_avant_iou_convex;")

dbExecute(conn, "
  CREATE TEMP TABLE modif_avant_iou_convex AS
  SELECT modif_avant_iou_multi.*, 
    calcul_iou_convex('modif_avant_iou_multi' , 'modif_apres_iou', participants_avant, participants_apres) AS iou_convex
  FROM modif_avant_iou_multi;
")

dbExecute(conn, "
  INSERT INTO contour_avant
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         iou_convex AS iou_multi, participants_avant, participants_apres
  FROM modif_avant_iou_convex
  WHERE iou_convex > 0.99 AND LENGTH(participants_avant) = LENGTH(participants_apres);
")

dbExecute(conn, "
  DELETE FROM modif_avant_iou_convex
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour_avant);
")

dbExecute(conn, "
  DELETE FROM modif_apres_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour_avant);
")
```

```{r convex}
contour_avant_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, iou_multi, participants_avant, participants_apres, geometry FROM contour_avant;")

modif_avant_sql <- st_read(conn, query = "SELECT * FROM modif_avant_iou_convex;")
modif_apres_sql <- st_read(conn, query = "SELECT * FROM modif_apres_iou;")
```

```{r présomption}
# NE PAS RELANCER
dbExecute(conn, "
  INSERT INTO contour_avant
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         iou_multi, participants_avant, participants_apres
  FROM modif_avant_iou_convex
  WHERE iou_ajust < (iou + 0.1);
")

dbExecute(conn, "
  INSERT INTO contour_translation
  SELECT avant.idu, avant.numero, avant.feuille, avant.section, avant.code_dep, 
         avant.nom_com, avant.code_com, avant.com_abs, 
         avant.code_arr, avant.contenance, avant.iou_ajust, apres.geometry, 
         avant.idu AS idu_translate
  FROM modif_avant_iou_convex AS avant
  LEFT JOIN modif_apres apres ON avant.idu = apres.idu
  WHERE iou_ajust > (iou + 0.1);
")

dbExecute(conn, "
  DELETE FROM modif_avant_iou_convex
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour_avant)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbExecute(conn, "
  DELETE FROM modif_apres_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour_avant)
    OR idu IN (SELECT idu FROM contour_translation);
")
```

```{r presomption sql}
contour_avant_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, iou_multi, participants_avant, participants_apres, geometry FROM contour_avant;")

contour_translation_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, idu_translate, geometry FROM contour_translation;")

modif_avant_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, iou_multi, participants_avant, participants_apres, iou_convex, geometry FROM modif_avant_iou_convex;")
modif_apres_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, iou_ajust, geometry FROM modif_apres_iou;")
```


```{r mapview typologie parcelles modifiées, eval=FALSE, include=FALSE}

map <- mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightgrey", 
               alpha.regions = 0.5, homebutton = F,
               map.types = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldImagery"))

if (nrow(translation_sql) > 0) {
  map <- map + mapview(translation_sql,
                       layer.name = "Parcelles translatées (état 2024)", 
                       col.regions = "darkcyan",
                       alpha.regions = 0.5, homebutton = F) + 
    mapview(ins_parc_apres %>%
              filter(idu %in% translation_sql$idu_translate), 
            layer.name = "Parcelles translatées (état 2023)", 
            col.regions = "darkcyan",
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_avant_sql) > 0) {
  map <- map + mapview(contour_avant_sql,  
                       layer.name = "Parcelles contours (état 2024)", 
                       col.regions = "orange",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ins_parc_apres %>%
              filter(idu %in% contour_avant_sql$idu),  
            layer.name = "Parcelles contours (état 2023)", 
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_translation_sql) > 0) {
  map <- map + mapview(contour_translation_sql,  
                       layer.name = "Parcelles translatées + contours (état 2024)", 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ins_parc_apres %>%
              filter(idu %in% contour_translation_sql$idu_translate),
            layer.name = "Parcelles translatées + contours (état 2023)", 
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(modif_apres_sql) > 0) {
  map <- map + mapview(modif_apres_sql, 
                       z = c("iou_ajust"), 
                       layer.name = "Parcelles modifiées restantes (état 2024)", 
                       alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(modif_avant_sql) > 0) {
  map <- map + mapview(modif_avant_sql, 
                       z = c("iou_ajust"), 
                       layer.name = "Parcelles modifiées restantes (état 2023)", 
                       alpha.regions = 0.5, homebutton = F)
}
mapshot(map, url = "parcelles_modifiées_85_24-23.html")
```

# Focus des parcelles ayant changé de communes

## Cas des parcelles dans le cas d'une fusion de communes

```{r ajout/supp -> focus fusion commune}
dbExecute(conn, "DROP TABLE IF EXISTS com_abs_apres, com_abs_avant;")

dbExecute(conn, "
  CREATE TEMP TABLE com_abs_apres AS
  SELECT *,
         SUBSTR(idu, 1, 2) || com_abs || '000' || SUBSTR(idu, 9, 14) AS idu_avant
  FROM ajout
  WHERE com_abs != '000';
")

dbExecute(conn, "
  CREATE TEMP TABLE com_abs_avant AS
  SELECT *
  FROM supp
  WHERE idu IN (SELECT idu_avant FROM com_abs_apres);
")

dbExecute(conn, "
  DELETE FROM com_abs_apres
  WHERE idu_avant NOT IN (SELECT idu FROM com_abs_avant);
")

# Parcelles n'ayant pas été modifiées mise à part le nom de commune
```

```{r parcelle changeant de communes}
com_abs_apres_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, idu_avant, geometry FROM com_abs_apres;")

com_abs_avant_sql <- st_read(conn, query = "
                             SELECT avant.idu, avant.nom_com, avant.code_com, avant.com_abs, avant.contenance,                                                           avant.geometry, apres.nom_com AS nom_com_apres
                             FROM com_abs_avant avant
                             LEFT JOIN com_abs_apres apres
                             ON avant.idu = apres.idu_avant;")
```

# Focus parcelles avec changement "majeur" lié à un changement impactant l'identifiant des parcelles

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r ajout/supp geometry egal}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_simp, supp_simp, ajout_identique, supp_identique CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE ajout_simp AS
  SELECT idu, ST_SnapToGrid(ajout.geometry, 0.0001) AS geometry
  FROM ajout;
")

dbExecute(conn, "
  CREATE TEMP TABLE supp_simp AS
  SELECT idu, ST_SnapToGrid(supp.geometry, 0.0001) AS geometry
  FROM supp;
")

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ajout_simp_geometry ON ajout_simp USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_simp_geometry ON supp_simp USING GIST(geometry);")

# Parcelles ajoutées n'ayant pas été modifiées
dbExecute(conn, "
  CREATE TEMP TABLE ajout_identique AS
  SELECT ajout_simp.*
  FROM ajout_simp
  JOIN supp_simp ON ST_Equals(ajout_simp.geometry, supp_simp.geometry);
")

# Parcelles supprimées n'ayant pas été modifiées
dbExecute(conn, "
  CREATE TEMP TABLE supp_identique AS
  SELECT supp_simp.*
  FROM supp_simp
  JOIN ajout_simp ON ST_Equals(supp_simp.geometry, ajout_simp.geometry);
")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (SELECT idu FROM ajout_identique);
")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (SELECT idu FROM supp_identique);
")

dbExecute(conn, "DROP TABLE IF EXISTS ajout_simp, supp_simp, ajout_identique, supp_identique CASCADE;")
```

## Reconnaissances des cas de fusion (peu fréquent) ou subdivision (plus courant)

```{r ajout/supp iou -> fusion/subdivision}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_iou, supp_iou, fusion, subdiv CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou AS
  SELECT
      supp.*,
      (calcul_iou_intersec(supp.geometry, 'ajout')).*
  FROM
      supp;
")

dbExecute(conn, "
  CREATE TEMP TABLE subdiv AS
  SELECT *
  FROM supp_iou
  WHERE iou > 0.99 AND LENGTH(participants) != 14;
")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants, ',\\s*')) FROM supp_iou WHERE iou > 0.99);
")

dbExecute(conn, "
  DELETE FROM supp_iou
  WHERE iou > 0.99;
")

dbExecute(conn, "
  CREATE TEMP TABLE ajout_iou AS
  SELECT
      ajout.*,
      (calcul_iou_intersec(ajout.geometry, 'supp_iou')).*
  FROM
      ajout;
")

dbExecute(conn, "
  CREATE TEMP TABLE fusion AS
  SELECT *
  FROM ajout_iou
  WHERE iou > 0.99 AND LENGTH(participants) != 14;
")

dbExecute(conn, "
  DELETE FROM supp_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants, ',\\s*')) FROM ajout_iou WHERE iou > 0.99);
")

dbExecute(conn, "
  DELETE FROM ajout_iou
  WHERE iou > 0.99;
")

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ajout_iou_geometry ON ajout_iou USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_iou_geometry ON supp_iou USING GIST(geometry);")
```

```{r fusion/subdivision}
subdiv_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, participants, geometry FROM subdiv;")
fusion_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, participants, geometry FROM fusion;")
```


## Reconnaissances des cas de multi-subdivision (ex : 2 -> 3) ou modification de contours

```{r ajout/supp iou_multi -> multi-subdivision et contours}
dbExecute(conn, "DROP TABLE IF EXISTS supp_iou_multi, multi_subdiv, contour CASCADE;")
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou_multi AS
  SELECT
      supp_iou.*,
      (calcul_iou_multi(supp_iou.idu, supp_iou.geometry, 'supp_iou', 'ajout_iou')).*
  FROM
      supp_iou;
")

dbExecute(conn, "
  CREATE TEMP TABLE multi_subdiv AS
  SELECT *
  FROM supp_iou_multi
  WHERE iou_multi > 0.99 AND LENGTH(participants_apres) != LENGTH(participants_avant);
")

dbExecute(conn, "
  CREATE TEMP TABLE contour AS
  SELECT *
  FROM supp_iou_multi
  WHERE (iou_multi > 0.95 AND LENGTH(participants_apres) = LENGTH(participants_avant))
    OR (LENGTH(participants_apres) = 14 AND LENGTH(participants_avant) = 14);
")

# A REVOIR ?
dbExecute(conn, "
  CREATE TEMP TABLE contour_transfo AS
  SELECT *
  FROM supp_iou_multi
  WHERE (iou_multi > 0.95 AND LENGTH(participants_apres) != LENGTH(participants_avant)
   AND iou_multi < 0.99);
")

dbExecute(conn, "
  DELETE FROM ajout_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM multi_subdiv)
    OR idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour)
    OR idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour_transfo);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM multi_subdiv)
    OR idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour)
    OR idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour_transfo);
")

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_iou_multi_geometry ON supp_iou_multi USING GIST(geometry);")
```

```{r multisubdiv sql}
multi_subdiv_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, participants, iou_multi, participants_avant, participants_apres, geometry FROM multi_subdiv;")

contour_transfo_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, participants, iou_multi, participants_avant, participants_apres, geometry FROM contour_transfo;")

contour_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, participants, iou_multi, participants_avant, participants_apres, geometry FROM contour;")
```

## Reconnaissances des cas de modification de contours plus compliquée
# a revoir c est trop long

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation, modification de contour avec translation

```{r ajout/supp iou_ajust -> translation, contour + translation}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_iou_translate CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE ajout_iou_translate AS
  SELECT DISTINCT
      ajout_iou.*,
      (calcul_iou_intersec_best_translate(ajout_iou.geometry, 'supp_iou_multi')).*
  FROM
      ajout_iou;
")

dbExecute(conn, "
  INSERT INTO translation
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry, idu_translate
  FROM ajout_iou_translate
  WHERE iou_ajust > 0.99;
")

dbExecute(conn, "
  INSERT INTO contour_translation
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry, idu_translate
  FROM ajout_iou_translate
  WHERE (iou_ajust > 0.95 AND iou_ajust < 0.99);
")

dbExecute(conn, "
  DELETE FROM ajout_iou_translate
  WHERE idu IN (SELECT idu FROM translation)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi
  WHERE idu IN (SELECT idu_translate FROM translation)
    OR idu IN (SELECT idu_translate FROM contour_translation);
")

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ajout_iou_translate_geometry ON ajout_iou_translate USING GIST(geometry);")
```

```{r contour translation ou translation seule}
contour_translation_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, idu_translate, geometry FROM contour_translation;")

translation_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, idu_translate, geometry FROM translation;")
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation avec modification de contour et avec fusion

```{r ajout/supp iou_ajust -> contour_fusion_translation}
dbExecute(conn, "DROP TABLE IF EXISTS supp_iou_multi_translate, contour_fusion_translation CASCADE;")
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou_multi_translate AS
  SELECT 
      supp_iou_multi.*,
      (calcul_iou_multi_translate(supp_iou_multi.idu, supp_iou_multi.geometry, 'supp_iou_multi', 'ajout_iou_translate')).*
  FROM
      supp_iou_multi;
")

dbExecute(conn, "
  CREATE TEMP TABLE contour_transfo_translation AS
  SELECT *
  FROM supp_iou_multi_translate
  WHERE iou_multi_translate > 0.95;
")

dbExecute(conn, "
  DELETE FROM ajout_iou_translate
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres_translate, ',\\s*')) FROM contour_transfo_translation);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi_translate
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant_translate, ',\\s*')) FROM contour_transfo_translation);
")

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_iou_multi_translate_geometry ON supp_iou_multi_translate USING GIST(geometry);")
```

```{r contour_fusion_translation}
contour_transfo_translation_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, participants, iou_multi, participants_avant, participants_apres, iou_multi_translate, participants_avant_translate, participants_apres_translate, geometry FROM contour_transfo_translation;")
```

## Cas rapide translation transformation

```{r rapide}
dbExecute(conn, "DROP TABLE IF EXISTS supp_iou_multi_translate_rapide, max_iou, multi_translate_rapide CASCADE;")
# 852000000A1114
dbExecute(conn, "
  CREATE TEMP TABLE supp_iou_multi_translate_rapide AS
  SELECT 
      idu, numero, feuille, section, code_dep, nom_com, code_com, 
      com_abs, code_arr, contenance, iou, participants,
      iou_multi, participants_avant, participants_apres,
      (calcul_iou_multi_translate_rapide(supp_iou_multi_translate.geometry, 'supp_iou_multi_translate', 'ajout_iou_translate')).*,
      geometry
  FROM
      supp_iou_multi_translate;
")

dbExecute(conn, "
  CREATE TEMP TABLE max_iou AS
SELECT idu, MAX(iou_multi_translate) AS max_iou
FROM (
    SELECT unnest(regexp_split_to_array(participants_avant_translate, ',\\s*')) AS idu, iou_multi_translate
    FROM supp_iou_multi_translate_rapide
    WHERE iou_multi_translate > 0.95
) subquery
GROUP BY idu;
")

dbExecute(conn, "
CREATE TEMP TABLE multi_translate_rapide AS
SELECT DISTINCT ON (idu_unnest.idu) idu_unnest.idu, idu_unnest.iou_multi_translate, idu_unnest.participants_avant_translate,                      idu_unnest.participants_apres_translate
FROM (
    SELECT unnest(regexp_split_to_array(participants_avant_translate, ',\\s*')) AS idu, 
        iou_multi_translate, participants_avant_translate, participants_apres_translate
    FROM supp_iou_multi_translate_rapide
    WHERE iou_multi_translate > 0.95
) idu_unnest
JOIN max_iou mi
ON idu_unnest.idu = mi.idu AND idu_unnest.iou_multi_translate = mi.max_iou
ORDER BY idu_unnest.idu, idu_unnest.iou_multi_translate DESC;
")

dbExecute(conn, "
  INSERT INTO contour_transfo_translation
  SELECT simtr.idu, simtr.numero, simtr.feuille, simtr.section, simtr.code_dep, simtr.nom_com, simtr.code_com, simtr.com_abs, simtr.code_arr, simtr.contenance, simtr.geometry,simtr.iou, simtr.participants, simtr.iou_multi, simtr.participants_avant,
      simtr.participants_apres, rapide.iou_multi_translate, rapide.participants_avant_translate,                                    rapide.participants_apres_translate
  FROM multi_translate_rapide rapide
  LEFT JOIN supp_iou_multi_translate_rapide simtr ON rapide.idu = simtr.idu;
")

dbExecute(conn, "
  DELETE FROM ajout_iou_translate
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres_translate, ',\\s*')) 
                  FROM multi_translate_rapide);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi_translate_rapide
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant_translate, ',\\s*')) FROM multi_translate_rapide);
")

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_iou_multi_translate_rapide_geometry ON supp_iou_multi_translate_rapide USING GIST(geometry);")
```

```{r contour_fusion_translation}
contour_transfo_translation_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, participants, iou_multi, participants_avant, participants_apres, iou_multi_translate, participants_avant_translate, participants_apres_translate, geometry FROM contour_transfo_translation;")
```

## Recalcul de l'IoU pour détecter les parcelles maintenant isolées -> Véritable ajout ou suppression

```{r le reste}
dbExecute(conn, "DROP TABLE IF EXISTS supp_iou_restant, ajout_iou_restant, 
          vrai_ajout, vrai_supp CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou_restant AS
  SELECT
      idu, numero, feuille, section, code_dep, nom_com, code_com, 
      com_abs, code_arr, contenance, geometry, 
      (calcul_iou_intersec(supp_iou_multi_translate_rapide.geometry, 'ajout_iou_translate')).*,
      iou_multi, participants_avant, participants_apres, 
      iou_multi_translate, participants_avant_translate, participants_apres_translate
  FROM
      supp_iou_multi_translate_rapide;
")

dbExecute(conn, "
  CREATE TEMP TABLE ajout_iou_restant AS
  SELECT
      idu, numero, feuille, section, code_dep, nom_com, code_com, 
      com_abs, code_arr, contenance, geometry, 
      (calcul_iou_intersec(ajout_iou_translate.geometry, 'supp_iou_multi_translate')).*, 
      iou_ajust, idu_translate
  FROM
      ajout_iou_translate;
")

dbExecute(conn, "
  CREATE TEMP TABLE vrai_ajout AS
  SELECT *
  FROM ajout_iou_restant
  WHERE iou IS NULL;
")

dbExecute(conn, "
  CREATE TEMP TABLE vrai_supp AS
  SELECT *
  FROM supp_iou_restant
  WHERE iou IS NULL;
")

dbExecute(conn, "
  DELETE FROM ajout_iou_restant
  WHERE idu IN (SELECT idu FROM vrai_ajout);
")

dbExecute(conn, "
  DELETE FROM supp_iou_restant
  WHERE idu IN (SELECT idu FROM vrai_supp);
")
```

```{r le reste}
ajout_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, participants, iou_ajust, idu_translate, geometry FROM ajout_iou_restant;")

supp_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, participants, iou_multi, participants_avant, participants_apres, iou_multi_translate, participants_avant_translate, participants_apres_translate, geometry FROM supp_iou_restant;")

vrai_ajout_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, participants, iou_ajust, idu_translate, geometry FROM vrai_ajout;")

vrai_supp_sql <- st_read(conn, query = "SELECT idu, nom_com, code_com, com_abs, contenance, iou, participants, iou_multi, participants_avant, participants_apres, iou_multi_translate, participants_avant_translate, participants_apres_translate, geometry FROM vrai_supp;")
```

# Visualisation finale sur une carte du département

```{r mapview typologie parcelles, eval=FALSE, include=FALSE}
map <- mapview(bordure, 
               layer.name = "Bordures étendues", col.regions = "lightgrey", 
               alpha.regions = 0.5, homebutton = F,
               map.types = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldImagery"))

if (nrow(translation_sql) > 0) {
  map <- map + mapview(translation_sql,
                       layer.name = paste0("Parcelles translatées (état 20",temps_apres,")"), 
                       col.regions = "darkcyan",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ins_parc_avant %>%
              filter(idu %in% translation_sql$idu_translate),
            col.regions = "darkcyan",
            layer.name = paste0("Parcelles translatées (état 20",temps_avant,")"), 
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(fusion_sql) > 0) {
  map <- map + mapview(fusion_sql, 
                       layer.name = paste0("Parcelles fusionnéees (état 20",temps_apres,")"),
                       col.regions = "darkmagenta", alpha.regions = 0.5, homebutton = F) +
    mapview(supp_tot %>%
              filter(idu %in% unlist(str_split(fusion_sql$participants, ",\\s*"))),  
            layer.name = paste0("Parcelles fusionnéees (état 20",temps_avant,")"), 
            col.regions = "darkmagenta",
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(subdiv_sql) > 0) {
  map <- map + mapview(ajout_tot %>%
                         filter(idu %in% unlist(str_split(subdiv_sql$participants, ",\\s*"))),  
                       layer.name = paste0("Parcelles subdivisées (état 20",temps_apres,")"), 
                       col.regions = "purple",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(subdiv_sql,  
            layer.name = paste0("Parcelles subdivisées (état 20",temps_avant,")"), 
            col.regions = "purple", alpha.regions = 0.5, homebutton = F)
}
if (nrow(multi_subdiv_sql) > 0) {
  map <- map + mapview(ajout_tot %>%
                         filter(idu %in% unlist(str_split(multi_subdiv_sql$participants_apres, ",\\s*"))),
                       layer.name = paste0("Parcelles multi-subdivision (état 20",temps_apres,")"),
                       col.regions = "magenta",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(multi_subdiv_sql,  
            layer.name = paste0("Parcelles multi-subdivision (état 20",temps_avant,")"), 
            col.regions = "magenta", alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(contour_sql) > 0) {
  map <- map + mapview(ajout_tot %>%
                         filter(idu %in% unlist(str_split(contour_sql$participants_apres, ",\\s*"))),  
                       layer.name = paste0("Parcelles contours (état 20",temps_apres,")"), 
                       col.regions = "orange",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(contour_sql,
            layer.name = paste0("Parcelles contours (état 20",temps_avant,")"),
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_avant_sql) > 0) {
  map <- map + mapview(contour_avant_sql,  
                       layer.name = paste0("Parcelles contours (état 20",temps_apres,")"),
                       col.regions = "orange",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ins_parc_avant %>%
              filter(idu %in% contour_avant_sql$idu),  
            layer.name = paste0("Parcelles contours (état 20",temps_avant,")"), 
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_transfo_sql) > 0) {
  map <- map + mapview(ajout_tot %>%
                         filter(idu %in% unlist(str_split(contour_transfo_sql$participants_apres, ",\\s*"))),  
                       layer.name = paste0("Parcelles transfo + contours (état 20",temps_apres,")"),
                       col.regions = "pink",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(contour_transfo_sql,
            layer.name = paste0("Parcelles transfo + contours (état 20",temps_avant,")"), 
            col.regions = "pink", alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_translation_sql) > 0) {
  map <- map + mapview(contour_translation_sql,  
                       layer.name = paste0("Parcelles translatées + contours (état 20",temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ins_parc_avant %>%
              filter(idu %in% contour_translation_sql$idu_translate),
            layer.name = paste0("Parcelles translatées + contours (état 20",temps_avant,")"), 
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_transfo_translation_sql) > 0) {
  map <- map + mapview(ajout_tot %>%
              filter(idu %in% unlist(str_split(contour_transfo_translation_sql$participants_apres_translate, ",\\s*"))),
            layer.name = paste0("Parcelles transfo + translatées + contours (état 20",temps_apres,")"), 
            col.regions = "lightblue", alpha.regions = 0.5, homebutton = F) +
    mapview(contour_transfo_translation_sql,  
                       layer.name = paste0("Parcelles transfo + translatées + contours (état 20",temps_avant,")"), 
                       col.regions = "lightblue",
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(com_abs_apres_sql) > 0) {
  map <- map + mapview(com_abs_apres_sql,  
                       layer.name = paste0("Parcelles fusion de communes (état 20",temps_apres,")"), 
                       col.regions = "lightgreen",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(com_abs_avant_sql,  
            layer.name = paste0("Parcelles fusion de communes (état 20",temps_avant,")"), 
            col.regions = "lightgreen", alpha.regions = 0.5, homebutton = F)
}
if (nrow(vrai_ajout_sql) > 0) {
  map <- map + mapview(vrai_ajout_sql, 
                       layer.name = "Parcelles véritablement ajoutées", 
                       col.regions = "green", alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(vrai_supp_sql) > 0) {
  map <- map + mapview(vrai_supp_sql,
                       layer.name = "Parcelles véritablement supprimées",
                       col.regions = "red", alpha.regions = 0.5, homebutton = F) 
}
if (nrow(ajout_sql) > 0) {
  map <- map + mapview(ajout_sql,
                       z = c("iou_ajust"), layer.name = paste0("Parcelles restantes (état 20",temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(supp_sql) > 0) {
  map <- map + mapview(supp_sql, 
                       z = c("iou_multi"), layer.name = paste0("Parcelles restantes (état 20",temps_avant,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(modif_apres_sql) > 0) {
  map <- map + mapview(modif_apres_sql, 
                       z = c("iou_ajust"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(modif_avant_sql) > 0) {
  map <- map + mapview(modif_avant_sql, 
                       z = c("iou_ajust"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",temps_avant,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
mapshot(map, url = paste0("parcelles_",num_departement,"_",temps_apres,"-",temps_avant,".html"))
```