---
title: "Traitement des parcelles d'un département"
output: html_document
date: "2024-06-18"
params:
  num_departement: "85"
  temps_apres: 24
  temps_avant: 23
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = FALSE)
```

# Import package + fonction utilisés après

```{r package message=FALSE, warning=FALSE}
# rm(list = ls())
library(sf)
library(dplyr)
library(mapview)
library(DBI)
library(ggplot2)
library(webshot)
library(stringr)
# Importation des packages nécessaires au traitement et à la production des cartes

source(file = "database/connexion_db.R")
conn <- connecter()
# Connexion à la base de donnée Postgre

nb_parcelles_seuil <- 5e05
# Seuil limitant l'arrêt de la partie traitement pour les parcelles dont 
# l'identifiant est présent sur les deux périodes de temps

source(file = "fonctions/fonction_sql.R")
# Importation des fonctions codées en Postgre SQL nécessaires au traitement
# notamment l'IoU et ses variantes
```


```{r reset traitement}
dbExecute(conn, paste0(
  "DROP SCHEMA IF EXISTS traitement_", params$temps_apres, "_", params$temps_avant, "_cadastre_", params$num_departement, " CASCADE;"))
# Suppression du schéma contenant les tables de traitement si déjà effectué auparavant

source(file = "database/table_traitement_db.R")
# Création du schéma et des tables nécessaire au traitement et à la typologie des parcelles

dbExecute(conn, "SET client_min_messages TO NOTICE;")
# Permet d'afficher des messages dans la console lors de requêtes SQL
```

# Mise de côté des parcelles non présentes sur les deux périodes de temps à la fois

```{r ajout/supp}
dbExecute(conn, "TRUNCATE TABLE ajout, supp;")
# Vide les tables 'ajout' et 'supp'
# Ceci est utile si l'on souhaite relancer le chunk sans devoir tout relancer
# Certain chunk nécessite de relancer des chunks en amont et ne peuvent être
# relancer (cas d'une table qu'on a remplit en partie auparavant et qu'on ne peut
# vider à cette étape). Ils seront signalé en début de chunk

dbExecute(conn, paste0("
  INSERT INTO ajout (idu, nom_com, code_com, com_abs, contenance, geometry)
  SELECT idu, nom_com, code_com, com_abs, contenance, geometry
  FROM parc_", params$num_departement, "_", params$temps_apres, " apres
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_", params$num_departement, "_", params$temps_avant," avant
    WHERE apres.idu = avant.idu
  );"))
# Parcelles à la période T non présentes à T-1

dbExecute(conn, paste0("
  INSERT INTO supp (idu, nom_com, code_com, com_abs, contenance, geometry)
  SELECT idu, nom_com, code_com, com_abs, contenance, geometry
  FROM parc_", params$num_departement, "_", params$temps_avant, " avant
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_", params$num_departement, "_", params$temps_apres," apres
    WHERE avant.idu = apres.idu
  );"))
# Parcelles à la période T-1 non présentes à T
```


```{r, eval=FALSE}
# Les chunks avec 'eval=FALSE' ne se lance que manuellement
# Ces imports permettent de vérifier les différents remplissages des tables à chaque étape

ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
```

# Définition de la bordure de 250 m par rapport au contour communal

```{r bordure}
dbExecute(conn, "TRUNCATE TABLE bordure;")

dbExecute(conn, paste0("
  INSERT INTO bordure
  SELECT
      code_insee, nom_com,
      ST_Multi(
          ST_Simplify(
              ST_Difference(
                  ST_Buffer(geometry, 250), ST_Buffer(geometry, -250)
              )
          , 10)
      ) AS geometry
  FROM
      com_", params$num_departement, ";"))
# Création de la bordure de 250 mètres de chaque coté par rapport au contour communal
```


```{r, eval=FALSE}
bordure <- st_read(conn, query = "SELECT * FROM bordure;") %>%
  mutate(geometry = st_cast(geometry, "MULTIPOLYGON"))

commune <- st_read(conn, query = paste0("SELECT * FROM com_", params$num_departement, ";"))

parc_avant <- st_read(conn, query = paste0("SELECT * FROM parc_", params$num_departement, "_", params$temps_avant, ";"))
parc_apres <- st_read(conn, query = paste0("SELECT * FROM parc_", params$num_departement, "_", params$temps_apres, ";"))
```

# Focus sur les parcelles ayant conservées leur identifiant 

On s'occupe d'abord des parcelles les plus simples à traiter : celles présentes avec le même identifiant sur les deux périodes de temps. On élimine les parcelles en tout point identique (vis à vis de leur polygone). On fait attention de récupèrer des changements de noms qui n'affectent pas leur code communal (par exemple changement de nom, scission de commune, ect). On récupère ces informations pour éviter des erreurs dan l'application shiny (qui utilise le nom de la commune).
Après avoir enlevé les parcelles identiques, il reste toujours des cas qui ne nous intéressent pas et que nous souhaitons éliminer.
ATTENTION : Il arrive parfois qu'il reste trop de parcelles à comparer à cette étape (cas du département 1 période 24-23). Les calculs seront donc stoppés avant de lancer ceux néssaires dans la table modif (tout comme dans la partie traitement automatique). Il est nécessaire de lancer le code à la main à l'intérieur du chunk ou d'augmenter le seuil en début de document. Les calculs dans la partie modif restent encore acceptable mais il est fortement DECONSEILLE de lancer le code avec l'IoU Multi qui peuvent prendre à priori vraiment trop de temps pour pas grand chose.

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r géométrie égale + iou}
dbExecute(conn, "TRUNCATE TABLE identique, modif, disparition_com;")

dbExecute(conn, paste0("
  INSERT INTO identique
  SELECT 
      apres.idu, apres.nom_com, apres.code_com,
      avant.idu, avant.nom_com, avant.code_com
  FROM parc_", params$num_departement, "_", params$temps_apres, " apres
  JOIN parc_", params$num_departement, "_", params$temps_avant, " avant 
    ON avant.idu = apres.idu
  WHERE EXISTS (
      SELECT 1
      FROM parc_", params$num_departement, "_", params$temps_avant, " avant
      WHERE apres.idu = avant.idu 
          AND safe_st_equals(
              ST_SnapToGrid(apres.geometry, 0.0001), 
              ST_SnapToGrid(avant.geometry, 0.0001)
      )
  );"))
# On récupèrer les parcelles identiques pour lesquelles on a arrondi au préalable à 
# 10^-4 les cordonnées de la géomètrie (vraiment utile parfois). Toutefois, lors
# de l'arrondissage, certains polygones peuvent s'auto-intersecter ce qui génére une erreur.
# Si ce cas la arrive, la parcelle n'est pas considéré comme identique.

dbExecute(conn, paste0(" 
  INSERT INTO disparition_com
  SELECT DISTINCT
      nom_com_apres,
      code_com_apres,
      nom_com_avant,
      code_com_avant
  FROM identique 
  WHERE nom_com_apres != nom_com_avant;"))
# Récupère les noms des parcelles et code si des noms de communes ne sont plus présentes
# (changement de nom, ect)

nb_parcelles <- dbGetQuery(conn, paste0("
    SELECT 
      (SELECT COUNT(*) FROM parc_", params$num_departement, "_", params$temps_apres, ") - 
      (SELECT COUNT(*) FROM identique) AS parcelles_non_identique"))
# Estimation du nombre de parcelles restantes à traiter ici
# (tient compte du nombre de parcelles ajoutés/supprimées mais est négligeable)

if (nb_parcelles$parcelles_non_identique > nb_parcelles_seuil) {
  stop(paste0("Le nombre de parcelles a traité est trop volumineux : ", nb_parcelles$parcelles_non_identique, " (contre un seuil de ", nb_parcelles_seuil, ")
       Augmenté le seuil correspondant au nombre de parcelles maximum possibles à traiter !"))
}
# Arrète le chunk si le seuil est dépassé
# Le reste est à lancer manuellement ou en changeant le seuil si on le souhaite

# Parcelles à T non ajoutée ni une parcelle présente à T et T-1 'identique'
dbExecute(conn, paste0("
  INSERT INTO modif (
      idu, 
      nom_com, 
      code_com, 
      com_abs, 
      contenance_apres,
      contenance_avant,
      iou,
      geometry_apres,
      geometry_avant)
  SELECT
      apres.idu, apres.nom_com, apres.code_com, apres.com_abs,
      apres.contenance, avant.contenance,
      calcul_iou(apres.geometry, avant.geometry),
      avant.geometry AS geometry_avant, apres.geometry AS geometry_apres
  FROM parc_", params$num_departement, "_", params$temps_apres, " apres
  JOIN parc_", params$num_departement, "_", params$temps_avant, " avant
  ON avant.idu = apres.idu
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE apres.idu = identique.idu_apres
  ) AND NOT EXISTS (
      SELECT 1
      FROM supp
      WHERE avant.idu = supp.idu
  ) AND NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE apres.idu = ajout.idu
  );"))
# On fait une jointure pour faire les calculs qu'une seule fois et les récupére
# après dans les deux tables
```


```{r, eval=FALSE}
identique <- st_read(conn, query = "SELECT * FROM identique;")
disparition_com <- st_read(conn, query = "SELECT * FROM disparition_com;")
modif <- st_read(conn, query = "SELECT * FROM modif;")
```


```{r drop modif + Iou ajusté}
dbExecute(conn, "
  DELETE FROM modif
  WHERE iou >= 0.99 OR iou IS NULL;")
# Elimine les parcelles "sans changement manifeste" plus les parcelles sans iou
# = parcelles n'ayant pas de géométrie à T ou T-1

dbExecute(conn, "
  UPDATE modif
  SET iou_recale = calcul_iou_recale(m.geometry_apres, m.geometry_avant)
  FROM modif AS m
  WHERE modif.idu = m.idu;")
# On ne calcule pas directement avant pour éviter des calculs intutiles
```


```{r, eval=FALSE}
modif <- st_read(conn, query = "SELECT * FROM modif;")
```

## Reconnaissances des cas de translation, modification de contour et les deux à la fois

```{r translation, contour_apres, contour_translation modif}
dbExecute(conn, "TRUNCATE TABLE translation, contour;")

dbExecute(conn, "
  INSERT INTO translation
  SELECT idu, nom_com, code_com, com_abs, contenance_apres, iou_recale, 
      idu AS idu_recale, geometry_apres
  FROM modif
  WHERE iou_recale >= 0.99;")
# Si après translation, une parcelle partage quasiment la même surface, on considètre
# qu'il s'agit d'une translation.
# Ps : on a éliminé les concordances parfaites auparavant pour qu'elles ne soient pas
# considérées à tord comme des translations

dbExecute(conn, "
  INSERT INTO contour
  SELECT idu, nom_com, code_com, com_abs, contenance_avant,
         iou AS iou_multi, idu AS participants_avant,
         idu AS participants_apres, geometry_avant
  FROM modif
  WHERE (iou >= 0.95 OR iou_recale >= 0.95) AND iou_recale < 0.99;")
# Si avec translation ou non, la parcelle partage quasiment la même surface,
# il s'agit probablement juste d'une modification de contour

dbExecute(conn, "
  DELETE FROM modif
  WHERE EXISTS (
      SELECT 1
      FROM translation
      WHERE modif.idu = translation.idu
  ) OR EXISTS (
      SELECT 1
      FROM contour
      WHERE modif.idu = contour.idu
  );")
# On supprime les cas assignés
```


```{r, eval=FALSE}
translation <- st_read(conn, query = "SELECT * FROM translation;")
contour <- st_read(conn, query = "SELECT * FROM contour;")

modif <- st_read(conn, query = "SELECT * FROM modif;")
```

## Cas plus compliqués de détection des mêmes cas

```{r contour modif}
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache;")
# A NE PAS UTILISER SI NB DE PARCELLES DEPASSANT LE SEUIL
# NE PEUX PAS ETRE RELANCER DIRECTEMENT (contour utilisé avant)

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi_safe(idu, geometry_avant, 'modif')).*
    FROM modif
  )
  UPDATE modif
  SET iou_multi = updated_values.iou_multi,
      participants_avant = updated_values.participants_avant,
      participants_apres = updated_values.participants_apres
  FROM updated_values
  WHERE modif.idu = updated_values.idu")
# Ce code nous permet juste de savoir probablement les parcelles qui sont
# impliquées dans les modification de contours restantes.

dbExecute(conn, "
  INSERT INTO contour
  SELECT idu, nom_com, code_com, com_abs, contenance_avant,
         iou_multi, participants_avant, participants_apres, geometry_avant
  FROM modif;")
# Il n'y a priori pas d'autre cas possibles donc je mets toutes les parcelles restantes
# dans cette catégorie. Toutefois, je laisse les appels au table modif_avant et modif_après
# si jamais le code venait à être changer pour laisser des parcelles avec indétermination de cas

dbExecute(conn, "
  DELETE FROM modif
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM contour
  );")
```


```{r, eval=FALSE}
contour <- st_read(conn, query = "SELECT * FROM contour;")
modif <- st_read(conn, query = "SELECT * FROM modif;")
```

# Focus des parcelles ayant changé de communes

## Cas des parcelles dans le cas d'une scission de communes

```{r scission commune}
dbExecute(conn, "TRUNCATE TABLE scission_com, chgt_com;")

dbExecute(conn, paste0("
  INSERT INTO disparition_com
  SELECT 
      fusion_ajout.nom_com, fusion_ajout.code_com, 
      fusion_ajout.nom_com_avant, fusion_ajout.code_com_avant
  FROM (
      WITH avant AS (
          SELECT
              idu, nom_com, code_com,
              SUBSTR(idu, 1, 2) AS prefix_idu,
              SUBSTR(idu, 6, 14) AS suffix_idu
          FROM
              supp
          WHERE com_abs != '000'
      )
      SELECT 
          ajout.nom_com, ajout.code_com, 
          avant.nom_com AS nom_com_avant, avant.code_com AS code_com_avant
      FROM
          avant
      JOIN 
          ajout ON ajout.idu LIKE avant.prefix_idu || '___' || avant.suffix_idu
      WHERE avant.nom_com NOT IN (
          SELECT DISTINCT nom_com 
          FROM parc_", params$num_departement, "_", params$temps_apres, 
  ")
  ) AS fusion_ajout;"))

dbExecute(conn, "
  INSERT INTO scission_com
  WITH avant AS (
      SELECT
          idu, nom_com, code_com,
          SUBSTR(idu, 1, 2) || com_abs || '000' || SUBSTR(idu, 9, 14) AS idu_apres
      FROM
          supp
      WHERE com_abs != '000'
  )
  SELECT 
      ajout.idu, ajout.nom_com, ajout.code_com, ajout.com_abs, ajout.contenance,
         avant.idu, avant.nom_com, avant.code_com, ajout.geometry
  FROM
      ajout
  JOIN avant ON ajout.idu = avant.idu_apres;")
# On tente de reformer l'identifiant 


dbExecute(conn, paste0("
  INSERT INTO scission_com
  WITH avant AS (
      SELECT
          idu, nom_com, code_com,
          SUBSTR(idu, 1, 2) AS prefix_idu,
          SUBSTR(idu, 6, 14) AS suffix_idu
      FROM
          supp
      WHERE com_abs != '000'
  )
  SELECT 
      ajout.idu, ajout.nom_com, ajout.code_com, ajout.com_abs, ajout.contenance,
         avant.idu, avant.nom_com, avant.code_com, ajout.geometry
  FROM
      avant
  JOIN ajout ON ajout.idu LIKE avant.prefix_idu || '___' || avant.suffix_idu
  WHERE avant.nom_com IN (
      SELECT DISTINCT nom_com 
      FROM parc_", params$num_departement, "_", params$temps_apres,
  ") OR avant.nom_com IN (
      SELECT nom_com_avant
      FROM disparition_com GROUP BY nom_com_avant HAVING COUNT(nom_com_apres) > 1
  );"))

dbExecute(conn, paste0(" 
  INSERT INTO chgt_com
  WITH scission_data AS (
      SELECT
          nom_com_avant, 
          code_com_avant, 
          STRING_AGG(DISTINCT nom_com, ', ') AS participants,
          STRING_AGG(DISTINCT code_com, ', ') AS participants_code_com
      FROM
          scission_com
      GROUP BY 
          nom_com_avant, code_com_avant
  ),
  com_apres AS (
      SELECT DISTINCT
          nom_com, code_com
      FROM 
          parc_", params$num_departement, "_", params$temps_apres,"
  )
  SELECT
      df.participants,
      df.participants_code_com,
      CASE 
          WHEN c.nom_com IS NOT NULL THEN 
              'Scission partielle'
          ELSE 
              'Scission totale'
      END AS changement,
      df.nom_com_avant,
      df.code_com_avant
  FROM
      scission_data df
  LEFT JOIN 
      com_apres c ON c.nom_com = df.nom_com_avant;"))

dbExecute(conn, paste0(" 
  UPDATE chgt_com
  SET 
      nom_com_apres = disparition_com.nom_com_apres || ', ' || chgt_com.nom_com_apres,
      code_com_apres = disparition_com.code_com_apres || ', ' || chgt_com.code_com_apres
  FROM disparition_com
  WHERE chgt_com.nom_com_avant = disparition_com.nom_com_avant;"))

# Parcelles n'ayant pas été modifiées mise à part le nom de commune
```


```{r parcelle changeant de communes, eval=FALSE}
disparition_com <- dbGetQuery(conn,  "SELECT * FROM disparition_com;")
scission_com <- st_read(conn, query = "SELECT * FROM scission_com;")
chgt_com <- dbGetQuery(conn,  "SELECT * FROM chgt_com;")
```

## Cas des parcelles dans le cas d'une fusion de communes

```{r fusion commune}
dbExecute(conn, "TRUNCATE TABLE fusion_com;")

dbExecute(conn, "
  INSERT INTO fusion_com
  WITH apres AS (
      SELECT
          idu, nom_com, code_com, com_abs, contenance,
          SUBSTR(idu, 1, 2) || com_abs || '000' || SUBSTR(idu, 9, 14) AS idu_avant,
          geometry
      FROM
          ajout
      WHERE com_abs != '000'
  )
  SELECT 
      apres.idu, apres.nom_com, apres.code_com, apres.com_abs, apres.contenance,
         supp.idu, supp.nom_com, supp.code_com, apres.geometry
  FROM
      apres
  JOIN supp ON apres.idu_avant = supp.idu;")

dbExecute(conn, paste0("
  INSERT INTO fusion_com
  WITH avant AS (
      SELECT
          idu, nom_com, code_com,
          SUBSTR(idu, 1, 2) AS prefix_idu,
          SUBSTR(idu, 6, 14) AS suffix_idu
      FROM
          supp
      WHERE com_abs != '000'
  )
  SELECT 
      ajout.idu, ajout.nom_com, ajout.code_com, ajout.com_abs, ajout.contenance,
         avant.idu, avant.nom_com, avant.code_com, ajout.geometry
  FROM
      avant
  JOIN ajout ON ajout.idu LIKE avant.prefix_idu || '___' || avant.suffix_idu
  WHERE avant.nom_com NOT IN (
      SELECT DISTINCT nom_com 
      FROM parc_", params$num_departement, "_", params$temps_apres,
  ") AND avant.nom_com IN (
      SELECT nom_com_avant 
      FROM disparition_com GROUP BY nom_com_avant HAVING COUNT(nom_com_apres) = 1);"))

dbExecute(conn, paste0(" 
  INSERT INTO chgt_com
  WITH fusion_data AS (
      SELECT
          nom_com, 
          code_com, 
          STRING_AGG(DISTINCT nom_com_avant, ', ') AS participants,
          STRING_AGG(DISTINCT code_com_avant, ', ') AS participants_code_com
      FROM
          fusion_com
      GROUP BY 
          nom_com, code_com
  ),
  com_avant AS (
      SELECT DISTINCT
          nom_com, code_com
      FROM 
          parc_", params$num_departement, "_", params$temps_avant,"
  )
  SELECT
      f.nom_com,
      f.code_com,
      'Fusion' AS changement,
      CASE 
          WHEN c.nom_com IS NOT NULL THEN 
              STRING_AGG(DISTINCT c.nom_com || ', ' || f.participants, ', ')
          ELSE 
              f.participants 
      END AS participants,
      CASE 
          WHEN c.nom_com IS NOT NULL THEN 
              STRING_AGG(DISTINCT c.code_com || ', ' || f.participants_code_com , ', ')
          ELSE 
              f.participants_code_com 
      END AS participants_code_com
  FROM
      fusion_data f
  LEFT JOIN 
      com_avant c ON f.nom_com = c.nom_com
  GROUP BY
      f.nom_com, c.nom_com, f.code_com, f.participants, f.participants_code_com;"))

dbExecute(conn, paste0(" 
  UPDATE chgt_com
  SET 
      nom_com_avant = disparition_com.nom_com_avant || ', ' || chgt_com.nom_com_avant,
      code_com_avant = disparition_com.code_com_avant || ', ' || chgt_com.code_com_avant
  FROM disparition_com
  WHERE chgt_com.nom_com_apres = disparition_com.nom_com_apres;"))

dbExecute(conn, paste0(" 
  INSERT INTO chgt_com
  SELECT nom_com_apres, code_com_apres, 'Changement de nom', nom_com_avant, code_com_avant
  FROM disparition_com
  WHERE nom_com_apres NOT IN (
      SELECT unnest(regexp_split_to_array(nom_com_apres, ',\\s*'))
      FROM chgt_com
  );"))

# Parcelles n'ayant pas été modifiées mise à part le nom de commune
```


```{r parcelle changeant de communes, eval=FALSE}
fusion_com <- st_read(conn, query = "SELECT * FROM fusion_com;")
chgt_com <- dbGetQuery(conn,  "SELECT * FROM chgt_com;")
```

# Focus parcelles avec changement "majeur" lié à un changement impactant l'identifiant des parcelles

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r ajout/supp geometry egal}
dbExecute(conn, "TRUNCATE TABLE ajout_simp, supp_simp, identique, echange_parc;")

dbExecute(conn, "
  INSERT INTO ajout_simp
  SELECT idu, nom_com, code_com, ST_SnapToGrid(geometry, 0.0001) AS geometry
  FROM ajout;")

dbExecute(conn, "
  INSERT INTO supp_simp
  SELECT idu, nom_com, code_com, ST_SnapToGrid(geometry, 0.0001) AS geometry
  FROM supp;")

dbExecute(conn, "
  INSERT INTO identique
  SELECT 
      ajout.idu, ajout.nom_com, ajout.code_com,
      supp.idu, supp.nom_com, supp.code_com
  FROM ajout_simp ajout
  JOIN supp_simp  supp
    ON ST_Equals(ajout.geometry, supp.geometry)
  WHERE ST_IsValid(ajout.geometry) 
      AND ST_IsValid(supp.geometry);")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH avant AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_avant, ',\\s*')) AS nom_avant
      FROM chgt_com
  ),
  apres AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_apres, ',\\s*')) AS nom_apres
      FROM chgt_com
  ),
  couples AS (
    SELECT a.nom_avant, b.nom_apres
    FROM avant a
    JOIN apres b ON a.nom_com_avant = b.nom_com_avant
  )
  SELECT idu_avant, nom_com_avant, code_com_avant, 
      idu_apres, nom_com_apres, code_com_apres  
  FROM identique
  LEFT JOIN couples c ON c.nom_avant = nom_com_avant AND c.nom_apres = nom_com_apres
  WHERE code_com_avant != code_com_apres
      AND (nom_avant IS NULL OR nom_apres IS NULL)
;"))

# Parcelles ajoutées n'ayant pas été modifiées
dbExecute(conn, "
  DELETE FROM ajout
  WHERE EXISTS (
      SELECT 1
      FROM identique
      WHERE ajout.idu = identique.idu_apres
  );")

# Parcelles supprimées n'ayant pas été modifiées
dbExecute(conn, "
  DELETE FROM supp
  WHERE EXISTS (
      SELECT 1
      FROM identique
      WHERE supp.idu = identique.idu_avant
  );")
```

```{r fusion/subdivision, eval=FALSE}
identique <- st_read(conn, query = "SELECT * FROM identique;")
echange_parc <- dbGetQuery(conn, "SELECT * FROM echange_parc;")
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
```

```{r eval=FALSE}
ajout <- dbGetQuery(conn, paste0("
  SELECT 
      avant.idu AS idu_avant, 
      apres.idu AS idu_apres,
      ST_Area(ST_Intersection(avant.geometry, apres.geometry)) / 
      LEAST(ST_Area(avant.geometry), ST_Area(apres.geometry)) AS surface_ratio
  FROM 
      supp avant
  JOIN 
      ajout apres
  ON 
      ST_Intersects(avant.geometry, apres.geometry) 
      AND avant.geometry && apres.geometry;"))

```

```{r distib iou, eval=FALSE}
quantiles <- quantile(ajout$surface_ratio, probs = c(0.3, 0.4, 0.5), na.rm = TRUE)

plot <- ggplot(na.omit(ajout), aes(x = surface_ratio)) +
  geom_histogram(aes(y = after_stat(count / sum(count))), fill = "skyblue", color = "black", alpha = 0.7) +
  geom_segment(x = quantiles[1], xend = quantiles[1], y = 0, yend = 0.3, color = "black", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[2], xend = quantiles[2], y = 0, yend = 0.3, color = "black", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[3], xend = quantiles[3], y = 0, yend = 0.5, color = "black", linetype = "dashed", linewidth = 0.6) +
  annotate("text", x = quantiles[1], y = 0.3, label = paste0("Q3: ", round(quantiles[1], 2)), color = "black", size = 4, vjust = -1.5) +
  annotate("text", x = quantiles[2], y = 0.3, label = paste0("Q4: ", round(quantiles[2], 2)), color = "black", size = 4,  vjust = -1.5) +
  annotate("text", x = quantiles[3], y = 0.5, label = paste0("Médiane: ", round(quantiles[3], 2)), color = "black", size = 4, vjust = -1.5) +
  labs(title = "",
       x = "Proportion de surface recouverte de deux parcelles s'intersectant, par rapport à la plus petite",
       y = "Fréquence",
       caption = "Champ: Parcelles avec changement d'identifiant, et restantes après l'étape d'élimination avec ST_Equals") +
  theme_bw()

plot

ggsave("www/Distribution_surface_ratio.png", plot = plot, width = 10, height = 8, dpi = 300)
```

## Reconnaissances des cas de fusion (peu fréquent) ou subdivision (plus courant)

```{r ajout/supp iou -> fusion/subdivision}
dbExecute(conn, "TRUNCATE TABLE redecoupage, fusion_ajout;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_intersect(geometry, 'ajout')).*
    FROM supp
  )
  UPDATE supp
  SET iou = updated_values.iou,
      participants = updated_values.participants
  FROM updated_values
  WHERE supp.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO redecoupage
  SELECT idu, nom_com, code_com, com_abs, contenance, iou, 
      idu, participants, geometry
  FROM supp
  WHERE iou >= 0.99 AND LENGTH(participants) != 14;")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH avant AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_avant, ',\\s*')) AS nom_avant
      FROM chgt_com
  ),
  apres AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_apres, ',\\s*')) AS nom_apres
      FROM chgt_com
  ),
  couples AS (
    SELECT a.nom_avant, b.nom_apres
    FROM avant a
    JOIN apres b ON a.nom_com_avant = b.nom_com_avant
  )
  SELECT supp.idu, supp.nom_com, supp.code_com, participants, 
      apres.nom_com, SUBSTRING(participants FROM 3 FOR 3) 
  FROM supp
  JOIN parc_", params$num_departement, "_", params$temps_avant, " apres
  ON apres.idu = supp.participants
  LEFT JOIN couples c ON c.nom_avant = supp.nom_com AND c.nom_apres = apres.nom_com
  WHERE iou >= 0.99 AND LENGTH(participants) = 14
  AND SUBSTRING(participants FROM 3 FOR 3) <> supp.code_com 
  AND (nom_avant IS NULL OR nom_apres IS NULL);"))

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants, ',\\s*')) 
      FROM supp WHERE iou >= 0.99
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE iou >= 0.99;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_intersect(geometry, 'supp')).*
    FROM ajout
  )
  UPDATE ajout
  SET iou = updated_values.iou,
      participants = updated_values.participants
  FROM updated_values
  WHERE ajout.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO fusion_ajout
  SELECT DISTINCT
      unnest(string_to_array(participants, ', ')), 
      iou,
      participants,
      idu,
      nom_com,
      code_com
  FROM
      ajout
  WHERE iou >= 0.99;")

dbExecute(conn, "
  INSERT INTO redecoupage
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, fa.iou, 
      fa.participants_avant, fa.participants_apres, supp.geometry
  FROM supp
  LEFT JOIN fusion_ajout fa ON fa.idu = supp.idu
  WHERE fa.iou >= 0.99 AND LENGTH(fa.participants_avant) != 14;")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH avant AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_avant, ',\\s*')) AS nom_avant
      FROM chgt_com
  ),
  apres AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_apres, ',\\s*')) AS nom_apres
      FROM chgt_com
  ),
  couples AS (
    SELECT a.nom_avant, b.nom_apres
    FROM avant a
    JOIN apres b ON a.nom_com_avant = b.nom_com_avant
  )
  SELECT fa.idu, supp.nom_com, supp.code_com, fa.participants_apres, 
      fa.nom_com_apres, fa.code_com_apres
  FROM supp
  JOIN fusion_ajout fa ON fa.idu = supp.idu
  LEFT JOIN couples c ON c.nom_avant = supp.nom_com AND c.nom_apres = fa.nom_com_apres
  WHERE LENGTH(fa.participants_avant) = 14
  AND SUBSTRING(fa.participants_avant FROM 3 FOR 3) <> fa.code_com_apres
  AND (nom_avant IS NULL OR nom_apres IS NULL);"))

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants, ',\\s*')) 
      FROM ajout WHERE iou >= 0.99
  );")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE iou >= 0.99;")
```


```{r fusion/subdivision, eval=FALSE}
fusion_ajout <- dbGetQuery(conn, "SELECT * FROM fusion_ajout;")
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
redecoupage <- st_read(conn, query = "SELECT * FROM redecoupage;")
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation, modification de contour avec translation

```{r ajout/supp iou_recale -> translation, contour + translation}
dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_intersect_best_recale(geometry, 'supp')).*
    FROM ajout
  )
  UPDATE ajout
  SET iou_recale = updated_values.iou_recale,
      idu_recale = updated_values.idu_recale
  FROM updated_values
  WHERE ajout.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO translation
  SELECT idu, nom_com, code_com, com_abs, contenance, iou_recale, 
      idu_recale, geometry
  FROM ajout
  WHERE iou_recale >= 0.99;")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE EXISTS (
      SELECT 1
      FROM translation
      WHERE ajout.idu = translation.idu
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE EXISTS (
      SELECT 1
      FROM translation
      WHERE supp.idu = translation.idu_recale
  );")
```


```{r contour translation ou translation seule, eval=FALSE}
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
translation <- st_read(conn, query = "SELECT * FROM translation;")
```

## Reconnaissances des cas de multi-subdivision (ex : 2 -> 3) ou modification de contours

```{r ajout/supp iou_multi -> multi-subdivision et contours}
dbExecute(conn, "TRUNCATE TABLE max_iou, multi_rapide;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi_rapide(geometry, 'supp', 'ajout', false, 0.9, 1)).*
    FROM supp
  )
  UPDATE supp
  SET iou_multi = updated_values.iou_multi,
      participants_avant = updated_values.participants_avant,
      participants_apres = updated_values.participants_apres
  FROM updated_values
  WHERE supp.idu = updated_values.idu")


dbExecute(conn, "
  INSERT INTO max_iou
  SELECT idu, MAX(iou_multi) AS max_iou
  FROM (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) AS idu, 
          iou_multi
      FROM supp
      WHERE iou_multi >= 0.99
  ) subquery
  GROUP BY idu;")

dbExecute(conn, "
  INSERT INTO multi_rapide
  SELECT DISTINCT ON (sub.idu) sub.idu, sub.iou_multi, 
      sub.participants_avant, sub.participants_apres
  FROM (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) AS idu, 
          iou_multi, participants_avant, participants_apres
      FROM supp
      WHERE iou_multi >= 0.99
  ) sub
  JOIN max_iou mi
  ON sub.idu = mi.idu AND sub.iou_multi = mi.max_iou
  ORDER BY sub.idu, sub.iou_multi DESC;")

# Attention peut etre bidon
dbExecute(conn, "
  WITH decomposed AS (
      SELECT
          idu,
          unnest(regexp_split_to_array(participants_avant, ',\\s*')) AS participant_id
      FROM multi_rapide
  ),
  participant_groups AS (
      SELECT
          idu,
          array_agg(DISTINCT participant_id ORDER BY participant_id) AS participants_list
      FROM decomposed
      GROUP BY idu
  ),
  conflicting AS (
      SELECT DISTINCT t2.idu
      FROM participant_groups t1
      JOIN participant_groups t2
      ON t1.idu <> t2.idu
      AND t1.idu = ANY(t2.participants_list)
      WHERE t1.participants_list <> t2.participants_list
  )
  DELETE FROM multi_rapide
  WHERE idu  IN (SELECT idu FROM conflicting);
")

dbExecute(conn, "
  INSERT INTO redecoupage
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, 
      mtr.iou_multi, mtr.participants_avant, mtr.participants_apres, supp.geometry
  FROM multi_rapide mtr
  LEFT JOIN supp ON mtr.idu = supp.idu 
  WHERE LENGTH(mtr.participants_apres) != LENGTH(mtr.participants_avant);")

dbExecute(conn, "
  INSERT INTO contour
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, 
      mtr.iou_multi, mtr.participants_avant, mtr.participants_apres, supp.geometry
  FROM multi_rapide mtr
  LEFT JOIN supp ON mtr.idu = supp.idu 
  WHERE LENGTH(mtr.participants_apres) = LENGTH(mtr.participants_avant);")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM multi_rapide
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM multi_rapide
  );")
```


```{r multisubdiv sql, eval=FALSE}
multi_rapide <-  dbGetQuery(conn, "SELECT * FROM multi_rapide;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
redecoupage <- st_read(conn, query = "SELECT * FROM redecoupage;")
contour <- st_read(conn, query = "SELECT * FROM contour;")
```


```{r ajout/supp iou_multi -> multi-subdivision et contours}
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache, contour_redecoupage;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi(idu, geometry, 'supp', 'ajout')).*
    FROM supp
  )
  UPDATE supp
  SET iou_multi = updated_values.iou_multi,
      participants_avant = updated_values.participants_avant,
      participants_apres = updated_values.participants_apres
  FROM updated_values
  WHERE supp.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO redecoupage
  SELECT idu, nom_com, code_com, com_abs, contenance, iou_multi, 
      participants_avant, participants_apres, geometry
  FROM supp
  WHERE iou_multi >= 0.99 
      AND LENGTH(participants_apres) != LENGTH(participants_avant);")

dbExecute(conn, "
  INSERT INTO contour_redecoupage
  SELECT idu, nom_com, code_com, com_abs, contenance, iou_multi, 
      participants_avant, participants_apres, geometry
  FROM supp
  WHERE (iou_multi >= 0.95 
      AND LENGTH(participants_apres) != LENGTH(participants_avant) 
      AND iou_multi < 0.99
  );")

dbExecute(conn, "
  INSERT INTO contour
  SELECT idu, nom_com, code_com, com_abs, contenance, iou_multi, 
      participants_avant, participants_apres, geometry
  FROM supp
  WHERE iou_multi >= 0.95 
      AND LENGTH(participants_apres) = LENGTH(participants_avant);")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM redecoupage
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM contour
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM contour_redecoupage
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM redecoupage
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM contour
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM contour_redecoupage
  );")
```


```{r multisubdiv sql, eval=FALSE}
supp <- st_read(conn, query = "SELECT * FROM supp;")
redecoupage <- st_read(conn, query = "SELECT * FROM redecoupage;")
contour_redecoupage <- st_read(conn, query = "SELECT * FROM contour_redecoupage;")
contour <- st_read(conn, query = "SELECT * FROM contour;")
```

## Reconnaissances des cas de modification de contours plus compliquée

## Cas rapide translation transformation

```{r rapide}
dbExecute(conn, "TRUNCATE TABLE max_iou, multi_rapide;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi_rapide(geometry, 'supp', 'ajout', true, 0, 1)).*
    FROM supp
  )
  UPDATE supp
  SET iou_multi_recale = updated_values.iou_multi,
      participants_avant_recale = updated_values.participants_avant,
      participants_apres_recale = updated_values.participants_apres
  FROM updated_values
  WHERE supp.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO max_iou
  SELECT idu, MAX(iou_multi_recale) AS max_iou
  FROM (
      SELECT unnest(regexp_split_to_array(participants_avant_recale, ',\\s*')) AS idu, 
          iou_multi_recale
      FROM supp
      WHERE iou_multi_recale >= 0.95
  ) subquery
  GROUP BY idu;")

dbExecute(conn, "
  INSERT INTO multi_rapide
  SELECT DISTINCT ON (sub.idu) sub.idu, sub.iou_multi_recale, 
      sub.participants_avant_recale, sub.participants_apres_recale
  FROM (
      SELECT unnest(regexp_split_to_array(participants_avant_recale, ',\\s*')) AS idu, 
          iou_multi_recale, participants_avant_recale, participants_apres_recale
      FROM supp
      WHERE iou_multi_recale >= 0.95
  ) sub
  JOIN max_iou mi
  ON sub.idu = mi.idu AND sub.iou_multi_recale = mi.max_iou
  ORDER BY sub.idu, sub.iou_multi_recale DESC;")

dbExecute(conn, "
  WITH decomposed AS (
      SELECT
          idu,
          unnest(regexp_split_to_array(participants_avant, ',\\s*')) AS participant_id
      FROM multi_rapide
  ),
  participant_groups AS (
      SELECT
          idu,
          array_agg(DISTINCT participant_id ORDER BY participant_id) AS participants_list
      FROM decomposed
      GROUP BY idu
  ),
  conflicting AS (
      SELECT DISTINCT t2.idu
      FROM participant_groups t1
      JOIN participant_groups t2
      ON t1.idu <> t2.idu
      AND t1.idu = ANY(t2.participants_list)
      WHERE t1.participants_list <> t2.participants_list
  )
  DELETE FROM multi_rapide
  WHERE idu  IN (SELECT idu FROM conflicting);
")

dbExecute(conn, "
  INSERT INTO contour_redecoupage
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, 
      supp.contenance, mtr.iou_multi, 
      mtr.participants_avant, mtr.participants_apres, 
      supp.geometry
  FROM multi_rapide mtr
  LEFT JOIN supp ON mtr.idu = supp.idu;")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM multi_rapide
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM multi_rapide
  );")
```


```{r contour_redecoupagen_rapide, eval=FALSE}
contour_redecoupage <- st_read(conn, query = "SELECT * FROM contour_redecoupage;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation avec modification de contour et avec fusion

```{r ajout/supp iou_recale -> contour_fusion_translation}
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi(idu, geometry, 'supp', 'ajout', true, 0)).*
    FROM supp
  )
  UPDATE supp
  SET iou_multi_recale = updated_values.iou_multi,
      participants_avant_recale = updated_values.participants_avant,
      participants_apres_recale = updated_values.participants_apres
  FROM updated_values
  WHERE supp.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO contour_redecoupage
  SELECT idu, nom_com, code_com, com_abs, contenance, iou_multi_recale, 
      participants_avant_recale, participants_apres_recale, geometry
  FROM supp
  WHERE iou_multi_recale >= 0.95;")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM contour_redecoupage
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM contour_redecoupage
  );")
```


```{r contour_fusion_translation, eval=FALSE}
contour_redecoupage <- st_read(conn, query = "SELECT * FROM contour_redecoupage;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
```

# Ajout d'un iou_multi pour ajout

```{r}
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache, multi_ajout;")

dbExecute(conn, "
  INSERT INTO multi_ajout
  WITH calc_results AS (
      SELECT
          idu,
          (calcul_iou_multi(idu, geometry, 'ajout', 'supp')).*
      FROM
          ajout
  )
  SELECT DISTINCT
      unnest(string_to_array(participants_apres, ', ')) AS idu, 
      iou_multi,
      participants_apres,
      participants_avant
  FROM
      calc_results
  WHERE iou_multi >= 0.95;")

dbExecute(conn, "
  INSERT INTO redecoupage
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, 
      ma.iou_multi, ma.participants_avant, ma.participants_apres, supp.geometry
  FROM supp
  LEFT JOIN multi_ajout ma ON ma.idu = supp.idu
  WHERE ma.iou_multi >= 0.99 
      AND LENGTH(ma.participants_apres) != LENGTH(ma.participants_avant);")

dbExecute(conn, "
  INSERT INTO contour
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, 
      ma.iou_multi, ma.participants_avant, ma.participants_apres, supp.geometry
  FROM supp
  LEFT JOIN multi_ajout ma ON ma.idu = supp.idu
  WHERE ma.iou_multi >= 0.95 
      AND LENGTH(ma.participants_apres) = LENGTH(ma.participants_avant);")

dbExecute(conn, "
  INSERT INTO contour_redecoupage
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, 
      ma.iou_multi, ma.participants_avant, ma.participants_apres, supp.geometry
  FROM supp
  LEFT JOIN multi_ajout ma ON ma.idu = supp.idu
  WHERE (ma.iou_multi >= 0.95 
      AND LENGTH(ma.participants_apres) != LENGTH(ma.participants_avant) 
      AND ma.iou_multi < 0.99);")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM redecoupage
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM contour
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM contour_redecoupage
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM redecoupage
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*'))
      FROM contour
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM contour_redecoupage
  );")
```


```{r contour_fusion_translation, eval=FALSE}
redecoupage <- st_read(conn, query = "SELECT * FROM redecoupage;")
contour_redecoupage <- st_read(conn, query = "SELECT * FROM contour_redecoupage;")
contour <- st_read(conn, query = "SELECT * FROM contour;")
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
```

## Recalcul de l'IoU pour détecter les parcelles maintenant isolées -> Véritable ajout ou suppression

```{r le reste}
dbExecute(conn, "TRUNCATE TABLE vrai_ajout, vrai_supp;")

dbExecute(conn, "
  INSERT INTO vrai_ajout
  SELECT idu, nom_com, code_com, com_abs, contenance, geometry
  FROM ajout
  WHERE NOT EXISTS (
      SELECT 1 FROM supp WHERE ST_DWithin(ajout.geometry, supp.geometry, 50) 
  );")

dbExecute(conn, "
  INSERT INTO vrai_supp
  SELECT idu, nom_com, code_com, com_abs, contenance, geometry
  FROM supp
  WHERE NOT EXISTS (
      SELECT 1 FROM ajout WHERE ST_DWithin(ajout.geometry, supp.geometry, 50) 
  );")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE EXISTS (
      SELECT 1
      FROM vrai_ajout
      WHERE ajout.idu = vrai_ajout.idu
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE EXISTS (
      SELECT 1
      FROM vrai_supp
      WHERE supp.idu = vrai_supp.idu
  );")
```


```{r le reste, eval=FALSE}
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")

vrai_ajout <- st_read(conn, query = "SELECT * FROM vrai_ajout;")
vrai_supp <- st_read(conn, query = "SELECT * FROM vrai_supp;")

# 132078330A0082 cas d'une parcelle disparu en 2024 mais pas affiché comme vrai supp -> multipolygon empty
# 13041000AM0018 parcelle participant a une multi subdiv mais qui a l'air iou parfait
```


```{r echanges parcelles}
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache, echange_parc_possible;")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH avant AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_avant, ',\\s*')) AS nom_avant
      FROM chgt_com
  ),
  apres AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_apres, ',\\s*')) AS nom_apres
      FROM chgt_com
  ),
  couples AS (
    SELECT a.nom_avant, b.nom_apres
    FROM avant a
    JOIN apres b ON a.nom_com_avant = b.nom_com_avant
  )
  SELECT idu_recale, avant.nom_com, SUBSTRING(idu_recale FROM 3 FOR 3), 
      tr.idu, tr.nom_com, tr.code_com
  FROM translation tr
  JOIN parc_", params$num_departement, "_", params$temps_avant, " avant
  ON avant.idu = tr.idu_recale
  LEFT JOIN couples c ON c.nom_avant = avant.nom_com AND c.nom_apres = tr.nom_com
  WHERE SUBSTRING(idu_recale FROM 3 FOR 3) <> tr.code_com
  AND (nom_avant IS NULL OR nom_apres IS NULL);"))

dbExecute(conn, "
  DELETE FROM translation
  WHERE EXISTS (
      SELECT 1
      FROM echange_parc
      WHERE translation.idu = echange_parc.participants_apres
  );")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH avant AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_avant, ',\\s*')) AS nom_avant
      FROM chgt_com
  ),
  apres AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_apres, ',\\s*')) AS nom_apres
      FROM chgt_com
  ),
  couples AS (
      SELECT a.nom_avant, b.nom_apres
      FROM avant a
      JOIN apres b ON a.nom_com_avant = b.nom_com_avant
  ),
  echange AS (
      SELECT 
          (echange_parcelles(
          MIN(idu),
          'redecoupage', 
          'parc_", params$num_departement, "_", params$temps_avant, "',
          'parc_", params$num_departement, "_", params$temps_apres, "')).*
      FROM redecoupage
      GROUP BY participants_avant
  ),
  resultats_base AS (
      SELECT DISTINCT ON (red.participants_avant) 
          red.participants_avant, 
          red.nom_com AS nom_com_avant, 
          red.code_com AS code_com_avant, 
          red.participants_apres, 
          apres.nom_com AS nom_com_apres, 
          ech.code_com_apres
      FROM echange ech
      JOIN redecoupage red ON red.idu = ech.idu
      JOIN parc_", params$num_departement, "_", params$temps_apres, " apres 
      ON apres.code_com = ech.code_com_apres
  )
  SELECT 
      rb.participants_avant, 
      rb.nom_com_avant, 
      rb.code_com_avant, 
      rb.participants_apres, 
      rb.nom_com_apres, 
      rb.code_com_apres
  FROM resultats_base rb
  LEFT JOIN couples c ON c.nom_avant = rb.nom_com_avant AND c.nom_apres = rb.nom_com_apres
  WHERE c.nom_avant IS NULL OR c.nom_apres IS NULL;
"))

dbExecute(conn, "
  DELETE FROM redecoupage
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM echange_parc
  );")


dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH avant AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_avant, ',\\s*')) AS nom_avant
      FROM chgt_com
  ),
  apres AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_apres, ',\\s*')) AS nom_apres
      FROM chgt_com
  ),
  couples AS (
      SELECT a.nom_avant, b.nom_apres
      FROM avant a
      JOIN apres b ON a.nom_com_avant = b.nom_com_avant
  ),
  echange AS (
      SELECT 
          (echange_parcelles(
          MIN(idu),
          'contour', 
          'parc_", params$num_departement, "_", params$temps_avant, "',
          'parc_", params$num_departement, "_", params$temps_apres, "')).*
      FROM contour
      GROUP BY participants_avant
  ),
  resultats_base AS (
      SELECT DISTINCT ON (con.participants_avant) 
          con.participants_avant, 
          con.nom_com AS nom_com_avant, 
          con.code_com AS code_com_avant, 
          con.participants_apres, 
          apres.nom_com AS nom_com_apres, 
          ech.code_com_apres
      FROM echange ech
      JOIN contour con ON con.idu = ech.idu
      JOIN parc_", params$num_departement, "_", params$temps_apres, " apres 
      ON apres.code_com = ech.code_com_apres
  )
  SELECT 
      rb.participants_avant, 
      rb.nom_com_avant, 
      rb.code_com_avant, 
      rb.participants_apres, 
      rb.nom_com_apres, 
      rb.code_com_apres
  FROM resultats_base rb
  LEFT JOIN couples c ON c.nom_avant = rb.nom_com_avant AND c.nom_apres = rb.nom_com_apres
  WHERE c.nom_avant IS NULL OR c.nom_apres IS NULL;
"))

dbExecute(conn, "
  DELETE FROM contour
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM echange_parc
  );")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH avant AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_avant, ',\\s*')) AS nom_avant
      FROM chgt_com
  ),
  apres AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_apres, ',\\s*')) AS nom_apres
      FROM chgt_com
  ),
  couples AS (
      SELECT a.nom_avant, b.nom_apres
      FROM avant a
      JOIN apres b ON a.nom_com_avant = b.nom_com_avant
  ),
  echange AS (
      SELECT 
          (echange_parcelles(
          MIN(idu),
          'contour_redecoupage', 
          'parc_", params$num_departement, "_", params$temps_avant, "',
          'parc_", params$num_departement, "_", params$temps_apres, "')).*
      FROM contour_redecoupage
      GROUP BY participants_avant
  ),
  resultats_base AS (
      SELECT DISTINCT ON (con.participants_avant) 
          con.participants_avant, 
          con.nom_com AS nom_com_avant, 
          con.code_com AS code_com_avant, 
          con.participants_apres, 
          apres.nom_com AS nom_com_apres, 
          ech.code_com_apres
      FROM echange ech
      JOIN contour_redecoupage con ON con.idu = ech.idu
      JOIN parc_", params$num_departement, "_", params$temps_apres, " apres 
      ON apres.code_com = ech.code_com_apres
  )
  SELECT 
      rb.participants_avant, 
      rb.nom_com_avant, 
      rb.code_com_avant, 
      rb.participants_apres, 
      rb.nom_com_apres, 
      rb.code_com_apres
  FROM resultats_base rb
  LEFT JOIN couples c ON c.nom_avant = rb.nom_com_avant AND c.nom_apres = rb.nom_com_apres
  WHERE c.nom_avant IS NULL OR c.nom_apres IS NULL;
"))

dbExecute(conn, "
  DELETE FROM contour_redecoupage
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM echange_parc
  );")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi(idu, geometry, 'supp', 'ajout', false, 0)).*
    FROM supp
  )
  UPDATE supp
  SET iou_multi = updated_values.iou_multi,
      participants_avant = updated_values.participants_avant,
      participants_apres = updated_values.participants_apres
  FROM updated_values
  WHERE supp.idu = updated_values.idu")

dbExecute(conn, paste0("
  INSERT INTO echange_parc_possible
  WITH avant AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_avant, ',\\s*')) AS nom_avant
      FROM chgt_com
  ),
  apres AS (
      SELECT nom_com_avant, unnest(regexp_split_to_array(nom_com_apres, ',\\s*')) AS nom_apres
      FROM chgt_com
  ),
  couples AS (
      SELECT a.nom_avant, b.nom_apres
      FROM avant a
      JOIN apres b ON a.nom_com_avant = b.nom_com_avant
  ),
  echange AS (
      SELECT 
          (echange_parcelles(
          MIN(idu),
          'supp', 
          'parc_", params$num_departement, "_", params$temps_avant, "',
          'parc_", params$num_departement, "_", params$temps_apres, "')).*
      FROM supp
      GROUP BY participants_avant
  ),
  resultats_base AS (
      SELECT DISTINCT ON (supp.participants_avant) 
          supp.participants_avant, 
          supp.nom_com AS nom_com_avant, 
          supp.code_com AS code_com_avant, 
          supp.participants_apres, 
          apres.nom_com AS nom_com_apres, 
          ech.code_com_apres
      FROM echange ech
      JOIN supp ON supp.idu = ech.idu
      JOIN parc_", params$num_departement, "_", params$temps_apres, " apres 
      ON apres.code_com = ech.code_com_apres
  )
  SELECT 
      rb.participants_avant, 
      rb.nom_com_avant, 
      rb.code_com_avant, 
      rb.participants_apres, 
      rb.nom_com_apres, 
      rb.code_com_apres
  FROM resultats_base rb
  LEFT JOIN couples c ON c.nom_avant = rb.nom_com_avant AND c.nom_apres = rb.nom_com_apres
  WHERE c.nom_avant IS NULL OR c.nom_apres IS NULL;
"))

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM echange_parc_possible
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM echange_parc_possible
  );")
```

```{r, eval=FALSE}
echange_parc <- dbGetQuery(conn, "SELECT * FROM echange_parc;")
echange_parc_possible <- dbGetQuery(conn, "SELECT * FROM echange_parc_possible;")
```

```{r carte reste, eval=FALSE}
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
modif_avant <- st_read(conn, query = "
                       SELECT idu, nom_com, code_com, com_abs, contenance_avant,
                            iou, iou_recale, iou_multi, participants_avant, 
                            participants_apres, geometry_avant FROM modif;")

modif_apres <- st_read(conn, query = "
                       SELECT idu, nom_com, code_com, com_abs, contenance_apres,
                            iou, iou_recale, iou_multi, participants_avant, 
                            participants_apres, geometry_apres FROM modif;")

map <- mapview()

if (nrow(ajout) > 0) {
  map <- map + mapview(ajout,
                       z = c("iou_recale"), layer.name = paste0("Parcelles restantes (état 20",params$temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(supp) > 0) {
  map <- map + mapview(supp, 
                       z = c("iou_multi"), layer.name = paste0("Parcelles restantes (état 20",params$temps_avant,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(modif_apres) > 0) {
  map <- map + mapview(modif_apres, 
                       z = c("iou_recale"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",params$temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(modif_avant) > 0) {
  map <- map + mapview(modif_avant, 
                       z = c("iou_recale"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",params$temps_avant,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
mapshot(map, url = paste0("parcelles_restantes_",params$num_departement,"_",params$temps_apres,"-",params$temps_avant,".html"))
```

# Visualisation finale sur une carte du département

```{r mapview typologie parcelles, eval=FALSE}
bordure <- st_read(conn, query = "SELECT * FROM bordure;")

parc_avant <- st_read(conn, query = paste0("SELECT * FROM parc_", params$num_departement, "_", params$temps_avant, ";"))
parc_apres <- st_read(conn, query = paste0("SELECT * FROM parc_", params$num_departement, "_", params$temps_apres, ";"))

contour <- st_read(conn, query = "SELECT * FROM contour;")
translation <- st_read(conn, query = "SELECT * FROM translation;")
redecoupage <- st_read(conn, query = "SELECT * FROM redecoupage;")
contour_redecoupage <- st_read(conn, query = "SELECT * FROM contour_redecoupage;")
vrai_ajout <- st_read(conn, query = "SELECT * FROM vrai_ajout;")
vrai_supp <- st_read(conn, query = "SELECT * FROM vrai_supp;")

scission_com <- st_read(conn, query = "SELECT * FROM scission_com;")
fusion_com <- st_read(conn, query = "SELECT * FROM fusion_com;")

ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
modif_avant <- st_read(conn, query = "
                       SELECT idu, nom_com, code_com, com_abs, contenance_avant,
                            iou, iou_recale, iou_multi, participants_avant, 
                            participants_apres, geometry_avant FROM modif;")

modif_apres <- st_read(conn, query = "
                       SELECT idu, nom_com, code_com, com_abs, contenance_apres,
                            iou, iou_recale, iou_multi, participants_avant, 
                            participants_apres, geometry_apres FROM modif;")

map <- mapview(bordure, 
               layer.name = "Bordures étendues", col.regions = "#F2F2F2", 
               alpha.regions = 0.7, homebutton = F,
               map.types = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldImagery"))

if (nrow(translation) > 0) {
  map <- map + mapview(translation,
                       layer.name = paste0("Parcelles translatées (état 20",params$temps_apres,")"), 
                       col.regions = "#069F9C",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(parc_avant %>%
              filter(idu %in% translation$idu_recale),
            col.regions = "#069F9C",
            layer.name = paste0("Parcelles translatées (état 20",params$temps_avant,")"), 
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour) > 0) {
  map <- map + mapview(parc_apres %>%
                         filter(idu %in% unlist(str_split(contour$participants_apres, ",\\s*"))),  
                       layer.name = paste0("Parcelles contours (état 20",params$temps_apres,")"), 
                       col.regions = "#D79700", alpha.regions = 0.5, homebutton = F)  +
    mapview(contour,  
            layer.name = paste0("Parcelles contours (état 20",params$temps_avant,")"),
            col.regions = "#D79700",
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(redecoupage) > 0) {
  map <- map + mapview(parc_apres %>%
                         filter(idu %in% unlist(str_split(redecoupage$participants_apres, ",\\s*"))),
                       layer.name = paste0("Parcelles redécoupées (état 20",params$temps_apres,")"),
                       col.regions = "#AE48C0",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(redecoupage,  
            layer.name = paste0("Parcelles redécoupées (état 20",params$temps_avant,")"), 
            col.regions = "#AE48C0", alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(contour_redecoupage) > 0) {
  map <- map + mapview(parc_apres %>%
                         filter(idu %in% unlist(str_split(contour_redecoupage$participants_apres, ",\\s*"))),  
                       layer.name = paste0("Parcelles redecoupage + contours (état 20",params$temps_apres,")"),
                       col.regions = "#FFB9BB",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(contour_redecoupage,
            layer.name = paste0("Parcelles redecoupage + contours (état 20",params$temps_avant,")"), 
            col.regions = "#FFB9BB", alpha.regions = 0.5, homebutton = F)
}
if (nrow(scission_com) > 0) {
  map <- map + mapview(scission_com,  
                       layer.name = paste0("Parcelles scission de communes (état 20",params$temps_apres,")"), 
                       col.regions = "white",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(parc_avant %>%
              filter(idu %in% scission_com$idu_avant),  
            layer.name = paste0("Parcelles scission de communes (état 20",params$temps_avant,")"), 
            col.regions = "white", alpha.regions = 0.5, homebutton = F)
}
if (nrow(fusion_com) > 0) {
  map <- map + mapview(fusion_com,  
                       layer.name = paste0("Parcelles fusion de communes (état 20",params$temps_apres,")"), 
                       col.regions = "white",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(parc_avant %>%
              filter(idu %in% fusion_com$idu_avant),  
            layer.name = paste0("Parcelles fusion de communes (état 20",params$temps_avant,")"), 
            col.regions = "white", alpha.regions = 0.5, homebutton = F)
}
if (nrow(vrai_ajout) > 0) {
  map <- map + mapview(vrai_ajout, 
                       layer.name = "Parcelles véritablement ajoutées", 
                       col.regions = "#26A44B", alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(vrai_supp) > 0) {
  map <- map + mapview(vrai_supp,
                       layer.name = "Parcelles véritablement supprimées",
                       col.regions = "#E91422", alpha.regions = 0.5, homebutton = F) 
}
if (nrow(ajout) > 0) {
  map <- map + mapview(ajout,
                       z = c("iou_recale"), layer.name = paste0("Parcelles restantes (état 20",params$temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(supp) > 0) {
  map <- map + mapview(supp, 
                       z = c("iou_multi"), layer.name = paste0("Parcelles restantes (état 20",params$temps_avant,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(modif_apres) > 0) {
  map <- map + mapview(modif_apres, 
                       z = c("iou_recale"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",params$temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(modif_avant) > 0) {
  map <- map + mapview(modif_avant, 
                       z = c("iou_recale"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",params$temps_avant,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
mapshot(map, url = paste0("parcelles_",params$num_departement,"_",params$temps_apres,"-",params$temps_avant,".html"))
```

```{r nettoyage table inutile}
dbExecute(conn, "
  DROP TABLE IF EXISTS multi_calcul_cache, identique, ajout_simp, 
  supp_simp, fusion_ajout, max_iou, disparition_com, multi_rapide, 
  multi_ajout, scission_com, fusion_com CASCADE
;")
dbListTables(conn)
```

```{r eval=FALSE, include=FALSE}
cartes_dynamiques <- function(conn, num_departement, temps_apres, temps_avant, nom_com) {
  
  bordure <- st_read(conn, query = paste0(
    "SELECT * FROM bordure WHERE nom_com IN (", nom_com, ");"))
  parc_avant <- st_read(conn, query = paste0(
    "SELECT * FROM parc_", num_departement, "_", temps_avant, " WHERE nom_com IN (", nom_com, ");"))
  parc_apres <- st_read(conn, query = paste0(
    "SELECT * FROM parc_", num_departement, "_", temps_apres, " WHERE nom_com IN (", nom_com, ");"))
  
  modif_apres <- st_read(conn, query =  paste0(
    "SELECT idu, nom_com, code_com, com_abs, contenance_apres,
        iou, iou_recale, iou_multi, participants_avant, 
        participants_apres, geometry_apres 
    FROM modif WHERE nom_com IN (", nom_com, ");"))
  
  ajout <- st_read(conn, query =  paste0(
    "SELECT * FROM ajout WHERE nom_com IN (", nom_com, ");"))
  
  translation <- st_read(conn, query = paste0(
    "SELECT * FROM translation WHERE nom_com IN (", nom_com, ");"))
  vrai_ajout <- st_read(conn, query = paste0(
    "SELECT * FROM vrai_ajout WHERE nom_com IN (", nom_com, ");"))
  
  if (nrow(bordure) > 0) {
    
    contour_commune <- st_read(conn, query = paste0(
      "SELECT nom_com, code_insee, ST_Boundary(geometry) AS geometry FROM com_", num_departement, " WHERE nom_com IN (", nom_com, ");"))
    
    map_base <- mapview(bordure, 
                        layer.name = "Bordures étendues", col.regions = "#F2F2F2", 
                        alpha.regions = 0.7, homebutton = F,
                        map.types = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldImagery")) +
      mapview(contour_commune, color = "black",
              layer.name = "Contour communal",
              homebutton = F,
              legend = FALSE,
              map.types = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldImagery"))
    
    
    map_base_2 <- mapview(contour_commune, legend = FALSE, color = "black",
                          layer.name = "Contour communal",
                          homebutton = F, 
                          map.types = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldImagery"))
  }
  
  map_1 <- map_base
  
  modif_avant <- st_read(conn, query =  paste0(
    "SELECT idu, nom_com, code_com, com_abs, contenance_avant,
          iou, iou_recale, iou_multi, participants_avant, 
          participants_apres, geometry_avant
      FROM modif WHERE nom_com IN (", nom_com, ");"))
  contour <- st_read(conn, query = paste0(
    "SELECT * FROM contour WHERE nom_com IN (", nom_com, ");"))
  redecoupage <- st_read(conn, query = paste0(
    "SELECT * FROM redecoupage WHERE nom_com IN (", nom_com, ");"))
  contour_redecoupage <- st_read(conn, query = paste0(
    "SELECT * FROM contour_redecoupage WHERE nom_com IN (", nom_com, ");"))
  
  if (nrow(translation) > 0) {
    
    map_1 <- map_1 + mapview(translation,
                             layer.name = paste0("Parcelles translatées"), 
                             col.regions = "#FFDA5A", homebutton = F)
    
  }
  if (nrow(contour) > 0) {
    
    map_1 <- map_1 + mapview(parc_apres %>%
                               filter(idu %in% unlist(str_split(contour$participants_apres, ",\\s*"))),  
                             layer.name = paste0("Parcelles contours"), 
                             col.regions = "#069F9C", homebutton = F)
  }
  if (nrow(redecoupage) > 0) {
    
    map_1 <- map_1 + mapview(parc_apres %>%
                               filter(idu %in% unlist(str_split(redecoupage$participants_apres, ",\\s*"))),
                             layer.name = paste0("Parcelles redécoupées"),
                             col.regions = "#AE48C0", homebutton = F)
  }
  if (nrow(contour_redecoupage) > 0) {
    
    map_1 <- map_1 + mapview(parc_apres %>%
                               filter(idu %in% unlist(str_split(contour_redecoupage$participants_apres, ",\\s*"))),  
                             layer.name = paste0("Parcelles redécoupées + contours"),
                             col.regions = "#268DFF", homebutton = F)
  }
  if (nrow(vrai_ajout[!st_is_empty(vrai_ajout), ]) > 0) {
    
    map_1 <- map_1 + mapview(vrai_ajout, 
                             layer.name = "Parcelles ajoutées", 
                             col.regions = "#26A44B", homebutton = F)
  }
  if (nrow(ajout) > 0) {
    
    map_1 <- map_1 + mapview(ajout, col.regions = "#E91422",
                             layer.name = paste0("Parcelles restantes"), homebutton = F)
  }
  if (nrow(modif_apres) > 0) {
    
    map_1 <- map_1 + mapview(modif_apres,  col.regions = "#E91422",
                             layer.name = paste0("Parcelles restantes"), homebutton = F)
  }
  map_1
}

map <- cartes_dynamiques(conn, "85", "24", "23", "'Saint-Avaugourd-des-Landes'")
mapshot(map, url = paste0("test.html"))
```

