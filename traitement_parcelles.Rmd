---
title: "Traitement des parcelles d'un département"
output: html_document
date: "2024-06-18"
params:
  num_departement: "60"
  temps_apres: 24
  temps_avant: 23
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = FALSE)
```

# Import package + fonction utilisés après

```{r package message=FALSE, warning=FALSE}
# rm(list = ls())
library(sf)
library(dplyr)
library(mapview)
library(DBI)
library(ggplot2)
library(webshot)
library(stringr)
# webshot::install_phantomjs()
# Importation des packages nécessaires au traitement et à la production des cartes

source(file = "database/connexion_db.R")
conn <- connecter()
# Connexion à la base de donnée Postgre

nb_parcelles_seuil <- 5e05
# Seuil limitant l'arrêt de la partie traitement pour les parcelles dont 
# l'identifiant est présent sur les deux périodes de temps

source(file = "fonctions/fonction_sql.R")
# Importation des fonctions codées en Postgre SQL nécessaires au traitement
# notamment l'IoU et ses variantes
```


```{r reset traitement}
dbExecute(conn, paste0(
  "DROP SCHEMA IF EXISTS traitement_", params$temps_apres, "_", params$temps_avant, "_cadastre_", params$num_departement, " CASCADE;"))
# Suppression du schéma contenant les tables de traitement si déjà effectué auparavant

source(file = "database/table_traitement_db.R")
# Création du schéma et des tables nécessaire au traitement et à la typologie des parcelles

dbExecute(conn, "SET client_min_messages TO NOTICE;")
# Permet d'afficher des messages dans la console lors de requêtes SQL
```

# Mise de côté des parcelles non présentes sur les deux périodes de temps à la fois

```{r ajout/supp}
dbExecute(conn, "TRUNCATE TABLE ajout, supp;")
# Vide les tables 'ajout' et 'supp'
# Ceci est utile si l'on souhaite relancer le chunk sans devoir tout relancer
# Certain chunk nécessite de relancer des chunks en amont et ne peuvent être
# relancer (cas d'une table qu'on a remplit en partie auparavant et qu'on ne peut
# vider à cette étape). Ils seront signalé en début de chunk

dbExecute(conn, paste0("
  INSERT INTO ajout (idu, nom_com, code_com, com_abs, contenance, geometry)
  SELECT idu, nom_com, code_com, com_abs, contenance, geometry
  FROM parc_", params$num_departement, "_", params$temps_apres, " apres
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_", params$num_departement, "_", params$temps_avant," avant
    WHERE apres.idu = avant.idu
  );"))
# Parcelles à la période T non présentes à T-1

dbExecute(conn, paste0("
  INSERT INTO supp (idu, nom_com, code_com, com_abs, contenance, geometry)
  SELECT idu, nom_com, code_com, com_abs, contenance, geometry
  FROM parc_", params$num_departement, "_", params$temps_avant, " avant
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_", params$num_departement, "_", params$temps_apres," apres
    WHERE avant.idu = apres.idu
  );"))
# Parcelles à la période T-1 non présentes à T
```


```{r, eval=FALSE}
# Les chunks avec 'eval=FALSE' ne se lance que manuellement
# Ces imports permettent de vérifier les différents remplissages des tables à chaque étape

ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
```

# Définition de la bordure de 250 m par rapport au contour communal

```{r bordure}
dbExecute(conn, "TRUNCATE TABLE bordure;")

dbExecute(conn, paste0("
  INSERT INTO bordure
  SELECT
      code_insee, nom_com,
      ST_Multi(
          ST_Simplify(
              ST_Difference(
                  ST_Buffer(geometry, 250), ST_Buffer(geometry, -250)
              )
          , 10)
      ) AS geometry
  FROM
      com_", params$num_departement, ";"))
# Création de la bordure de 250 mètres de chaque coté par rapport au contour communal
```


```{r, eval=FALSE}
bordure <- st_read(conn, query = "SELECT * FROM bordure;") %>%
  mutate(geometry = st_cast(geometry, "MULTIPOLYGON"))

commune <- st_read(conn, query = paste0("SELECT * FROM com_", params$num_departement, ";"))

parc_avant <- st_read(conn, query = paste0("SELECT * FROM parc_", params$num_departement, "_", params$temps_avant, ";"))
parc_apres <- st_read(conn, query = paste0("SELECT * FROM parc_", params$num_departement, "_", params$temps_apres, ";"))
```

# Focus sur les parcelles ayant conservées leur identifiant 

On s'occupe d'abord des parcelles les plus simples à traiter : celles présentes avec le même identifiant sur les deux périodes de temps. On élimine les parcelles en tout point identique (vis à vis de leur polygone). On fait attention de récupèrer des changements de noms qui n'affectent pas leur code communal (par exemple changement de nom, scission de commune, ect). On récupère ces informations pour éviter des erreurs dan l'application shiny (qui utilise le nom de la commune).
Après avoir enlevé les parcelles identiques, il reste toujours des cas qui ne nous intéressent pas et que nous souhaitons éliminer.
ATTENTION : Il arrive parfois qu'il reste trop de parcelles à comparer à cette étape (cas du département 1 période 24-23). Les calculs seront donc stoppés avant de lancer ceux néssaires dans la table modif (tout comme dans la partie traitement automatique). Il est nécessaire de lancer le code à la main à l'intérieur du chunk ou d'augmenter le seuil en début de document. Les calculs dans la partie modif restent encore acceptable mais il est fortement DECONSEILLE de lancer le code avec l'IoU Multi qui peuvent prendre à priori vraiment trop de temps pour pas grand chose.

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r géométrie égale + iou}
dbExecute(conn, "TRUNCATE TABLE identique, modif_apres, modif_avant, modif, disparition_com;")

dbExecute(conn, paste0("
  INSERT INTO identique
  SELECT apres.idu, apres.nom_com, avant.nom_com, apres.code_com
  FROM parc_", params$num_departement, "_", params$temps_apres, " apres
  FULL JOIN parc_", params$num_departement, "_", params$temps_avant, " avant 
    ON avant.idu = apres.idu
  WHERE EXISTS (
      SELECT 1
      FROM parc_", params$num_departement, "_", params$temps_avant, " avant
      WHERE apres.idu = avant.idu 
          AND safe_st_equals(
              ST_SnapToGrid(apres.geometry, 0.0001), 
              ST_SnapToGrid(avant.geometry, 0.0001)
      )
  );"))
# On récupèrer les parcelles identiques pour lesquelles on a arrondi au préalable à 
# 10^-4 les cordonnées de la géomètrie (vraiment utile parfois). Toutefois, lors
# de l'arrondissage, certains polygones peuvent s'auto-intersecter ce qui génére une erreur.
# Si ce cas la arrive, la parcelle n'est pas considéré comme identique.

dbExecute(conn, paste0(" 
  INSERT INTO disparition_com
  SELECT DISTINCT
      nom_com_apres,
      code_com,
      nom_com_avant,
      code_com
  FROM identique 
  WHERE nom_com_apres != nom_com_avant;"))
# Récupère les noms des parcelles et code si des noms de communes ne sont plus présentes
# (changement de nom, ect)

nb_parcelles <- dbGetQuery(conn, paste0("
    SELECT 
      (SELECT COUNT(*) FROM parc_", params$num_departement, "_", params$temps_apres, ") - 
      (SELECT COUNT(*) FROM identique) AS parcelles_non_identique"))
# Estimation du nombre de parcelles restantes à traiter ici
# (tient compte du nombre de parcelles ajoutés/supprimées mais est négligeable)

if (nb_parcelles$parcelles_non_identique > nb_parcelles_seuil) {
  stop(paste0("Le nombre de parcelles a traité est trop volumineux : ", nb_parcelles$parcelles_non_identique, " (contre un seuil de ", nb_parcelles_seuil, ")
       Augmenté le seuil correspondant au nombre de parcelles maximum possibles à traiter !"))
}
# Arrète le chunk si le seuil est dépassé
# Le reste est à lancer manuellement ou en changeant le seuil si on le souhaite

dbExecute(conn, paste0("
  INSERT INTO modif_avant (idu, nom_com, code_com, com_abs, contenance, geometry)
  SELECT avant.idu, avant.nom_com, avant.code_com, avant.com_abs, 
      avant.contenance, avant.geometry AS geometry
  FROM parc_", params$num_departement, "_", params$temps_avant, " avant
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE avant.idu = identique.idu
  ) AND NOT EXISTS (
      SELECT 1
      FROM supp
      WHERE avant.idu = supp.idu
  );"))
# Parcelles à T-1 non supprimées ni une parcelle présente à T et T-1 'identique'

dbExecute(conn, paste0("
  INSERT INTO modif_apres (idu, nom_com, code_com, com_abs, contenance, geometry)
  SELECT apres.idu, apres.nom_com, apres.code_com, apres.com_abs, 
      apres.contenance, apres.geometry
  FROM parc_", params$num_departement, "_", params$temps_apres, " apres
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE apres.idu = identique.idu
  ) AND NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE apres.idu = ajout.idu
  );"))
# Parcelles à T non ajoutée ni une parcelle présente à T et T-1 'identique'

dbExecute(conn, "
  INSERT INTO modif
  SELECT
      COALESCE(avant.idu, apres.idu) AS idu,
      avant.geometry AS geometry_avant,
      apres.geometry AS geometry_apres,
      calcul_iou(apres.geometry, avant.geometry) AS iou
  FROM
      modif_avant avant
  FULL JOIN
      modif_apres apres ON avant.idu = apres.idu;")
# On fait une jointure pour faire les calculs qu'une seule fois et les récupére
# après dans les deux tables
```


```{r, eval=FALSE}
identique <- st_read(conn, query = "SELECT * FROM identique;")
disparition_com <- st_read(conn, query = "SELECT * FROM disparition_com;")

modif <- st_read(conn, query = "SELECT * FROM modif;")
```


```{r drop modif + Iou ajusté}
dbExecute(conn, "
  DELETE FROM modif
  WHERE iou >= 0.99 OR iou IS NULL;")
# Elimine les parcelles "sans changement manifeste" plus les parcelles sans iou
# = parcelles n'ayant pas de géométrie à T ou T-1

dbExecute(conn, "
  UPDATE modif
  SET iou_ajust = calcul_iou_ajust(m.geometry_apres, m.geometry_avant)
  FROM modif AS m
  WHERE modif.idu = m.idu;")
# On ne calcule pas directement avant pour éviter des calculs intutiles
```


```{r, eval=FALSE}
modif <- st_read(conn, query = "SELECT * FROM modif;")
```

## Reconnaissances des cas de translation, modification de contour et les deux à la fois

```{r translation, contour_apres, contour_translation modif}
dbExecute(conn, "TRUNCATE TABLE translation, contour;")

dbExecute(conn, "
  UPDATE modif_avant
  SET iou = modif.iou,
      iou_ajust = modif.iou_ajust
  FROM modif
  WHERE modif_avant.idu = modif.idu;")

dbExecute(conn, "
  UPDATE modif_apres
  SET iou = modif.iou,
      iou_ajust = modif.iou_ajust
  FROM modif
  WHERE modif_apres.idu = modif.idu;")
# On récupère les résultats des indicateurs dans chacune des tables respectives

dbExecute(conn, "
  DELETE FROM modif_avant
  WHERE idu NOT IN (SELECT idu FROM modif);")

dbExecute(conn, "
  DELETE FROM modif_apres
  WHERE idu NOT IN (SELECT idu FROM modif);")
# On supprime les parcelles supprimées auparavant dans modif

dbExecute(conn, "
  INSERT INTO translation
  SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, 
      idu AS idu_translate, geometry
  FROM modif_apres
  WHERE iou_ajust >= 0.99;")
# Si après translation, une parcelle partage quasiment la même surface, on considètre
# qu'il s'agit d'une translation.
# Ps : on a éliminé les concordances parfaites auparavant pour qu'elles ne soient pas
# considérées à tord comme des translations

dbExecute(conn, "
  INSERT INTO contour
  SELECT idu, nom_com, code_com, com_abs, contenance,
         iou AS iou_multi, idu AS participants_avant,
         idu AS participants_apres, geometry
  FROM modif_avant
  WHERE (iou >= 0.95 OR iou_ajust >= 0.95) AND iou_ajust < 0.99;")
# Si avec translation ou non, la parcelle partage quasiment la même surface,
# il s'agit probablement juste d'une modification de contour

dbExecute(conn, "
  DELETE FROM modif_avant
  WHERE EXISTS (
      SELECT 1
      FROM translation
      WHERE modif_avant.idu = translation.idu
  ) OR EXISTS (
      SELECT 1
      FROM contour
      WHERE modif_avant.idu = contour.idu
  );")

dbExecute(conn, "
  DELETE FROM modif_apres
  WHERE EXISTS (
      SELECT 1
      FROM translation
      WHERE modif_apres.idu = translation.idu
  ) OR EXISTS (
      SELECT 1
      FROM contour
      WHERE modif_apres.idu = contour.idu
  );")
# On supprime les cas assignés
```


```{r, eval=FALSE}
translation <- st_read(conn, query = "SELECT * FROM translation;")
contour <- st_read(conn, query = "SELECT * FROM contour;")

modif_avant <- st_read(conn, query = "SELECT * FROM modif_avant;")
modif_apres <- st_read(conn, query = "SELECT * FROM modif_apres;")
```

## Cas plus compliqués de détection des mêmes cas

```{r contour modif}
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache;")
# A NE PAS UTILISER SI NB DE PARCELLES DEPASSANT LE SEUIL
# NE PEUX PAS ETRE RELANCER DIRECTEMENT (contour utilisé avant)

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi_safe(idu, geometry, 'modif_avant', 'modif_apres')).*
    FROM modif_avant
  )
  UPDATE modif_avant
  SET iou_multi = updated_values.iou_multi,
      participants_avant = updated_values.participants_avant,
      participants_apres = updated_values.participants_apres
  FROM updated_values
  WHERE modif_avant.idu = updated_values.idu")
# Ce code nous permet juste de savoir probablement les parcelles qui sont
# impliquées dans les modification de contours restantes.

dbExecute(conn, "
  INSERT INTO contour
  SELECT idu, nom_com, code_com, com_abs, contenance,
         iou_multi, participants_avant, participants_apres, geometry
  FROM modif_avant;")
# Il n'y a priori pas d'autre cas possibles donc je mets toutes les parcelles restantes
# dans cette catégorie. Toutefois, je laisse les appels au table modif_avant et modif_après
# si jamais le code venait à être changer pour laisser des parcelles avec indétermination de cas

dbExecute(conn, "
  DELETE FROM modif_avant
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM contour
  );")

dbExecute(conn, "
  DELETE FROM modif_apres
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM contour
  );")
```


```{r, eval=FALSE}
contour <- st_read(conn, query = "SELECT * FROM contour;")

modif_avant <- st_read(conn, query = "SELECT * FROM modif_avant;")
modif_apres <- st_read(conn, query = "SELECT * FROM modif_apres;")
```


```{r, eval=FALSE}
# Carte intéractive pour visualiser uniquement la typologie des parcelles
# dont l'identifiant a été conservé
bordure <- st_read(conn, query = "SELECT * FROM bordure;")

parc_avant <- st_read(conn, query = paste0(
  "SELECT * FROM parc_", params$num_departement, "_", params$temps_avant, ";"))

parc_apres <- st_read(conn, query = paste0(
  "SELECT * FROM parc_", params$num_departement, "_", params$temps_apres, ";"))

contour <- st_read(conn, query = "SELECT * FROM contour;")
translation <- st_read(conn, query = "SELECT * FROM translation;")

modif_avant <- st_read(conn, query = "SELECT * FROM modif_avant;")
modif_apres <- st_read(conn, query = "SELECT * FROM modif_apres;")

map <- mapview(bordure, layer.name = "Bordures étendues", col.regions = "#F2F2F2", 
               alpha.regions = 0.5, homebutton = F,
               map.types = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldImagery"))

if (nrow(translation) > 0) {
  map <- map + mapview(translation,
                       layer.name = paste0("Parcelles translatées (état 20",params$temps_apres,")"), 
                       col.regions = "#069F9C",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(parc_avant %>%
              filter(idu %in% translation$idu_translate),
            col.regions = "#069F9C",
            layer.name = paste0("Parcelles translatées (état 20",params$temps_avant,")"), 
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour) > 0) {
  map <- map + mapview(parc_apres %>%
                         filter(idu %in% contour$idu),  
                       layer.name = paste0("Parcelles contours (état 20",params$temps_apres,")"), 
                       col.regions = "#D79700", alpha.regions = 0.5, homebutton = F)  +
    mapview(contour,  
            layer.name = paste0("Parcelles contours (état 20",params$temps_avant,")"),
            col.regions = "#D79700",
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(modif_apres) > 0) {
  map <- map + mapview(modif_apres, 
                       z = c("iou_ajust"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",params$temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(modif_avant) > 0) {
  map <- map + mapview(modif_avant, 
                       z = c("iou_ajust"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",params$temps_avant,")"), 
                       alpha.regions = 0.5, homebutton = F)
}

mapshot(map, url = paste0("parcelles_modifiés_",params$num_departement,"_",params$temps_apres,"-",params$temps_avant,".html"))
```

# Focus des parcelles ayant changé de communes

## Cas des parcelles dans le cas d'une scission de communes

```{r scission commune}
dbExecute(conn, "TRUNCATE TABLE scission_com, chgt_com;")

dbExecute(conn, "
  INSERT INTO scission_com
  WITH avant AS (
      SELECT
          idu, nom_com, code_com,
          SUBSTR(idu, 1, 2) || com_abs || '000' || SUBSTR(idu, 9, 14) AS idu_apres
      FROM
          supp
      WHERE com_abs != '000'
  )
  SELECT 
      ajout.idu, ajout.nom_com, ajout.code_com, ajout.com_abs, ajout.contenance,
         avant.idu, avant.nom_com, avant.code_com, ajout.geometry
  FROM
      ajout
  JOIN avant ON ajout.idu = avant.idu_apres;")
# On tente de reformer l'identifiant 


dbExecute(conn, paste0("
  INSERT INTO scission_com
  WITH avant AS (
      SELECT
          idu, nom_com, code_com,
          SUBSTR(idu, 1, 2) AS prefix_idu,
          SUBSTR(idu, 6, 14) AS suffix_idu
      FROM
          supp
      WHERE com_abs != '000'
  )
  SELECT 
      ajout.idu, ajout.nom_com, ajout.code_com, ajout.com_abs, ajout.contenance,
         avant.idu, avant.nom_com, avant.code_com, ajout.geometry
  FROM
      avant
  JOIN ajout ON ajout.idu LIKE avant.prefix_idu || '___' || avant.suffix_idu
  WHERE avant.nom_com IN (
      SELECT DISTINCT nom_com 
      FROM parc_", params$num_departement, "_", params$temps_apres,
  ");"))

dbExecute(conn, paste0(" 
  INSERT INTO chgt_com
  WITH scission_data AS (
      SELECT
          nom_com_avant, 
          code_com_avant, 
          STRING_AGG(DISTINCT nom_com, ', ') AS participants,
          STRING_AGG(DISTINCT code_com, ', ') AS participants_code_com
      FROM
          scission_com
      GROUP BY 
          nom_com_avant, code_com_avant
  ),
  com_apres AS (
      SELECT DISTINCT
          nom_com, code_com
      FROM 
          parc_", params$num_departement, "_", params$temps_apres,"
  )
  SELECT
      df.nom_com_avant,
      df.code_com_avant,
      CASE 
          WHEN c.nom_com IS NOT NULL THEN 
              'Scission partielle'
          ELSE 
              'Scission totale'
      END AS changement,
      df.participants,
      df.participants_code_com
  FROM
      scission_data df
  LEFT JOIN 
      com_apres c ON c.nom_com = df.nom_com_avant;"))

# Parcelles n'ayant pas été modifiées mise à part le nom de commune
```


```{r parcelle changeant de communes, eval=FALSE}
scission_com <- st_read(conn, query = "SELECT * FROM scission_com;")
chgt_com <- dbGetQuery(conn,  "SELECT * FROM chgt_com;")
```

## Cas des parcelles dans le cas d'une fusion de communes

```{r fusion commune}
dbExecute(conn, "TRUNCATE TABLE fusion_com;")

dbExecute(conn, "
  INSERT INTO fusion_com
  WITH apres AS (
      SELECT
          idu, nom_com, code_com, com_abs, contenance,
          SUBSTR(idu, 1, 2) || com_abs || '000' || SUBSTR(idu, 9, 14) AS idu_avant,
          geometry
      FROM
          ajout
      WHERE com_abs != '000'
  )
  SELECT 
      apres.idu, apres.nom_com, apres.code_com, apres.com_abs, apres.contenance,
         supp.idu, supp.nom_com, supp.code_com, apres.geometry
  FROM
      apres
  JOIN supp ON apres.idu_avant = supp.idu;")

dbExecute(conn, paste0("
  INSERT INTO disparition_com
  SELECT 
      fusion_ajout.nom_com, fusion_ajout.code_com, 
      fusion_ajout.nom_com_avant, fusion_ajout.code_com_avant
  FROM (
      WITH avant AS (
          SELECT
              idu, nom_com, code_com,
              SUBSTR(idu, 1, 2) AS prefix_idu,
              SUBSTR(idu, 6, 14) AS suffix_idu
          FROM
              supp
          WHERE com_abs != '000'
      )
      SELECT 
          ajout.nom_com, ajout.code_com, 
          avant.nom_com AS nom_com_avant, avant.code_com AS code_com_avant
      FROM
          avant
      JOIN 
          ajout ON ajout.idu LIKE avant.prefix_idu || '___' || avant.suffix_idu
      WHERE avant.nom_com NOT IN (
          SELECT DISTINCT nom_com 
          FROM parc_", params$num_departement, "_", params$temps_apres, 
      ")
  ) AS fusion_ajout;"))

dbExecute(conn, paste0("
  INSERT INTO fusion_com
  WITH avant AS (
      SELECT
          idu, nom_com, code_com,
          SUBSTR(idu, 1, 2) AS prefix_idu,
          SUBSTR(idu, 6, 14) AS suffix_idu
      FROM
          supp
      WHERE com_abs != '000'
  )
  SELECT 
      ajout.idu, ajout.nom_com, ajout.code_com, ajout.com_abs, ajout.contenance,
         avant.idu, avant.nom_com, avant.code_com, ajout.geometry
  FROM
      avant
  JOIN ajout ON ajout.idu LIKE avant.prefix_idu || '___' || avant.suffix_idu
  WHERE avant.nom_com NOT IN (
      SELECT DISTINCT nom_com 
      FROM parc_", params$num_departement, "_", params$temps_apres,
  ") AND avant.nom_com IN (
      SELECT nom_com_avant 
      FROM disparition_com GROUP BY nom_com_avant HAVING COUNT(nom_com) = 1);"))

dbExecute(conn, paste0(" 
  INSERT INTO chgt_com
  WITH fusion_data AS (
      SELECT
          nom_com, 
          code_com, 
          STRING_AGG(DISTINCT nom_com_avant, ', ') AS participants,
          STRING_AGG(DISTINCT code_com_avant, ', ') AS participants_code_com
      FROM
          fusion_com
      GROUP BY 
          nom_com, code_com
  ),
  com_avant AS (
      SELECT DISTINCT
          nom_com, code_com
      FROM 
          parc_", params$num_departement, "_", params$temps_avant,"
  )
  SELECT
      f.nom_com,
      f.code_com,
      'Fusion' AS changement,
      CASE 
          WHEN c.nom_com IS NOT NULL THEN 
              STRING_AGG(DISTINCT c.nom_com || ', ' || f.participants, ', ')
          ELSE 
              f.participants 
      END AS participants,
      CASE 
          WHEN c.nom_com IS NOT NULL THEN 
              STRING_AGG(DISTINCT c.code_com || ', ' || f.participants_code_com , ', ')
          ELSE 
              f.participants_code_com 
      END AS participants_code_com
  FROM
      fusion_data f
  LEFT JOIN 
      com_avant c ON f.nom_com = c.nom_com
  GROUP BY
      f.nom_com, c.nom_com, f.code_com, f.participants, f.participants_code_com;"))

dbExecute(conn, paste0(" 
  UPDATE chgt_com
  SET 
      participants = disparition_com.nom_com_avant || ', ' || chgt_com.participants,
      participants_code_com = disparition_com.code_com_avant || ', ' || chgt_com.participants_code_com
  FROM disparition_com
  WHERE chgt_com.nom_com = disparition_com.nom_com;"))

dbExecute(conn, paste0(" 
  INSERT INTO chgt_com
  SELECT nom_com, code_com, 'Changement de nom', nom_com_avant, code_com_avant
  FROM disparition_com
  WHERE nom_com NOT IN (SELECT nom_com FROM chgt_com);"))

# Parcelles n'ayant pas été modifiées mise à part le nom de commune
```


```{r parcelle changeant de communes, eval=FALSE}
fusion_com <- st_read(conn, query = "SELECT * FROM fusion_com;")
disparition_com <- dbGetQuery(conn,  "SELECT * FROM disparition_com;")
chgt_com <- dbGetQuery(conn,  "SELECT * FROM chgt_com;")
```

# Focus parcelles avec changement "majeur" lié à un changement impactant l'identifiant des parcelles

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r ajout/supp geometry egal}
dbExecute(conn, "TRUNCATE TABLE ajout_simp, supp_simp, identique_bis, echange_parc;")

dbExecute(conn, "
  INSERT INTO ajout_simp
  SELECT idu, nom_com, code_com, ST_SnapToGrid(geometry, 0.0001) AS geometry
  FROM ajout;")

dbExecute(conn, "
  INSERT INTO supp_simp
  SELECT idu, nom_com, code_com, ST_SnapToGrid(geometry, 0.0001) AS geometry
  FROM supp;")

dbExecute(conn, "
  INSERT INTO identique_bis
  SELECT supp.idu, supp.nom_com, supp.code_com, 
      ajout.idu, ajout.nom_com, ajout.code_com
  FROM ajout_simp ajout
   JOIN supp_simp  supp
    ON ST_Equals(ajout.geometry, supp.geometry)
      WHERE ST_IsValid(ajout.geometry) 
          AND ST_IsValid(supp.geometry);")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH decomposed_participants AS (
      SELECT 
          unnest(regexp_split_to_array(participants, ',\\s*')) AS participant_idu
      FROM chgt_com
      WHERE changement != 'Changement de nom'
  )
  SELECT * FROM identique_bis 
  WHERE nom_com_avant NOT IN (SELECT participant_idu FROM decomposed_participants)
  AND nom_com_apres NOT IN (SELECT participant_idu FROM decomposed_participants)
  AND (nom_com_avant != nom_com_apres OR code_com_avant != code_com_apres);"))

# Parcelles ajoutées n'ayant pas été modifiées
dbExecute(conn, "
  DELETE FROM ajout
  WHERE EXISTS (
      SELECT 1
      FROM identique_bis ident
      WHERE ajout.idu = ident.idu_apres
  );")

# Parcelles supprimées n'ayant pas été modifiées
dbExecute(conn, "
  DELETE FROM supp
  WHERE EXISTS (
      SELECT 1
      FROM identique_bis ident
      WHERE supp.idu = ident.idu_avant
  );")
```

```{r fusion/subdivision, eval=FALSE}
identique_bis <- st_read(conn, query = "SELECT * FROM identique_bis;")
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
```

## Reconnaissances des cas de fusion (peu fréquent) ou subdivision (plus courant)

```{r ajout/supp iou -> fusion/subdivision}
dbExecute(conn, "TRUNCATE TABLE redecoupage, fusion_ajout;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_intersec(geometry, 'ajout')).*
    FROM supp
  )
  UPDATE supp
  SET iou = updated_values.iou,
      participants = updated_values.participants
  FROM updated_values
  WHERE supp.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO redecoupage
  SELECT idu, nom_com, code_com, com_abs, contenance, iou, 
      idu, participants, geometry
  FROM supp
  WHERE iou >= 0.99 AND LENGTH(participants) != 14;")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH decomposed_participants AS (
    SELECT 
        unnest(regexp_split_to_array(participants, ',\\s*')) AS participant_idu
    FROM chgt_com
    WHERE changement != 'Changement de nom'
  )
  SELECT supp.idu, supp.nom_com, supp.code_com, participants, 
      apres.nom_com, SUBSTRING(participants FROM 3 FOR 3) 
  FROM supp
  JOIN parc_", params$num_departement, "_", params$temps_avant, " apres
  ON apres.idu = supp.participants
  WHERE iou >= 0.99 AND LENGTH(participants) = 14
  AND SUBSTRING(participants FROM 3 FOR 3) <> supp.code_com
  AND supp.nom_com NOT IN (SELECT participant_idu FROM decomposed_participants)
  AND apres.nom_com NOT IN (SELECT participant_idu FROM decomposed_participants);"))

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants, ',\\s*')) 
      FROM supp WHERE iou >= 0.99
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE iou >= 0.99;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_intersec(geometry, 'supp')).*
    FROM ajout
  )
  UPDATE ajout
  SET iou = updated_values.iou,
      participants = updated_values.participants
  FROM updated_values
  WHERE ajout.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO fusion_ajout
  SELECT DISTINCT
      unnest(string_to_array(participants, ', ')), 
      iou,
      participants,
      idu,
      nom_com,
      code_com
  FROM
      ajout
  WHERE iou >= 0.99;")

dbExecute(conn, "
  INSERT INTO redecoupage
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, fa.iou, 
      fa.participants_avant, fa.participants_apres, supp.geometry
  FROM supp
  LEFT JOIN fusion_ajout fa ON fa.idu = supp.idu
  WHERE fa.iou >= 0.99 AND LENGTH(fa.participants_avant) != 14;")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH decomposed_participants AS (
    SELECT 
        unnest(regexp_split_to_array(participants, ',\\s*')) AS participant_idu
    FROM chgt_com
    WHERE changement != 'Changement de nom'
  )
  SELECT fa.idu, supp.nom_com, supp.code_com, fa.participants_apres, 
      fa.nom_com_apres, fa.code_com_apres
  FROM supp
  JOIN fusion_ajout fa ON fa.idu = supp.idu
  WHERE LENGTH(fa.participants_avant) = 14
  AND SUBSTRING(fa.participants_avant FROM 3 FOR 3) <> fa.code_com_apres
  AND supp.nom_com NOT IN (SELECT participant_idu FROM decomposed_participants)
  AND fa.nom_com_apres NOT IN (SELECT participant_idu FROM decomposed_participants);"))

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants, ',\\s*')) 
      FROM ajout WHERE iou >= 0.99
  );")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE iou >= 0.99;")
```


```{r fusion/subdivision, eval=FALSE}
fusion_ajout <- dbGetQuery(conn, "SELECT * FROM fusion_ajout;")
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
redecoupage <- st_read(conn, query = "SELECT * FROM redecoupage;")
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation, modification de contour avec translation

```{r ajout/supp iou_ajust -> translation, contour + translation}
dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_intersec_best_translate(geometry, 'supp')).*
    FROM ajout
  )
  UPDATE ajout
  SET iou_ajust = updated_values.iou_ajust,
      idu_translate = updated_values.idu_translate
  FROM updated_values
  WHERE ajout.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO translation
  SELECT idu, nom_com, code_com, com_abs, contenance, iou_ajust, 
      idu_translate, geometry
  FROM ajout
  WHERE iou_ajust >= 0.99;")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE EXISTS (
      SELECT 1
      FROM translation
      WHERE ajout.idu = translation.idu
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE EXISTS (
      SELECT 1
      FROM translation
      WHERE supp.idu = translation.idu_translate
  );")
```


```{r contour translation ou translation seule, eval=FALSE}
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
translation <- st_read(conn, query = "SELECT * FROM translation;")
```

## Reconnaissances des cas de multi-subdivision (ex : 2 -> 3) ou modification de contours

```{r ajout/supp iou_multi -> multi-subdivision et contours}
dbExecute(conn, "TRUNCATE TABLE max_iou, multi_rapide;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi_rapide(geometry, 'supp', 'ajout')).*
    FROM supp
  )
  UPDATE supp
  SET iou_multi = updated_values.iou_multi,
      participants_avant = updated_values.participants_avant,
      participants_apres = updated_values.participants_apres
  FROM updated_values
  WHERE supp.idu = updated_values.idu")


dbExecute(conn, "
  INSERT INTO max_iou
  SELECT idu, MAX(iou_multi) AS max_iou
  FROM (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) AS idu, 
          iou_multi
      FROM supp
      WHERE iou_multi >= 0.99
  ) subquery
  GROUP BY idu;")

dbExecute(conn, "
  INSERT INTO multi_rapide
  SELECT DISTINCT ON (sub.idu) sub.idu, sub.iou_multi, 
      sub.participants_avant, sub.participants_apres
  FROM (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) AS idu, 
          iou_multi, participants_avant, participants_apres
      FROM supp
      WHERE iou_multi >= 0.99
  ) sub
  JOIN max_iou mi
  ON sub.idu = mi.idu AND sub.iou_multi = mi.max_iou
  ORDER BY sub.idu, sub.iou_multi DESC;")

# Attention peut etre bidon
dbExecute(conn, "
  WITH decomposed AS (
      SELECT
          idu,
          unnest(regexp_split_to_array(participants_avant, ',\\s*')) AS participant_id
      FROM multi_rapide
  ),
  participant_groups AS (
      SELECT
          idu,
          array_agg(DISTINCT participant_id ORDER BY participant_id) AS participants_list
      FROM decomposed
      GROUP BY idu
  ),
  conflicting AS (
      SELECT DISTINCT t2.idu
      FROM participant_groups t1
      JOIN participant_groups t2
      ON t1.idu <> t2.idu
      AND t1.idu = ANY(t2.participants_list)
      WHERE t1.participants_list <> t2.participants_list
  )
  DELETE FROM multi_rapide
  WHERE idu  IN (SELECT idu FROM conflicting);
")

dbExecute(conn, "
  INSERT INTO redecoupage
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, 
      mtr.iou_multi, mtr.participants_avant, mtr.participants_apres, supp.geometry
  FROM multi_rapide mtr
  LEFT JOIN supp ON mtr.idu = supp.idu 
  WHERE LENGTH(mtr.participants_apres) != LENGTH(mtr.participants_avant);")

dbExecute(conn, "
  INSERT INTO contour
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, 
      mtr.iou_multi, mtr.participants_avant, mtr.participants_apres, supp.geometry
  FROM multi_rapide mtr
  LEFT JOIN supp ON mtr.idu = supp.idu 
  WHERE LENGTH(mtr.participants_apres) = LENGTH(mtr.participants_avant);")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM multi_rapide
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM multi_rapide
  );")
```


```{r multisubdiv sql, eval=FALSE}
multi_rapide <-  dbGetQuery(conn, "SELECT * FROM multi_rapide;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
redecoupage <- st_read(conn, query = "SELECT * FROM redecoupage;")
contour <- st_read(conn, query = "SELECT * FROM contour;")
```


```{r ajout/supp iou_multi -> multi-subdivision et contours}
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache, contour_redecoupage;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi(idu, geometry, 'supp', 'ajout')).*
    FROM supp
  )
  UPDATE supp
  SET iou_multi = updated_values.iou_multi,
      participants_avant = updated_values.participants_avant,
      participants_apres = updated_values.participants_apres
  FROM updated_values
  WHERE supp.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO redecoupage
  SELECT idu, nom_com, code_com, com_abs, contenance, iou_multi, 
      participants_avant, participants_apres, geometry
  FROM supp
  WHERE iou_multi >= 0.99 
      AND LENGTH(participants_apres) != LENGTH(participants_avant);")

dbExecute(conn, "
  INSERT INTO contour_redecoupage
  SELECT idu, nom_com, code_com, com_abs, contenance, iou_multi, 
      participants_avant, participants_apres, geometry
  FROM supp
  WHERE (iou_multi >= 0.95 
      AND LENGTH(participants_apres) != LENGTH(participants_avant) 
      AND iou_multi < 0.99
  );")

dbExecute(conn, "
  INSERT INTO contour
  SELECT idu, nom_com, code_com, com_abs, contenance, iou_multi, 
      participants_avant, participants_apres, geometry
  FROM supp
  WHERE iou_multi >= 0.95 
      AND LENGTH(participants_apres) = LENGTH(participants_avant);")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM redecoupage
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM contour
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM contour_redecoupage
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM redecoupage
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM contour
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM contour_redecoupage
  );")
```


```{r multisubdiv sql, eval=FALSE}
supp <- st_read(conn, query = "SELECT * FROM supp;")
redecoupage <- st_read(conn, query = "SELECT * FROM redecoupage;")
contour_redecoupage <- st_read(conn, query = "SELECT * FROM contour_redecoupage;")
contour <- st_read(conn, query = "SELECT * FROM contour;")
```

## Reconnaissances des cas de modification de contours plus compliquée

## Cas rapide translation transformation

```{r rapide}
dbExecute(conn, "TRUNCATE TABLE max_iou, multi_rapide;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi_translate_rapide(geometry, 'supp', 'ajout')).*
    FROM supp
  )
  UPDATE supp
  SET iou_multi_translate = updated_values.iou_multi_translate,
      participants_avant_translate = updated_values.participants_avant_translate,
      participants_apres_translate = updated_values.participants_apres_translate
  FROM updated_values
  WHERE supp.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO max_iou
  SELECT idu, MAX(iou_multi_translate) AS max_iou
  FROM (
      SELECT unnest(regexp_split_to_array(participants_avant_translate, ',\\s*')) AS idu, 
          iou_multi_translate
      FROM supp
      WHERE iou_multi_translate >= 0.95
  ) subquery
  GROUP BY idu;")

dbExecute(conn, "
  INSERT INTO multi_rapide
  SELECT DISTINCT ON (sub.idu) sub.idu, sub.iou_multi_translate, 
      sub.participants_avant_translate, sub.participants_apres_translate
  FROM (
      SELECT unnest(regexp_split_to_array(participants_avant_translate, ',\\s*')) AS idu, 
          iou_multi_translate, participants_avant_translate, participants_apres_translate
      FROM supp
      WHERE iou_multi_translate >= 0.95
  ) sub
  JOIN max_iou mi
  ON sub.idu = mi.idu AND sub.iou_multi_translate = mi.max_iou
  ORDER BY sub.idu, sub.iou_multi_translate DESC;")

dbExecute(conn, "
  WITH decomposed AS (
      SELECT
          idu,
          unnest(regexp_split_to_array(participants_avant, ',\\s*')) AS participant_id
      FROM multi_rapide
  ),
  participant_groups AS (
      SELECT
          idu,
          array_agg(DISTINCT participant_id ORDER BY participant_id) AS participants_list
      FROM decomposed
      GROUP BY idu
  ),
  conflicting AS (
      SELECT DISTINCT t2.idu
      FROM participant_groups t1
      JOIN participant_groups t2
      ON t1.idu <> t2.idu
      AND t1.idu = ANY(t2.participants_list)
      WHERE t1.participants_list <> t2.participants_list
  )
  DELETE FROM multi_rapide
  WHERE idu  IN (SELECT idu FROM conflicting);
")

dbExecute(conn, "
  INSERT INTO contour_redecoupage
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, 
      supp.contenance, mtr.iou_multi, 
      mtr.participants_avant, mtr.participants_apres, 
      supp.geometry
  FROM multi_rapide mtr
  LEFT JOIN supp ON mtr.idu = supp.idu;")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM multi_rapide
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM multi_rapide
  );")
```


```{r contour_redecoupagen_rapide, eval=FALSE}
contour_redecoupage <- st_read(conn, query = "SELECT * FROM contour_redecoupage;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation avec modification de contour et avec fusion

```{r ajout/supp iou_ajust -> contour_fusion_translation}
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache;")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi_translate(idu, geometry, 'supp', 'ajout')).*
    FROM supp
  )
  UPDATE supp
  SET iou_multi_translate = updated_values.iou_multi_translate,
      participants_avant_translate = updated_values.participants_avant_translate,
      participants_apres_translate = updated_values.participants_apres_translate
  FROM updated_values
  WHERE supp.idu = updated_values.idu")

dbExecute(conn, "
  INSERT INTO contour_redecoupage
  SELECT idu, nom_com, code_com, com_abs, contenance, iou_multi_translate, 
      participants_avant_translate, participants_apres_translate, geometry
  FROM supp
  WHERE iou_multi_translate >= 0.95;")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM contour_redecoupage
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM contour_redecoupage
  );")
```


```{r contour_fusion_translation, eval=FALSE}
contour_redecoupage <- st_read(conn, query = "SELECT * FROM contour_redecoupage;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
```

# Ajout d'un iou_multi pour ajout

```{r}
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache, multi_ajout;")

dbExecute(conn, "
  INSERT INTO multi_ajout
  WITH calc_results AS (
      SELECT
          idu,
          (calcul_iou_multi(idu, geometry, 'ajout', 'supp')).*
      FROM
          ajout
  )
  SELECT DISTINCT
      unnest(string_to_array(participants_apres, ', ')) AS idu, 
      iou_multi,
      participants_apres,
      participants_avant
  FROM
      calc_results
  WHERE iou_multi >= 0.95;")

dbExecute(conn, "
  INSERT INTO redecoupage
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, 
      ma.iou_multi, ma.participants_avant, ma.participants_apres, supp.geometry
  FROM supp
  LEFT JOIN multi_ajout ma ON ma.idu = supp.idu
  WHERE ma.iou_multi >= 0.99 
      AND LENGTH(ma.participants_apres) != LENGTH(ma.participants_avant);")

dbExecute(conn, "
  INSERT INTO contour
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, 
      ma.iou_multi, ma.participants_avant, ma.participants_apres, supp.geometry
  FROM supp
  LEFT JOIN multi_ajout ma ON ma.idu = supp.idu
  WHERE ma.iou_multi >= 0.95 
      AND LENGTH(ma.participants_apres) = LENGTH(ma.participants_avant);")

dbExecute(conn, "
  INSERT INTO contour_redecoupage
  SELECT supp.idu, supp.nom_com, supp.code_com, supp.com_abs, supp.contenance, 
      ma.iou_multi, ma.participants_avant, ma.participants_apres, supp.geometry
  FROM supp
  LEFT JOIN multi_ajout ma ON ma.idu = supp.idu
  WHERE (ma.iou_multi >= 0.95 
      AND LENGTH(ma.participants_apres) != LENGTH(ma.participants_avant) 
      AND ma.iou_multi < 0.99);")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM redecoupage
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM contour
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) 
      FROM contour_redecoupage
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM redecoupage
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*'))
      FROM contour
  ) OR idu IN (
      SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) 
      FROM contour_redecoupage
  );")
```


```{r contour_fusion_translation, eval=FALSE}
redecoupage <- st_read(conn, query = "SELECT * FROM redecoupage;")
contour_redecoupage <- st_read(conn, query = "SELECT * FROM contour_redecoupage;")
contour <- st_read(conn, query = "SELECT * FROM contour;")
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
```

## Recalcul de l'IoU pour détecter les parcelles maintenant isolées -> Véritable ajout ou suppression

```{r le reste}
dbExecute(conn, "TRUNCATE TABLE vrai_ajout, vrai_supp;")

dbExecute(conn, "
  INSERT INTO vrai_ajout
  SELECT idu, nom_com, code_com, com_abs, contenance, geometry
  FROM ajout
  WHERE NOT EXISTS (
      SELECT 1 FROM supp WHERE ST_DWithin(ajout.geometry, supp.geometry, 50) 
  );")

dbExecute(conn, "
  INSERT INTO vrai_supp
  SELECT idu, nom_com, code_com, com_abs, contenance, geometry
  FROM supp
  WHERE NOT EXISTS (
      SELECT 1 FROM ajout WHERE ST_DWithin(ajout.geometry, supp.geometry, 50) 
  );")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE EXISTS (
      SELECT 1
      FROM vrai_ajout
      WHERE ajout.idu = vrai_ajout.idu
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE EXISTS (
      SELECT 1
      FROM vrai_supp
      WHERE supp.idu = vrai_supp.idu
  );")
```


```{r le reste, eval=FALSE}
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")

vrai_ajout <- st_read(conn, query = "SELECT * FROM vrai_ajout;")
vrai_supp <- st_read(conn, query = "SELECT * FROM vrai_supp;")

# 132078330A0082 cas d'une parcelle disparu en 2024 mais pas affiché comme vrai supp -> multipolygon empty
# 13041000AM0018 parcelle participant a une multi subdiv mais qui a l'air iou parfait
```


```{r echanges parcelles}
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache, echange_parc_possible;")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH decomposed_participants AS (
    SELECT 
        unnest(regexp_split_to_array(participants, ',\\s*')) AS participant_idu
    FROM chgt_com
    WHERE changement != 'Changement de nom'
  )
  SELECT idu_translate, avant.nom_com, SUBSTRING(idu_translate FROM 3 FOR 3), 
      tr.idu, tr.nom_com, tr.code_com
  FROM translation tr
  JOIN parc_", params$num_departement, "_", params$temps_avant, " avant
  ON avant.idu = tr.idu_translate
  WHERE SUBSTRING(idu_translate FROM 3 FOR 3) <> tr.code_com
  AND avant.nom_com NOT IN (SELECT participant_idu FROM decomposed_participants)
  AND tr.nom_com NOT IN (SELECT participant_idu FROM decomposed_participants);"))

dbExecute(conn, "
  DELETE FROM translation
  WHERE EXISTS (
      SELECT 1
      FROM echange_parc
      WHERE translation.idu = echange_parc.idu_apres
  );")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH decomposed_participants AS (
    SELECT 
        unnest(regexp_split_to_array(participants, ',\\s*')) AS participant_idu
    FROM chgt_com
    WHERE changement != 'Changement de nom'
  ),
  echange AS (
      SELECT DISTINCT 
          (echange_parcelles('participants_apres', 'redecoupage')).*
  )
  SELECT DISTINCT ON (red.participants_avant) red.participants_avant, ech.nom_com_avant, ech.code_com_avant, 
      red.participants_apres, apres.nom_com, ech.code_com_apres
  FROM echange ech
  JOIN redecoupage red ON red.idu = ech.idu_avant
  JOIN parc_", params$num_departement, "_", params$temps_apres, " apres 
  ON apres.code_com = ech.code_com_apres
  WHERE ech.nom_com_avant NOT IN (SELECT participant_idu FROM decomposed_participants)
  AND apres.nom_com NOT IN (SELECT participant_idu FROM decomposed_participants);")) 

dbExecute(conn, "
  DELETE FROM redecoupage
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(idu_avant, ',\\s*')) 
      FROM echange_parc
  );")

dbExecute(conn, paste0("
  INSERT INTO echange_parc
  WITH decomposed_participants AS (
    SELECT 
        unnest(regexp_split_to_array(participants, ',\\s*')) AS participant_idu
    FROM chgt_com
    WHERE changement != 'Changement de nom'
  ),
  echange AS (
      SELECT DISTINCT 
          (echange_parcelles('participants_apres', 'contour_redecoupage')).*
  )
  SELECT DISTINCT ON (con.participants_avant) con.participants_avant, ech.nom_com_avant, ech.code_com_avant, 
      con.participants_apres, apres.nom_com, ech.code_com_apres
  FROM echange ech
  JOIN contour_redecoupage con ON con.idu = ech.idu_avant
  JOIN parc_", params$num_departement, "_", params$temps_avant, " apres 
  ON apres.code_com = ech.code_com_apres
  WHERE ech.nom_com_avant NOT IN (SELECT participant_idu FROM decomposed_participants)
  AND apres.nom_com NOT IN (SELECT participant_idu FROM decomposed_participants);"))

dbExecute(conn, "
  DELETE FROM contour_redecoupage
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(idu_avant, ',\\s*')) 
      FROM echange_parc
  );")

dbExecute(conn, "
  WITH updated_values AS (
    SELECT idu,
           (calcul_iou_multi(idu, geometry, 'supp', 'ajout', 0)).*
    FROM supp
  )
  UPDATE supp
  SET iou_multi = updated_values.iou_multi,
      participants_avant = updated_values.participants_avant,
      participants_apres = updated_values.participants_apres
  FROM updated_values
  WHERE supp.idu = updated_values.idu")

dbExecute(conn, paste0("
  INSERT INTO echange_parc_possible
  WITH decomposed_participants AS (
    SELECT 
        unnest(regexp_split_to_array(participants, ',\\s*')) AS participant_idu
    FROM chgt_com
    WHERE changement != 'Changement de nom'
  ),
  echange AS (
      SELECT DISTINCT 
          (echange_parcelles('participants_apres', 'supp')).*
  )
  SELECT DISTINCT ON (supp.participants_avant) supp.participants_avant, ech.nom_com_avant, ech.code_com_avant, 
      supp.participants_apres, apres.nom_com, ech.code_com_apres
  FROM echange ech
  JOIN supp ON supp.idu = ech.idu_avant
  JOIN parc_", params$num_departement, "_", params$temps_avant, " apres 
  ON apres.code_com = ech.code_com_apres
  WHERE ech.nom_com_avant NOT IN (SELECT participant_idu FROM decomposed_participants)
  AND apres.nom_com NOT IN (SELECT participant_idu FROM decomposed_participants);")) 

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(idu_apres, ',\\s*')) 
      FROM echange_parc_possible
  );")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (
      SELECT unnest(regexp_split_to_array(idu_avant, ',\\s*')) 
      FROM echange_parc_possible
  );")
```

```{r, eval=FALSE}
echange_parc <- dbGetQuery(conn, "SELECT * FROM echange_parc;")
echange_parc_possible <- dbGetQuery(conn, "SELECT * FROM echange_parc_possible;")
```

```{r nettoyage table inutile}
dbExecute(conn, "
  DROP TABLE IF EXISTS multi_calcul_cache, identique, modif, ajout_simp, 
  supp_simp, identique_bis, fusion_ajout, max_iou, disparition_com, multi_rapide, 
  multi_ajout CASCADE
;")
dbListTables(conn)
```


```{r carte reste, eval=FALSE}
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
modif_avant <- st_read(conn, query = "SELECT * FROM modif_avant;")
modif_apres <- st_read(conn, query = "SELECT * FROM modif_apres;")

map <- mapview()

if (nrow(ajout) > 0) {
  map <- map + mapview(ajout,
                       z = c("iou_ajust"), layer.name = paste0("Parcelles restantes (état 20",params$temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(supp) > 0) {
  map <- map + mapview(supp, 
                       z = c("iou_multi"), layer.name = paste0("Parcelles restantes (état 20",params$temps_avant,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(modif_apres) > 0) {
  map <- map + mapview(modif_apres, 
                       z = c("iou_ajust"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",params$temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(modif_avant) > 0) {
  map <- map + mapview(modif_avant, 
                       z = c("iou_ajust"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",params$temps_avant,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
mapshot(map, url = paste0("parcelles_restantes_",params$num_departement,"_",params$temps_apres,"-",params$temps_avant,".html"))
```

# Visualisation finale sur une carte du département

```{r mapview typologie parcelles, eval=FALSE}
bordure <- st_read(conn, query = "SELECT * FROM bordure;")

parc_avant <- st_read(conn, query = paste0("SELECT * FROM parc_", params$num_departement, "_", params$temps_avant, ";"))
parc_apres <- st_read(conn, query = paste0("SELECT * FROM parc_", params$num_departement, "_", params$temps_apres, ";"))

contour <- st_read(conn, query = "SELECT * FROM contour;")
translation <- st_read(conn, query = "SELECT * FROM translation;")
redecoupage <- st_read(conn, query = "SELECT * FROM redecoupage;")
contour_redecoupage <- st_read(conn, query = "SELECT * FROM contour_redecoupage;")
vrai_ajout <- st_read(conn, query = "SELECT * FROM vrai_ajout;")
vrai_supp <- st_read(conn, query = "SELECT * FROM vrai_supp;")

scission_com <- st_read(conn, query = "SELECT * FROM scission_com;")
fusion_com <- st_read(conn, query = "SELECT * FROM fusion_com;")

ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
modif_avant <- st_read(conn, query = "SELECT * FROM modif_avant;")
modif_apres <- st_read(conn, query = "SELECT * FROM modif_apres;")

map <- mapview(bordure, 
               layer.name = "Bordures étendues", col.regions = "#F2F2F2", 
               alpha.regions = 0.7, homebutton = F,
               map.types = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldImagery"))

if (nrow(translation) > 0) {
  map <- map + mapview(translation,
                       layer.name = paste0("Parcelles translatées (état 20",params$temps_apres,")"), 
                       col.regions = "#069F9C",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(parc_avant %>%
              filter(idu %in% translation$idu_translate),
            col.regions = "#069F9C",
            layer.name = paste0("Parcelles translatées (état 20",params$temps_avant,")"), 
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour) > 0) {
  map <- map + mapview(parc_apres %>%
                         filter(idu %in% unlist(str_split(contour$participants_apres, ",\\s*"))),  
                       layer.name = paste0("Parcelles contours (état 20",params$temps_apres,")"), 
                       col.regions = "#D79700", alpha.regions = 0.5, homebutton = F)  +
    mapview(contour,  
            layer.name = paste0("Parcelles contours (état 20",params$temps_avant,")"),
            col.regions = "#D79700",
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(redecoupage) > 0) {
  map <- map + mapview(parc_apres %>%
                         filter(idu %in% unlist(str_split(redecoupage$participants_apres, ",\\s*"))),
                       layer.name = paste0("Parcelles redécoupées (état 20",params$temps_apres,")"),
                       col.regions = "#AE48C0",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(redecoupage,  
            layer.name = paste0("Parcelles redécoupées (état 20",params$temps_avant,")"), 
            col.regions = "#AE48C0", alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(contour_redecoupage) > 0) {
  map <- map + mapview(parc_apres %>%
                         filter(idu %in% unlist(str_split(contour_redecoupage$participants_apres, ",\\s*"))),  
                       layer.name = paste0("Parcelles redecoupage + contours (état 20",params$temps_apres,")"),
                       col.regions = "#FFB9BB",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(contour_redecoupage,
            layer.name = paste0("Parcelles redecoupage + contours (état 20",params$temps_avant,")"), 
            col.regions = "#FFB9BB", alpha.regions = 0.5, homebutton = F)
}
if (nrow(scission_com) > 0) {
  map <- map + mapview(scission_com,  
                       layer.name = paste0("Parcelles scission de communes (état 20",params$temps_apres,")"), 
                       col.regions = "white",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(parc_avant %>%
              filter(idu %in% scission_com$idu_avant),  
            layer.name = paste0("Parcelles scission de communes (état 20",params$temps_avant,")"), 
            col.regions = "white", alpha.regions = 0.5, homebutton = F)
}
if (nrow(fusion_com) > 0) {
  map <- map + mapview(fusion_com,  
                       layer.name = paste0("Parcelles fusion de communes (état 20",params$temps_apres,")"), 
                       col.regions = "white",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(parc_avant %>%
              filter(idu %in% fusion_com$idu_avant),  
            layer.name = paste0("Parcelles fusion de communes (état 20",params$temps_avant,")"), 
            col.regions = "white", alpha.regions = 0.5, homebutton = F)
}
if (nrow(vrai_ajout) > 0) {
  map <- map + mapview(vrai_ajout, 
                       layer.name = "Parcelles véritablement ajoutées", 
                       col.regions = "#26A44B", alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(vrai_supp) > 0) {
  map <- map + mapview(vrai_supp,
                       layer.name = "Parcelles véritablement supprimées",
                       col.regions = "#E91422", alpha.regions = 0.5, homebutton = F) 
}
if (nrow(ajout) > 0) {
  map <- map + mapview(ajout,
                       z = c("iou_ajust"), layer.name = paste0("Parcelles restantes (état 20",params$temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(supp) > 0) {
  map <- map + mapview(supp, 
                       z = c("iou_multi"), layer.name = paste0("Parcelles restantes (état 20",params$temps_avant,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(modif_apres) > 0) {
  map <- map + mapview(modif_apres, 
                       z = c("iou_ajust"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",params$temps_apres,")"), 
                       alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(modif_avant) > 0) {
  map <- map + mapview(modif_avant, 
                       z = c("iou_ajust"), 
                       layer.name = paste0("Parcelles modifiées restantes (état 20",params$temps_avant,")"), 
                       alpha.regions = 0.5, homebutton = F)
}
mapshot(map, url = paste0("parcelles_",params$num_departement,"_",params$temps_apres,"-",params$temps_avant,".html"))
```
