---
title: "Vendée_sql 2024-2023"
output: html_document
date: "2024-06-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

# Import package + fonction utilisés après

```{r package message=FALSE, warning=FALSE}
library(sf)
library(dplyr)
library(lubridate)
library(mapview)
library(DBI)
library(ggplot2)
library(purrr)
library(webshot)
library(pracma)
library(RColorBrewer)
library(tidyr)
library(stringr)
# webshot::install_phantomjs()
source(file = "connexion_db.R")
conn <- connecter()
DBI::dbListTables(conn)
```

```{r voir les index}
dbGetQuery(conn, " SELECT 
    tablename, 
    indexname, 
    indexdef 
FROM 
    pg_indexes 
WHERE 
    schemaname LIKE 'pg_temp_%' 
    OR schemaname = 'public';
           ")
```

```{r voir les tables temporaires}
dbGetQuery(conn, " SELECT 
    schemaname AS schema_name,
    tablename AS table_name
FROM 
    pg_tables
WHERE 
    schemaname LIKE 'pg_temp_%'
ORDER BY 
    schemaname, tablename;
           ")
```

```{r supprimer toutes les tables temporaires}
query_list <- "
SELECT 
    tablename
FROM 
    pg_tables
WHERE 
    schemaname LIKE 'pg_temp_%';
"

# Exécution de la requête pour obtenir les noms des tables temporaires
tables_temporaires <- dbGetQuery(conn, query_list)

# Générer les commandes de suppression
drop_queries <- lapply(tables_temporaires$tablename, function(table) {
    paste("DROP TABLE IF EXISTS", table, "CASCADE;")
})

# Exécution des commandes de suppression
for (query in drop_queries) {
    dbSendQuery(conn, query)
}
```


```{r fonction commun}
creer_bordure_etendue <- function(commune, buffer_distance) {
  buffer_positif <- st_buffer(commune, buffer_distance)
  buffer_negatif <- st_buffer(commune, -buffer_distance)
  suppressWarnings({
    buffer_difference <- st_difference(buffer_positif, buffer_negatif)
  })
  return(buffer_difference)
}

calcul_iou <- function(geometry_avant, geometry_apres) {
  if (!st_is_empty(geometry_avant) & !st_is_empty(geometry_apres)) {
    
    intersection <- st_intersection(geometry_avant, geometry_apres)
    
    if (length(intersection) == 0) {
      return(0) # Si les géométries ne s'intersectent pas du tout, IoU = 0
    }
    
    aire_intersection <- st_area(intersection)
    union <- st_union(geometry_avant, geometry_apres)
    aire_union <- st_area(union)
    
    return(as.numeric(aire_intersection / aire_union))
  } else {
    return(NA)
  }
}

calcul_iou_ajust <- function(geometry_avant, geometry_apres) {
  if (!st_is_empty(geometry_avant) & !st_is_empty(geometry_apres)) {
    # Calculer l'ajustement de la géométrie_avant
    centroid_apres <- st_centroid(geometry_apres)
    centroid_avant <- st_centroid(geometry_avant)
    translation_vector <- st_coordinates(centroid_apres)[1, 1:2] - st_coordinates(centroid_avant)[1, 1:2]
    geometry_avant_ajust <- st_geometry(geometry_avant) + translation_vector
    iou_ajust <- calcul_iou(st_set_crs(geometry_avant_ajust, 2154), geometry_apres)
    
    return(iou_ajust)
  } else {
    return(NA)
  }
}

calcul_iou_intersec <- function(polygon, ajout) {
  
  parcelles_intersectant <- ajout %>%
    st_filter(st_buffer(polygon, -1), .predicate = st_intersects)
  # seuil à choisir
  
  nom_participants <- parcelles_intersectant$idu
  if (isempty(nom_participants)) {
    return(list(iou = NA, participants = NA))
  }
  
  union_parcelles <- st_union(parcelles_intersectant)
  iou <- calcul_iou(union_parcelles, polygon)
  
  list(iou = iou, participants = paste(nom_participants, collapse = ", "))
}

calcul_iou_multi <- function(polygon, supp, ajout) {
  n <- 0
  nom_participants_avant <- NULL
  repeat {
    # Trouver les parcelles dans supp qui intersectent la parcelle actuelle
    parcelles_intersectant_avant <- supp %>%
      st_filter(polygon, .predicate = st_intersects)
    
    # Condition de sortie : on retrouve le même nombre de parcelles
    if (nrow(parcelles_intersectant_avant) == n) break
    
    # Mettre à jour la parcelle en faisant l'union des parcelles trouvées
    polygon <- st_union(parcelles_intersectant_avant)
    nom_participants_avant <- parcelles_intersectant_avant$idu
    n <- nrow(parcelles_intersectant_avant)
  }
  
  iou_intersect <- calcul_iou_intersec(polygon, ajout)
  
  list(iou = iou_intersect$iou, 
       participants_avant = paste(nom_participants_avant, collapse = ", "),
       participants_apres = iou_intersect$participants)
}

calcul_iou_intersec_translate <- function(polygon, ajout) {
  
  parcelles_intersectant <- ajout %>%
    st_filter(st_buffer(polygon, -1), .predicate = st_intersects)
  
  # Récupérer les noms des parcelles intersectants
  nom_participants <- parcelles_intersectant$idu
  if (isempty(nom_participants)) {
    return(list(iou_ajust = NA, idu_translate = NA))
  }
  
  max_iou <- -Inf
  best_idu <- NA
  
  # Boucler sur chaque parcelle intersectant
  for (i in seq_len(nrow(parcelles_intersectant))) {
    parcelle_actuelle <- parcelles_intersectant[i, ]
    
    # Calculer l'IoU entre la parcelle courante et la parcelle initiale
    iou_value <- suppressWarnings({calcul_iou(parcelle_actuelle, polygon)})
    
    # Si l'IoU courant est plus élevé que l'IoU maximum trouvé jusqu'à présent
    if (iou_value > max_iou) {
      max_iou <- iou_value
      best_indice <- i
      best_idu <- parcelle_actuelle$idu
    }
  }
  parcelle <- parcelles_intersectant[best_indice, ]
  iou_ajust <- calcul_iou_ajust(parcelle, polygon)
  
  list(iou_ajust = iou_ajust, idu_translate = parcelle$idu)
}

calcul_iou_multi_translate <- function(polygon, supp, ajout) {
  n <- 0
  nom_participants_avant <- NULL
  repeat {
    # Trouver les parcelles dans supp qui intersectent la parcelle actuelle
    parcelles_intersectant_avant <- supp %>%
      st_filter(polygon, .predicate = st_intersects)
    
    # Condition de sortie : on retrouve le même nombre de parcelles
    if (nrow(parcelles_intersectant_avant) == n) break
    
    # Mettre à jour la parcelle en faisant l'union des parcelles trouvées
    polygon <- st_union(parcelles_intersectant_avant)
    nom_participants_avant <- parcelles_intersectant_avant$idu
    n <- nrow(parcelles_intersectant_avant)
  }
  
  iou_intersect <- calcul_iou_intersec_translate(polygon, ajout)
  
  list(iou = iou_intersect$iou_ajust, 
       participants_avant = paste(nom_participants_avant, collapse = ", "),
       participants_apres = iou_intersect$idu_translate)
}
```

```{r}
dbSendQuery(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou(geometry_avant geometry, geometry_apres geometry)
  RETURNS numeric AS $$
  DECLARE
      intersection geometry;
      aire_intersection numeric;
      geom_union geometry;
      aire_union numeric;
      iou numeric;
  BEGIN
      -- Vérifier si les géométries ne sont pas vides
      IF NOT ST_IsEmpty(geometry_avant) AND NOT ST_IsEmpty(geometry_apres) THEN
          intersection := ST_Intersection(geometry_avant, geometry_apres);
        
          -- Si l'intersection est vide, IoU = 0
          IF ST_IsEmpty(intersection) THEN
              RETURN 0;
          END IF;
        
          aire_intersection := ST_Area(intersection);
          geom_union := ST_Union(geometry_avant, geometry_apres);
          aire_union := ST_Area(geom_union);
        
          -- Calculer l'IoU
          iou := aire_intersection / aire_union;
          RETURN iou;
      ELSE
          RETURN NULL;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
")

dbSendQuery(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_ajust(geometry_avant geometry, geometry_apres geometry)
  RETURNS numeric AS $$
  DECLARE
      centroid_apres geometry;
      centroid_avant geometry;
      translation_vector_x double precision;
      translation_vector_y double precision;
      geometry_avant_ajust geometry;
      iou_ajust numeric;
  BEGIN
      -- Vérifier si les géométries ne sont pas vides
      IF NOT ST_IsEmpty(geometry_avant) AND NOT ST_IsEmpty(geometry_apres) THEN
          centroid_apres := ST_Centroid(geometry_apres);
          centroid_avant := ST_Centroid(geometry_avant);
          translation_vector_x := ST_X(centroid_apres) - ST_X(centroid_avant);
          translation_vector_y := ST_Y(centroid_apres) - ST_Y(centroid_avant);
          
          -- Calculer la géométrie avant ajustée en utilisant ST_Translate
          geometry_avant_ajust := ST_Translate(geometry_avant, translation_vector_x, translation_vector_y);
          
          -- Calculer l'IoU ajusté avec la géométrie avant ajustée
          iou_ajust := calcul_iou(geometry_avant_ajust, geometry_apres);
          
          RETURN iou_ajust;
      ELSE
          RETURN NULL;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
")
```


# Importation des parcelles sur l'ensemble du département et des périodes données


```{r import sql}
parcelle_24 <- st_read(conn, query = "SELECT * FROM parc_85_24;")
parcelle_23 <- st_read(conn, query = "SELECT * FROM parc_85_23;")
commune <- st_read(conn, query = "SELECT * FROM com_85;")

dbSendQuery(conn, "
  CREATE TEMP TABLE ajout_tot AS
  SELECT * 
  FROM parc_85_24
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_85_23 
    WHERE parc_85_24.idu = parc_85_23.idu
  );
")

dbSendQuery(conn, "
  CREATE INDEX idx_ajout_tot_geometry ON ajout_tot USING GIST(geometry);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE supp_tot AS
  SELECT * 
  FROM parc_85_23
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_85_24
    WHERE parc_85_23.idu = parc_85_24.idu
  );
")

dbSendQuery(conn, "
  CREATE INDEX idx_supp_tot_geometry ON supp_tot USING GIST(geometry);
")

ajout_tot <- st_read(conn, query = "
  SELECT * 
  FROM ajout_tot;
")

supp_tot <- st_read(conn, query = "
  SELECT * 
  FROM supp_tot;
")
```


# Définition de la bordure dans laquelle je considère que mes parcelles doivent apartenir entièrement

```{r}
dbSendQuery(conn, "
  CREATE TEMP TABLE bordure AS
  SELECT
      code_insee, nom_com, code_dep,
      ST_Difference(ST_Buffer(geometry, 250), ST_Buffer(geometry, -250)) AS geometry
  FROM
      com_85;
")

dbSendQuery(conn, "
  CREATE INDEX idx_bordure_geometry ON bordure USING GIST(geometry);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE ins_parc_24 AS
  SELECT DISTINCT
      parc_85_24.*
  FROM
      parc_85_24
  JOIN
      bordure
  ON
      ST_WITHIN(parc_85_24.geometry, bordure.geometry);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE ins_parc_23 AS
  SELECT DISTINCT
      parc_85_23.*
  FROM
      parc_85_23
  JOIN
      bordure
  ON
      ST_WITHIN(parc_85_23.geometry, bordure.geometry);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE ajout AS
  SELECT 
      ajout_tot.*
  FROM
      ajout_tot
  JOIN
      bordure
  ON
      ST_WITHIN(ajout_tot.geometry, bordure.geometry)
  ORDER BY ajout_tot.nom_com;
")

dbSendQuery(conn, "
  CREATE INDEX idx_ajout_geometry ON ajout USING GIST(geometry);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE supp AS
  SELECT 
      supp_tot.*
  FROM
      supp_tot
  JOIN
      bordure
  ON
      ST_WITHIN(supp_tot.geometry, bordure.geometry)
  ORDER BY supp_tot.nom_com;
")

dbSendQuery(conn, "
  CREATE INDEX idx_supp_geometry ON supp USING GIST(geometry);
")
```


```{r bordure sql}

bordure <- st_read(conn, query = "
  SELECT 
      *
  FROM
      bordure;
") %>%
  mutate(geometry = st_cast(geometry, "MULTIPOLYGON"))

ins_parc_24 <- st_read(conn, query = "
  SELECT * FROM ins_parc_24;
")

ins_parc_23 <- st_read(conn, query = "
   SELECT * FROM ins_parc_23;
")

ajout <- st_read(conn, query = "
  SELECT * FROM ajout;
")

supp <- st_read(conn, query = "
  SELECT * FROM supp;
")

dbSendQuery(conn, "DROP TABLE IF EXISTS bordure;")
```

# Carte des parcelles appartenant + croisant la bordure

```{r ggplot bordure}
plot <- ggplot() +
  geom_sf(data = commune, aes(fill = "Communes"), color = "black", alpha = 0.5) +  
  geom_sf(data = bordure, aes(fill = "Bordures étendues"), fill = "lightblue", alpha = 0.5, color = "lightblue") +  
  geom_sf(data = ins_parc_24, aes(fill = "Parcelles croisées"), alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", "Parcelles croisées" = "purple")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales (2024) croisant les frontières étendues des communes de Vendée", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 250m de chaque côté de celles définies par l'IGN")

# ggsave("parcelles_croisant_bordures_85.png", plot = plot, width = 12, height = 8, dpi = 300)
plot
```

# Focus sur une commune ayant fusionné avec d'autres communes limitrophes

```{r focus parcelle la tardiere}
map <- mapview(commune %>% 
                 filter(code_insee == "85289"), 
               layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure %>% 
            filter(code_insee == "85289"), 
          layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(parcelle_24 %>% 
            filter(code_com == "289"), 
          layer.name = "Parcelles (état 2024)", col.regions = "purple", alpha.regions = 0.5) +
  mapview(parcelle_23 %>% 
            filter(code_com %in% c("289", "053", "037")), 
          layer.name = "Parcelles (état 2023)", col.regions = "lightgreen", alpha.regions = 0.5)

# mapshot(map, url = "parcelles_tardiere.html")
```

# Focus sur les parcelles dont je peux comparer l'état sur les deux périodes facilement (cad parcelles ayant conservé leur identifiant)

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r modif geometry egal sql}
# Requête SQL pour créer la table temporaire identique
dbSendQuery(conn, "
  CREATE TEMP TABLE identique AS
  SELECT ins_parc_24.*
  FROM ins_parc_24
  WHERE NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE ins_parc_24.idu = ajout.idu
  )
  AND EXISTS (
      SELECT 1
      FROM ins_parc_23 
      WHERE ins_parc_24.idu = ins_parc_23.idu
      AND ST_Equals(ins_parc_24.geometry, ins_parc_23.geometry)
  );
")

dbSendQuery(conn, "
  CREATE TEMP TABLE modif_apres AS
  SELECT ins_parc_24.*
  FROM ins_parc_24
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE ins_parc_24.idu = identique.idu
  )
  AND NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE ins_parc_24.idu = ajout.idu
  )
  ORDER BY ins_parc_24.nom_com;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE modif_avant AS
  SELECT ins_parc_23.*
  FROM ins_parc_23
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE ins_parc_23.idu = identique.idu
  )
  AND NOT EXISTS (
      SELECT 1
      FROM supp
      WHERE ins_parc_23.idu = supp.idu
  )
  ORDER BY ins_parc_23.nom_com;
")


dbSendQuery(conn, "
  CREATE TEMP TABLE modif AS
  SELECT
      apres.idu,
      apres.geometry AS geometry_apres,
      avant.geometry AS geometry_avant,
      calcul_iou(avant.geometry, apres.geometry) AS iou,
      calcul_iou_ajust(avant.geometry, apres.geometry) AS iou_ajust
  FROM
      modif_avant avant
  FULL JOIN
      modif_apres apres ON avant.idu = apres.idu;
")


dbSendQuery(conn, "
  CREATE TEMP TABLE modif_filtrer AS
  SELECT
      *
  FROM
      modif
  WHERE
      iou < 0.99;
")

dbSendQuery(conn, "DROP TABLE IF EXISTS identique;")
```

```{r modif iou et iou_ajust}

modif <- st_read(conn, query = "
   SELECT * FROM modif_filtrer;
")
# Elimine les parcelles "sans changement manifeste" plus les parcelles sans iou = parcelles n'étant plus entièrement dans la bordure lors d'un changement d'une année sur l'autre

quantiles <- quantile(modif$iou_ajust, probs = c(0.01, 0.03, 0.05, 0.1), na.rm = TRUE)
```

# Visualisation cas base (avec défaut notamment sur ajout/supp) 

```{r ggplot methode geometry}
plot <- ggplot() +
  geom_sf(data = commune, aes(fill = "Communes"),color = "black", alpha = 0.5) +  
  geom_sf(data = bordure, aes(fill = "Bordures étendues"), fill = "lightblue", 
          alpha = 0.5, color = "lightblue") +  
  geom_sf(data = modif_apres, aes(fill = "Parcelles modifiées (2024)"), 
          alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = modif_avant, aes(fill = "Parcelles modifiées (2023)"), 
          alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = ajout, aes(fill = "Parcelles ajoutées"), 
          alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = supp, aes(fill = "Parcelles supprimées"), 
          alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", 
                               "Parcelles modifiées (2024)" = "purple",
                               "Parcelles modifiées (2023)" = "pink", 
                               "Parcelles ajoutées" = "green", "Parcelles supprimées" = "red")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales croisant les frontières étendues des communes en Vendée, modifiés au niveau de la geometry en 2024", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 50m de chaque côté de celles définies par l'IGN")

ggsave("parcelles_bordures_modifiées_85.png", plot = plot, width = 12, height = 8, dpi = 300)
# plot
```

```{r mapview methode geometry}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure, layer.name = "Bordures étendues", 
          col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(modif_apres, layer.name = "Parcelles modifiées (état 2024)", 
          col.regions = "purple", alpha.regions = 0.5) +
  mapview(modif_avant, layer.name = "Parcelles modifiées (état 2023)", 
          col.regions = "pink", alpha.regions = 0.5) +
  mapview(ajout, layer.name = "Parcelles ajoutées", 
          col.regions = "lightgreen", alpha.regions = 0.5) +
  mapview(supp, layer.name = "Parcelles supprimées",
          col.regions = "red", alpha.regions = 0.5)

mapshot(map, url = "parcelles_modifiées_bordure_85.html")
```

## Reconnaissances des cas de translation, modification de contour et les deux à la fois

```{r}
dbSendQuery(conn, "
  CREATE TEMP TABLE modif_apres_jointure AS
  SELECT modif_apres.*, modif.iou, modif.iou_ajust
  FROM modif
  LEFT JOIN modif_apres ON modif.idu = modif_apres.idu;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE modif_avant_jointure AS
  SELECT modif_avant.*, modif.iou, modif.iou_ajust
  FROM modif
  LEFT JOIN modif_avant ON modif.idu = modif_avant.idu;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE translation AS
  SELECT idu, ?
         idu AS idu_translate
  FROM modif_apres_jointure
  WHERE iou_ajust > 0.99;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE contour_apres AS
  SELECT modif_apres_jointure.*,
         iou AS iou_multi,
         idu AS participants_avant,
         idu AS participants_apres
  FROM modif_apres_jointure
  WHERE iou > 0.95 AND iou_ajust < 0.99;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE contour_translation AS
  SELECT idu, ?
         idu AS idu_translate
  FROM modif_apres_jointure
  WHERE iou < 0.95 AND iou_ajust > 0.95 AND iou_ajust < 0.99;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE modif_apres_filtered AS
  SELECT *
  FROM modif_apres_jointure
  WHERE idu NOT IN (SELECT idu FROM translation)
    AND idu NOT IN (SELECT idu FROM contour_apres)
    AND idu NOT IN (SELECT idu FROM contour_translation);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE modif_avant_filtered AS
  SELECT *
  FROM modif_avant_jointure
  WHERE idu NOT IN (SELECT idu FROM translation)
    AND idu NOT IN (SELECT idu FROM contour_apres)
    AND idu NOT IN (SELECT idu FROM contour_translation);
")
```


```{r modif iou et iou_ajust -> translation, modification de contour et les deux à la fois}
modif_apres <- modif %>% select(idu, iou, iou_ajust) %>%
  left_join(modif_apres, by = "idu") %>% 
  st_as_sf() %>% 
  st_set_crs(2154) %>% 
  ungroup()

modif_avant <- modif %>% select(idu, iou, iou_ajust) %>% 
  left_join(modif_avant, by = "idu") %>% 
  st_as_sf() %>% 
  st_set_crs(2154) %>% 
  ungroup()

translation <- modif_apres %>% 
  filter(iou_ajust > 0.99) %>% 
  select(-iou) %>% 
  mutate(idu_translate = idu)

contour_apres <- modif_apres %>% 
  filter(iou > 0.95 & iou_ajust < 0.99) %>% 
  mutate(iou_multi = iou,
         participants_avant = idu,
         participants_apres = idu)

contour_translation <- modif_apres %>% 
  filter(iou < 0.95 & iou_ajust > 0.95 & iou_ajust < 0.99) %>% 
  select(-iou) %>% 
  mutate(idu_translate = idu)

modif_apres <- modif_apres %>%
  filter(!idu %in% translation$idu) %>% 
  filter(!idu %in% contour_apres$idu) %>% 
  filter(!idu %in% contour_translation$idu)

modif_avant <- modif_avant %>%
  filter(!idu %in% translation$idu) %>% 
  filter(!idu %in% contour_apres$idu) %>% 
  filter(!idu %in% contour_translation$idu)
```

## Cas plus compliqués de détection des mêmes cas

```{r modif iou_multi -> translation, modification de contour et les deux à la fois bis}
modif_apres <- modif_apres %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_multi(geometry, modif_apres, modif_avant))) %>%
  mutate(iou_multi = result$iou,
         participants_avant = result$participants_avant,
         participants_apres= result$participants_apres) %>%
  ungroup() %>%
  select(-result)

contour_apres <- modif_apres %>% 
  filter(iou_multi > 0.95 & nchar(participants_avant) == nchar(participants_apres) | 
           nchar(participants_avant) == 14 & nchar(participants_apres) == 14 & iou > iou_ajust) %>% 
  rbind(contour_apres)

contour_translation <- modif_apres %>% 
  filter(nchar(participants_avant) == 14 & nchar(participants_apres) == 14 & iou < iou_ajust | is.na(iou_multi)) %>% 
  select(-iou, -participants_avant, -participants_apres, -iou_multi) %>% 
  mutate(idu_translate = idu) %>% 
  rbind(contour_translation)

modif_apres <- modif_apres %>%
  filter(!idu %in% contour_apres$idu) %>% 
  filter(!idu %in% contour_translation$idu)

modif_avant <- modif_avant %>%
  filter(!idu %in% contour_apres$idu) %>% 
  filter(!idu %in% contour_translation$idu)
```

## Distribution de l'IoU après translation des parcelles

```{r distib iou}
plot <- ggplot(na.omit(modif), aes(x = iou_ajust)) +
  geom_histogram(aes(y = after_stat(density)), binwidth = 0.005, fill = "skyblue", color = "black", alpha = 0.7) +
  geom_segment(x = quantiles[1], xend = quantiles[1], y = 0, yend = 9, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[2], xend = quantiles[2], y = 0, yend = 12, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[3], xend = quantiles[3], y = 0, yend = 15, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[4], xend = quantiles[4], y = 0, yend = 19, color = "blue", linetype = "dashed", linewidth = 0.6) +
  annotate("text", x = quantiles[1], y = 10, label = paste0("1% Quantile: ", round(quantiles[1], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[2], y = 13, label = paste0("3% Quantile: ", round(quantiles[2], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[3], y = 16, label = paste0("5% Quantile: ", round(quantiles[3], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[4], y = 20, label = paste0("10% Quantile: ", round(quantiles[4], 2)), color = "blue", vjust = -1.5) +
  labs(title = "Histogramme de la variable iou_ajust avec quantiles",
       x = "iou_ajust",
       y = "Fréquence") +
  theme_bw()

# ggsave("Distribution_iou.png", plot = plot, width = 12, height = 8, dpi = 300)
```

# Focus des parcelles ayant changé de communes

## Cas des parcelles dans le cas d'une fusion de communes

```{r ajout/supp -> focus fusion commune}
com_abs_apres <- ajout %>% 
  filter(com_abs != "000") %>%
  mutate(idu_avant = paste0(substr(idu,1,2),
                            com_abs, 
                            "000", 
                            substr(idu,9,14))
  )

com_abs_avant <- supp %>% 
  filter(idu %in% com_abs_apres$idu_avant)

com_abs_apres <- com_abs_apres %>% 
  filter(idu_avant %in% com_abs_avant$idu)
# Parcelles n'ayant pas été modifiées mise à part le nom de commune
```


```{r focus parcelle changement de communes}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(com_abs_apres_bis, layer.name = "Parcelles abs_bis (état 2024)", col.regions = "purple", alpha.regions = 0.5) +
  mapview(com_abs_avant, layer.name = "Parcelles abs (état 2023)", col.regions = "lightgreen", alpha.regions = 0.5) +
  mapview(df_abs, layer.name = "Parcelles df_abs (état 2024)", col.regions = "purple", alpha.regions = 0.5)

# mapshot(map, url = "parcelles_abs.html")
```

# Focus parcelles avec changement "majeur" lié à un changement impactant l'identifiant des parcelles

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r ajout/supp geometry egal}
ajout_identique <- ajout %>%
  st_filter(supp, .predicate = st_equals)
# Parcelles n'ayant pas été modifiées

supp_identique <- supp %>%
  st_filter(ajout, .predicate = st_equals)
# Parcelles n'ayant pas été modifiées

ajout <- ajout %>% 
  filter(!idu %in% ajout_identique$idu) %>% 
  arrange(nom_com)

supp <- supp %>% 
  filter(!idu %in% supp_identique$idu) %>% 
  arrange(nom_com)

rm(ajout_identique, supp_identique)
```

## Reconnaissances des cas de fusion (peu fréquent) ou subdivision (plus courant)

```{r ajout/supp iou -> fusion/subdivision}

supp <- supp %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_intersec(geometry, ajout))) %>%
  mutate(iou = result$iou,
         participants = result$participants) %>%
  ungroup() %>%
  select(-result)

ajout <- ajout %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_intersec(geometry, supp))) %>%
  mutate(iou = result$iou,
         participants = result$participants) %>%
  ungroup() %>%
  select(-result)

fusion <- ajout %>% 
  filter(iou > 0.99 & nchar(participants) != 14)

subdiv <- supp %>% 
  filter(iou > 0.99 & nchar(participants) != 14)

ajout <- ajout %>%
  filter(!idu %in% unlist(str_split(subdiv$participants, ",\\s*"))) %>% 
  filter(!idu %in% fusion$idu & iou < 0.99 | is.na(iou))

supp <- supp %>%
  filter(!idu %in% unlist(str_split(fusion$participants, ",\\s*"))) %>% 
  filter(!idu %in% subdiv$idu & iou < 0.99 | is.na(iou))
```

## Reconnaissances des cas de multi-subdivision (ex : 2 -> 3) ou modification de contours

```{r ajout/supp iou_multi -> multi-subdivision et contours}

supp <- supp %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_multi(geometry, supp, ajout))) %>%
  mutate(iou_multi = result$iou,
         participants_avant = result$participants_avant,
         participants_apres= result$participants_apres) %>%
  ungroup() %>%
  select(-result)

multi_subdiv <- supp %>% 
  filter(iou_multi > 0.99 & nchar(participants_avant) != nchar(participants_apres))

contour <- supp %>% 
  filter((iou_multi > 0.95 & nchar(participants_avant) == nchar(participants_apres)) | nchar(participants_avant) == 14 & nchar(participants_apres) == 14)

ajout <- ajout %>%
  filter(!idu %in% unlist(str_split(multi_subdiv$participants_apres, ",\\s*"))) %>% 
  filter(!idu %in% unlist(str_split(contour$participants_apres, ",\\s*")))

supp <- supp %>%
  filter(!idu %in% unlist(str_split(multi_subdiv$participants_avant, ",\\s*"))) %>% 
  filter(!idu %in% unlist(str_split(contour$participants_avant, ",\\s*")))
```

## Reconnaissances des cas de modification de contours plus compliquée

```{r changement forme + ou découpage compliquée}
supp <- supp %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_multi(geometry, supp, ajout))) %>%
  mutate(iou_multi = result$iou,
         participants_avant = result$participants_avant,
         participants_apres= result$participants_apres) %>%
  ungroup() %>%
  select(-result)

# Cas d'une parcelle spécial 850040000F0149
contour <- supp %>% 
  filter((iou_multi > 0.95 & nchar(participants_avant) == nchar(participants_apres)) | nchar(participants_avant) == 14 & nchar(participants_apres) == 14) %>% 
  rbind(contour)

ajout <- ajout %>%
  filter(!idu %in% unlist(str_split(contour$participants_apres, ",\\s*")))

supp <- supp %>%
  filter(!idu %in% unlist(str_split(contour$participants_avant, ",\\s*")))

contour_transfo <- supp %>% 
  filter(iou_multi > 0.95)

ajout <- ajout %>%
  filter(!idu %in% unlist(str_split(contour_transfo$participants_apres, ",\\s*")))

supp <- supp %>%
  filter(!idu %in% unlist(str_split(contour_transfo$participants_avant, ",\\s*")))
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation, modification de contour avec translation

```{r ajout/supp iou_ajust -> translation, contour + translation}

ajout <- ajout %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_intersec_translate(geometry, supp))) %>%
  mutate(iou_ajust = result$iou_ajust,
         idu_translate = result$idu_translate) %>%
  ungroup() %>%
  select(-result)

translation <- ajout %>% 
  filter(iou_ajust > 0.99) %>% 
  select(-iou,-participants) %>% 
  rbind(translation)

contour_translation <- ajout %>% 
  filter(iou_ajust > 0.95 & iou_ajust < 0.99) %>% 
  select(-iou,-participants) %>% 
  rbind(contour_translation)

ajout <- ajout %>%
  filter(!idu %in% translation$idu) %>% 
  filter(!idu %in% contour_translation$idu)

supp <- supp %>%
  filter(!idu %in% translation$idu_translate)%>% 
  filter(!idu %in% contour_translation$idu_translate)
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation avec modification de contour et avec fusion

```{r ajout/supp iou_ajust -> contour_fusion_translation}
supp <- supp %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_multi_translate(geometry, supp, ajout))) %>%
  mutate(iou_multi_translate = result$iou,
         participants_avant_multi_translate = result$participants_avant,
         participants_apres_multi_translate = result$participants_apres) %>%
  ungroup() %>%
  select(-result)

contour_fusion_translation <- supp %>% 
  filter(iou_multi_translate > 0.95)

ajout <- ajout %>%
  filter(!idu %in% contour_fusion_translation$participants_apres_multi_translate)

supp <- supp %>%
  filter(!idu %in% contour_fusion_translation$participants_avant_multi_translate)
```

## Recalcul de l'IoU pour détecter les parcelles maintenant isolées -> Véritable ajout ou suppression

```{r}
supp <- supp %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_intersec(geometry, ajout))) %>%
  mutate(iou = result$iou,
         participants = result$participants) %>%
  ungroup() %>%
  select(-result)

ajout <- ajout %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_intersec(geometry, supp))) %>%
  mutate(iou = result$iou,
         participants = result$participants) %>%
  ungroup() %>%
  select(-result)

vrai_ajout <- ajout %>%
  filter(is.na(iou))

vrai_supp <- supp %>%
  filter(is.na(iou))

ajout <- ajout %>%
  filter(!is.na(iou))

supp <- supp %>%
  filter(!is.na(iou))
```

# Visualisation finale sur une carte du département

```{r mapview typologie parcelles}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", 
               alpha.regions = 0.5, homebutton = F) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(translation,
          layer.name = "Parcelles translatées (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ins_parc_23 %>%
            filter(idu %in% translation$idu_translate), 
          layer.name = "Parcelles translatées (état 2023)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(fusion, layer.name = "Parcelles fusionnéees (état 2024)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(supp_tot %>%
            filter(idu %in% unlist(str_split(fusion$participants, ",\\s*"))),  
          layer.name = "Parcelles avant fusion (état 2023)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(subdiv$participants, ",\\s*"))),  
          layer.name = "Parcelles subdivisées (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(subdiv,  layer.name = "Parcelles avant subdivision (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(multi_subdiv$participants_apres, ",\\s*"))),
          layer.name = "Parcelles après multi-subdivision (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(multi_subdiv,  
          layer.name = "Parcelles avant multi-subdivision (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(contour$participants_apres, ",\\s*"))),  
          layer.name = "Parcelles après évolution forme (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(contour,
          layer.name = "Parcelles avant évolution forme (état 2023)",
          col.regions = "purple", alpha.regions = 0.5, homebutton = F) +
  mapview(contour_apres,  
          layer.name = "Parcelles après évolution forme (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ins_parc_23 %>%
            filter(idu %in% contour_apres$idu),  
          layer.name = "Parcelles avant évolution forme (état 2023)", 
          col.regions = "purple", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(contour_transfo$participants_apres, ",\\s*"))),  
          layer.name = "Parcelles ayant transfo + évolution forme (état 2024)",
          alpha.regions = 0.5, homebutton = F) +
  mapview(contour_transfo,
          layer.name = "Parcelles ayant transfo + évolution forme (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(contour_translation,  
          layer.name = "Parcelles ayant translatées + évolution forme (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ins_parc_23 %>%
            filter(idu %in% contour_translation$idu_translate),
          layer.name = "Parcelles ayant translatées + évolution forme (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(contour_fusion_translation,  
          layer.name = "Parcelles ayant translatées + évolution forme + fusion (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% contour_fusion_translation$participants_apres_multi_translate),
          layer.name = "Parcelles ayant translatées + évolution forme + fusion (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(com_abs_apres,  layer.name = "Parcelles après fusion de communes (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(com_abs_avant,  layer.name = "Parcelles avant fusion de communes (état 2023)", 
          col.regions = "purple", alpha.regions = 0.5, homebutton = F) +
  mapview(vrai_ajout, layer.name = "Parcelles véritablement ajoutées", 
          col.regions = "green", alpha.regions = 0.5, homebutton = F) +
  mapview(vrai_supp, layer.name = "Parcelles véritablement supprimées",
          col.regions = "red", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout, z = c("iou_ajust"), layer.name = "Parcelles restantes (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(supp, z = c("iou_multi"), layer.name = "Parcelles restantes (état 2023)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(modif_apres, z = c("iou_ajust"), 
          layer.name = "Parcelles modifiées restantes (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(modif_avant, z = c("iou_ajust"), 
          layer.name = "Parcelles modifiées restantes (état 2023)", 
          alpha.regions = 0.5, homebutton = F)

mapshot(map, url = "parcelles_iou_inside_bordure_85.html")
```

# Tableau de comparaison de superficie entre les deux années

```{r evolution superficie}
evol_sup <- modif %>% 
  mutate(superficie_apres = st_area(geometry_apres),
         superficie_avant = st_area(geometry_avant)) %>% 
  group_by(code_com) %>% 
  summarise(modif_superficie_apres = round(sum(superficie_apres),2),
            modif_superficie_avant = round(sum(superficie_avant),2),
            modif_evolution_superficie = modif_superficie_apres - modif_superficie_avant)

ajout_sup <- ajout %>% 
  mutate(superficie = st_area(geometry)) %>% 
  group_by(code_com) %>% 
  summarise(superficie_ajoute = round(sum(superficie),2)) %>% 
  st_drop_geometry()

supp_sup <- supp %>% 
  mutate(superficie = st_area(geometry)) %>% 
  group_by(code_com) %>% 
  summarise(superficie_supprime = round(sum(superficie),2)) %>% 
  st_drop_geometry()

evol_sup <- evol_sup %>% 
  full_join(ajout_sup, by = "code_com") %>% 
  full_join(supp_sup, by = "code_com") %>% 
  mutate(across(everything(), ~ replace_na(.x, units::set_units(0, m*m)))) %>% 
  mutate(tot_evolution_superficie = round(modif_evolution_superficie + superficie_ajoute - superficie_supprime,2))
```

