---
title: "Vendée_sql 2024-2023"
output: html_document
date: "2024-06-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

# Import package + fonction utilisés après

```{r package message=FALSE, warning=FALSE}
library(sf)
library(dplyr)
library(lubridate)
library(mapview)
library(DBI)
library(ggplot2)
library(purrr)
library(webshot)
library(pracma)
library(RColorBrewer)
library(tidyr)
library(stringr)
# webshot::install_phantomjs()
source(file = "connexion_db.R")
conn <- connecter()
DBI::dbListTables(conn)
```

```{r voir les index}
dbGetQuery(conn, " SELECT 
    tablename, 
    indexname, 
    indexdef 
FROM 
    pg_indexes 
WHERE 
    schemaname LIKE 'pg_temp_%' 
    OR schemaname = 'public';
           ")
```

```{r voir les tables temporaires}
dbGetQuery(conn, " SELECT 
    schemaname AS schema_name,
    tablename AS table_name
FROM 
    pg_tables
WHERE 
    schemaname LIKE 'pg_temp_%'
ORDER BY 
    schemaname, tablename;
           ")
```

```{r supprimer toutes les tables temporaires}
query_list <- "
SELECT 
    tablename
FROM 
    pg_tables
WHERE 
    schemaname LIKE 'pg_temp_%';
"

# Exécution de la requête pour obtenir les noms des tables temporaires
tables_temporaires <- dbGetQuery(conn, query_list)

# Générer les commandes de suppression
drop_queries <- lapply(tables_temporaires$tablename, function(table) {
    paste("DROP TABLE IF EXISTS", table, "CASCADE;")
})

# Exécution des commandes de suppression
for (query in drop_queries) {
    dbSendQuery(conn, query)
}
```

```{r}

dbSendQuery(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou(geometry_avant geometry, geometry_apres geometry)
  RETURNS numeric AS $$
  DECLARE
      intersection geometry;
      aire_intersection numeric;
      geom_union geometry;
      aire_union numeric;
      iou numeric;
  BEGIN
      -- Vérifier si les géométries ne sont pas vides
      IF NOT ST_IsEmpty(geometry_avant) AND NOT ST_IsEmpty(geometry_apres) THEN
          intersection := ST_Intersection(geometry_avant, geometry_apres);
        
          -- Si l'intersection est vide, IoU = 0
          IF ST_IsEmpty(intersection) THEN
              RETURN 0;
          END IF;
        
          aire_intersection := ST_Area(intersection);
          geom_union := ST_Union(geometry_avant, geometry_apres);
          aire_union := ST_Area(geom_union);
        
          -- Calculer l'IoU
          iou := aire_intersection / aire_union;
          RETURN iou;
      ELSE
          RETURN NULL;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
")

dbSendQuery(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_ajust(geometry_avant geometry, geometry_apres geometry)
  RETURNS numeric AS $$
  DECLARE
      centroid_apres geometry;
      centroid_avant geometry;
      translation_vector_x double precision;
      translation_vector_y double precision;
      geometry_avant_ajust geometry;
      iou_ajust numeric;
  BEGIN
      -- Vérifier si les géométries ne sont pas vides
      IF NOT ST_IsEmpty(geometry_avant) AND NOT ST_IsEmpty(geometry_apres) THEN
          centroid_apres := ST_Centroid(geometry_apres);
          centroid_avant := ST_Centroid(geometry_avant);
          translation_vector_x := ST_X(centroid_apres) - ST_X(centroid_avant);
          translation_vector_y := ST_Y(centroid_apres) - ST_Y(centroid_avant);
          
          -- Calculer la géométrie avant ajustée en utilisant ST_Translate
          geometry_avant_ajust := ST_Translate(geometry_avant, translation_vector_x, translation_vector_y);
          
          -- Calculer l'IoU ajusté avec la géométrie avant ajustée
          iou_ajust := calcul_iou(geometry_avant_ajust, geometry_apres);
          
          RETURN iou_ajust;
      ELSE
          RETURN NULL;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
")

dbSendQuery(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_intersec(polygon geometry, ajout_table_name text)
  RETURNS TABLE (iou numeric, participants text) AS $$
  DECLARE
      parcelles_intersectant RECORD;
      nom_participants text := '';
      union_parcelles geometry;
      query_text text;
      first boolean := true;
  BEGIN
      -- Sélectionner les parcelles intersectant avec le polygon
      query_text := '
          SELECT idu
          FROM ' || quote_ident(ajout_table_name) || '
          WHERE ST_Intersects(st_buffer($1, -1), geometry)
      ';
      
      FOR parcelles_intersectant IN EXECUTE query_text USING polygon
      LOOP
          IF first THEN
              nom_participants := parcelles_intersectant.idu::text;
              first := false;  -- Après le premier cas, mettre à jour la variable
          ELSE
              nom_participants := nom_participants || ', ' || parcelles_intersectant.idu::text;
          END IF;
      END LOOP;
      
      -- Si aucun résultat, retourner NULL
      IF nom_participants = '' THEN
          RETURN QUERY SELECT NULL::numeric, NULL::text;
          RETURN;  -- Terminer la fonction immédiatement
      END IF;
      
      -- Calculer l'union des parcelles intersectant
      query_text := '
          SELECT ST_Union(geometry)
          FROM ' || quote_ident(ajout_table_name) || '
          WHERE idu IN (
              SELECT idu
              FROM ' || quote_ident(ajout_table_name) || '
              WHERE ST_Intersects(st_buffer($1, -1), geometry)
          )
      ';

      -- Calculer l'union des parcelles intersectant
      EXECUTE query_text INTO union_parcelles USING polygon;
      
      -- Calculer l'IoU avec l'union des parcelles et le polygon
      RETURN QUERY SELECT calcul_iou(union_parcelles, polygon), nom_participants;
  END;
  $$ LANGUAGE plpgsql;
")

dbSendQuery(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_multi(polygon geometry, supp_table_name text, ajout_table_name text)
  RETURNS TABLE (iou_multi numeric, participants_avant text, participants_apres text) AS $$
  DECLARE
      n integer := 0;
      k integer := 0;
      nom_participants_avant text;
      polygon_maj geometry;
      iou_intersect RECORD;
      query_sql text;
      
  BEGIN
      -- Initialiser le polygon_maj avec la géométrie de départ
      polygon_maj := polygon;
  
      -- Boucle pour trouver les intersections dans supp
      LOOP
          -- Mettre à jour polygon_maj avec l'union des géométries de supp
          EXECUTE '
            SELECT ST_Union(geometry) 
            FROM ' || quote_ident(supp_table_name) || ' 
            WHERE ST_Intersects(geometry, $1)
        ' INTO polygon_maj USING polygon_maj;
  
          -- Sortir de la boucle si le nombre de parcelles reste le même
          query_sql := '
            SELECT COUNT(*) 
            FROM ' || quote_ident(supp_table_name) || ' 
            WHERE ST_Intersects(geometry, $1)';
        
          EXECUTE query_sql INTO k USING polygon_maj;
          
          EXIT WHEN n = k;
  
          -- Mettre à jour le nombre de parcelles
          n := k;
      END LOOP;
  
      -- Sélectionner les noms des participants avant
      query_sql := '
        SELECT string_agg(idu::text, '', '') 
        FROM ' || quote_ident(supp_table_name) || ' 
        WHERE ST_Intersects(geometry, $1)';
    
      EXECUTE query_sql INTO nom_participants_avant USING polygon_maj;
  
      -- Calculer l'IoU intersection avec ajout
      SELECT * INTO iou_intersect
      FROM calcul_iou_intersec(polygon_maj, ajout_table_name);  -- Utilisez le nom de votre table ajout
  
      -- Retourner les résultats
      RETURN QUERY SELECT iou_intersect.iou, nom_participants_avant, iou_intersect.participants;
  END;
  $$ LANGUAGE plpgsql;
")

dbSendQuery(conn, "
CREATE OR REPLACE FUNCTION calcul_iou_intersec_translate(polygon geometry, ajout geometry)
RETURNS TABLE (iou_ajust numeric, idu_translate text) AS $$
DECLARE
    parcelle RECORD;
    max_iou numeric := -Inf;
    iou_value numeric;
BEGIN
    -- Sélectionner les parcelles intersectant avec la zone tampon de polygon
    FOR parcelle IN
        SELECT idu, geometry
        FROM ajout
        WHERE ST_Intersects(geometry, ST_Buffer(polygon, -1))
    LOOP
        -- Calculer l'IoU entre la parcelle courante et polygon
        BEGIN
            iou_value := calcul_iou(parcelle.geometry, polygon);
        EXCEPTION WHEN others THEN
            iou_value := NULL; -- Ignorer les erreurs de calcul d'IoU
        END;
        
        -- Mettre à jour si on trouve un IoU plus élevé
        IF iou_value > max_iou THEN
            max_iou := iou_value;
            idu_translate := parcelle.idu;
        END IF;
    END LOOP;
    
    -- Si aucune parcelle intersecte, retourner NA
    IF max_iou = -Inf THEN
        RETURN QUERY SELECT NULL::numeric, NULL::text;
    END IF;
    
    -- Calculer l'IoU ajusté avec la meilleure parcelle trouvée
    iou_ajust := calcul_iou_ajust((SELECT geometry FROM ajout WHERE idu = idu_translate), polygon);
    
    -- Retourner les résultats
    RETURN QUERY SELECT iou_ajust, idu_translate;
END;
$$ LANGUAGE plpgsql;
")

dbSendQuery(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_multi_translate(polygon geometry, supp geometry, ajout geometry)
  RETURNS TABLE (iou numeric, participants_avant text, participants_apres text) AS $$
  DECLARE
      n integer := 0;
      polygon_maj geometry := polygon;
      nom_participants_avant text;
      iou_intersect RECORD;
  BEGIN
      -- Boucle pour mettre à jour polygon_maj avec l'union des géométries dans supp
      LOOP
          -- Sélectionner les parcelles dans supp qui intersectent avec polygon_maj
          SELECT ST_Union(geometry) INTO polygon_maj
          FROM supp
          WHERE ST_Intersects(geometry, polygon_maj);
  
          -- Condition de sortie : le nombre de parcelles reste le même
          EXIT WHEN n = (SELECT COUNT(*) FROM supp WHERE ST_Intersects(geometry, polygon_maj));
  
          -- Mettre à jour le nombre de parcelles
          n := (SELECT COUNT(*) FROM supp WHERE ST_Intersects(geometry, polygon_maj));
      END LOOP;
  
      -- Sélectionner les noms des participants avant
      SELECT string_agg(idu::text, ', ') INTO nom_participants_avant
      FROM supp
      WHERE ST_Intersects(geometry, polygon_maj);
  
      -- Calculer l'IoU intersection ajusté avec ajout
      SELECT * INTO iou_intersect
      FROM calcul_iou_intersec_translate(polygon_maj, ajout);
  
      -- Retourner les résultats
      RETURN QUERY SELECT iou_intersect.iou_ajust AS iou, nom_participants_avant AS participants_avant, iou_intersect.idu_translate AS participants_apres;
  END;
  $$ LANGUAGE plpgsql;
")
```


# Importation des parcelles sur l'ensemble du département et des périodes données


```{r import sql}

dbSendQuery(conn, "
  CREATE TEMP TABLE ajout_tot AS
  SELECT * 
  FROM parc_85_24
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_85_23 
    WHERE parc_85_24.idu = parc_85_23.idu
  );
")

dbSendQuery(conn, "
  CREATE INDEX idx_ajout_tot_geometry ON ajout_tot USING GIST(geometry);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE supp_tot AS
  SELECT * 
  FROM parc_85_23
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_85_24
    WHERE parc_85_23.idu = parc_85_24.idu
  );
")

dbSendQuery(conn, "
  CREATE INDEX idx_supp_tot_geometry ON supp_tot USING GIST(geometry);
")

```

```{r}
parcelle_24 <- st_read(conn, query = "SELECT * FROM parc_85_24;")
parcelle_23 <- st_read(conn, query = "SELECT * FROM parc_85_23;")
commune <- st_read(conn, query = "SELECT * FROM com_85;")

ajout_tot <- st_read(conn, query = "SELECT * FROM ajout_tot;")
supp_tot <- st_read(conn, query = "SELECT * FROM supp_tot;")
```


# Définition de la bordure dans laquelle je considère que mes parcelles doivent apartenir entièrement

```{r}
dbSendQuery(conn, "
  CREATE TEMP TABLE bordure AS
  SELECT
      code_insee, nom_com, code_dep,
      ST_Difference(ST_Buffer(geometry, 250), ST_Buffer(geometry, -250)) AS geometry
  FROM
      com_85;
")

dbSendQuery(conn, "
  CREATE INDEX idx_bordure_geometry ON bordure USING GIST(geometry);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE ins_parc_24 AS
  SELECT DISTINCT
      parc_85_24.*
  FROM
      parc_85_24
  JOIN
      bordure
  ON
      ST_WITHIN(parc_85_24.geometry, bordure.geometry);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE ins_parc_23 AS
  SELECT DISTINCT
      parc_85_23.*
  FROM
      parc_85_23
  JOIN
      bordure
  ON
      ST_WITHIN(parc_85_23.geometry, bordure.geometry);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE ajout AS
  SELECT 
      ajout_tot.*
  FROM
      ajout_tot
  JOIN
      bordure
  ON
      ST_WITHIN(ajout_tot.geometry, bordure.geometry)
  ORDER BY ajout_tot.nom_com;
")

dbSendQuery(conn, "
  CREATE INDEX idx_ajout_geometry ON ajout USING GIST(geometry);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE supp AS
  SELECT 
      supp_tot.*
  FROM
      supp_tot
  JOIN
      bordure
  ON
      ST_WITHIN(supp_tot.geometry, bordure.geometry)
  ORDER BY supp_tot.nom_com;
")

dbSendQuery(conn, "
  CREATE INDEX idx_supp_geometry ON supp USING GIST(geometry);
")
```


```{r bordure sql}

bordure <- st_read(conn, query = "
  SELECT 
      *
  FROM
      bordure;
") %>%
  mutate(geometry = st_cast(geometry, "MULTIPOLYGON"))

ins_parc_24 <- st_read(conn, query = "
  SELECT * FROM ins_parc_24;
")

ins_parc_23 <- st_read(conn, query = "
   SELECT * FROM ins_parc_23;
")

ajout <- st_read(conn, query = "
  SELECT * FROM ajout;
")

supp <- st_read(conn, query = "
  SELECT * FROM supp;
")

dbSendQuery(conn, "DROP TABLE IF EXISTS bordure;")
```

# Carte des parcelles appartenant + croisant la bordure

```{r ggplot bordure}
plot <- ggplot() +
  geom_sf(data = commune, aes(fill = "Communes"), color = "black", alpha = 0.5) +  
  geom_sf(data = bordure, aes(fill = "Bordures étendues"), fill = "lightblue", alpha = 0.5, color = "lightblue") +  
  geom_sf(data = ins_parc_24, aes(fill = "Parcelles croisées"), alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", "Parcelles croisées" = "purple")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales (2024) croisant les frontières étendues des communes de Vendée", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 250m de chaque côté de celles définies par l'IGN")

# ggsave("parcelles_croisant_bordures_85.png", plot = plot, width = 12, height = 8, dpi = 300)
plot
```

# Focus sur une commune ayant fusionné avec d'autres communes limitrophes

```{r focus parcelle la tardiere}
map <- mapview(commune %>% 
                 filter(code_insee == "85289"), 
               layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure %>% 
            filter(code_insee == "85289"), 
          layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(parcelle_24 %>% 
            filter(code_com == "289"), 
          layer.name = "Parcelles (état 2024)", col.regions = "purple", alpha.regions = 0.5) +
  mapview(parcelle_23 %>% 
            filter(code_com %in% c("289", "053", "037")), 
          layer.name = "Parcelles (état 2023)", col.regions = "lightgreen", alpha.regions = 0.5)

# mapshot(map, url = "parcelles_tardiere.html")
```

# Focus sur les parcelles dont je peux comparer l'état sur les deux périodes facilement (cad parcelles ayant conservé leur identifiant)

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r modif geometry egal sql}

dbSendQuery(conn, "
  CREATE TEMP TABLE identique AS
  SELECT ins_parc_24.*
  FROM ins_parc_24
  WHERE NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE ins_parc_24.idu = ajout.idu
  )
  AND EXISTS (
      SELECT 1
      FROM ins_parc_23 
      WHERE ins_parc_24.idu = ins_parc_23.idu
      AND ST_Equals(ins_parc_24.geometry, ins_parc_23.geometry)
  );
")

dbSendQuery(conn, "
  CREATE TEMP TABLE modif_apres AS
  SELECT ins_parc_24.*
  FROM ins_parc_24
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE ins_parc_24.idu = identique.idu
  )
  AND NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE ins_parc_24.idu = ajout.idu
  )
  ORDER BY ins_parc_24.nom_com;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE modif_avant AS
  SELECT ins_parc_23.*
  FROM ins_parc_23
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE ins_parc_23.idu = identique.idu
  )
  AND NOT EXISTS (
      SELECT 1
      FROM supp
      WHERE ins_parc_23.idu = supp.idu
  )
  ORDER BY ins_parc_23.nom_com;
")


dbSendQuery(conn, "
  CREATE TEMP TABLE modif AS
  SELECT
      COALESCE(avant.idu, apres.idu) AS idu,
      apres.geometry AS geometry_apres,
      avant.geometry AS geometry_avant,
      calcul_iou(apres.geometry, avant.geometry) AS iou,
      calcul_iou_ajust(apres.geometry, avant.geometry) AS iou_ajust,
      (calcul_iou_multi(apres.geometry, 'modif_apres' , 'modif_avant')).*
  FROM
      modif_avant avant
  FULL JOIN
      modif_apres apres ON avant.idu = apres.idu;
")

dbSendQuery(conn, "
  DELETE FROM modif
  WHERE iou > 0.99;
")

dbSendQuery(conn, "DROP TABLE IF EXISTS identique;")
```

```{r modif iou et iou_ajust}

modif <- st_read(conn, query = "
   SELECT * FROM modif;
")
# Elimine les parcelles "sans changement manifeste" plus les parcelles sans iou = parcelles n'étant plus entièrement dans la bordure lors d'un changement d'une année sur l'autre

quantiles <- quantile(modif$iou_ajust, probs = c(0.01, 0.03, 0.05, 0.1), na.rm = TRUE)
```

# Visualisation cas base (avec défaut notamment sur ajout/supp) 

```{r ggplot methode geometry}
plot <- ggplot() +
  geom_sf(data = commune, aes(fill = "Communes"),color = "black", alpha = 0.5) +  
  geom_sf(data = bordure, aes(fill = "Bordures étendues"), fill = "lightblue", 
          alpha = 0.5, color = "lightblue") +  
  geom_sf(data = modif_apres, aes(fill = "Parcelles modifiées (2024)"), 
          alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = modif_avant, aes(fill = "Parcelles modifiées (2023)"), 
          alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = ajout, aes(fill = "Parcelles ajoutées"), 
          alpha = 0.5, color = "black", size = 0.01) +
  geom_sf(data = supp, aes(fill = "Parcelles supprimées"), 
          alpha = 0.5, color = "black", size = 0.01) +
  scale_fill_manual(values = c("Communes" = "white", "Bordures étendues" = "lightblue", 
                               "Parcelles modifiées (2024)" = "purple",
                               "Parcelles modifiées (2023)" = "pink", 
                               "Parcelles ajoutées" = "green", "Parcelles supprimées" = "red")) +
  theme_minimal() +
  labs(title = "Parcelles cadastrales croisant les frontières étendues des communes en Vendée, modifiés au niveau de la geometry en 2024", 
       fill ="Légende",
       subtitle = "Les bordures des communes sont élargies d'un rayon de 50m de chaque côté de celles définies par l'IGN")

ggsave("parcelles_bordures_modifiées_85.png", plot = plot, width = 12, height = 8, dpi = 300)
# plot
```

```{r mapview methode geometry}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure, layer.name = "Bordures étendues", 
          col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(modif_apres, layer.name = "Parcelles modifiées (état 2024)", 
          col.regions = "purple", alpha.regions = 0.5) +
  mapview(modif_avant, layer.name = "Parcelles modifiées (état 2023)", 
          col.regions = "pink", alpha.regions = 0.5) +
  mapview(ajout, layer.name = "Parcelles ajoutées", 
          col.regions = "lightgreen", alpha.regions = 0.5) +
  mapview(supp, layer.name = "Parcelles supprimées",
          col.regions = "red", alpha.regions = 0.5)

mapshot(map, url = "parcelles_modifiées_bordure_85.html")
```

## Reconnaissances des cas de translation, modification de contour et les deux à la fois

```{r}
dbSendQuery(conn, "
  CREATE TEMP TABLE modif_apres_jointure AS
  SELECT modif_apres.*, modif.iou, modif.iou_ajust, modif.iou_multi, 
    modif.participants_avant, modif.participants_apres
  FROM modif
  LEFT JOIN modif_apres ON modif.idu = modif_apres.idu;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE modif_avant_jointure AS
  SELECT modif_avant.*, modif.iou, modif.iou_ajust
  FROM modif
  LEFT JOIN modif_avant ON modif.idu = modif_avant.idu;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE translation AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         idu AS idu_translate
  FROM modif_apres_jointure
  WHERE iou_ajust > 0.99;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE contour_apres AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         iou AS iou_multi,
         idu AS participants_avant,
         idu AS participants_apres
  FROM modif_apres_jointure
  WHERE iou > 0.95 AND iou_ajust < 0.99;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE contour_translation AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         idu AS idu_translate
  FROM modif_apres_jointure
  WHERE iou < 0.95 AND iou_ajust > 0.95 AND iou_ajust < 0.99;
")

dbSendQuery(conn, "
  DELETE FROM modif_apres_jointure
  WHERE idu IN (SELECT idu FROM translation)
    OR idu IN (SELECT idu FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbSendQuery(conn, "
  DELETE FROM modif_avant_jointure
  WHERE idu IN (SELECT idu FROM translation)
    OR idu IN (SELECT idu FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")
```


## Cas plus compliqués de détection des mêmes cas

```{r}
dbExecute(conn, "
  INSERT INTO contour_apres
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         iou AS iou_multi,
         idu AS participants_avant,
         idu AS participants_apres
  FROM modif_apres_jointure
  WHERE (iou_multi > 0.95 AND LENGTH(participants_avant) = LENGTH(participants_apres))
     OR (LENGTH(participants_avant) = 14 AND LENGTH(participants_apres) = 14 AND iou > iou_ajust);
")

dbExecute(conn, "
  INSERT INTO contour_translation
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry, 
         idu AS idu_translate
  FROM modif_apres_jointure
  WHERE ((LENGTH(participants_avant) = 14 AND LENGTH(participants_apres) = 14 AND iou < iou_ajust))
     OR iou_multi IS NULL;
")

dbSendQuery(conn, "
  DELETE FROM modif_apres_jointure
  WHERE idu IN (SELECT idu FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbSendQuery(conn, "
  DELETE FROM modif_avant_jointure
  WHERE idu IN (SELECT idu FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")
```


```{r modif iou_multi -> translation, modification de contour et les deux à la fois bis}

translation <- st_read(conn, query = "SELECT * FROM translation;")

contour_apres <- st_read(conn, query = "SELECT * FROM contour_apres;")

contour_translation <- st_read(conn, query = "SELECT * FROM contour_translation;")
```

## Distribution de l'IoU après translation des parcelles

```{r distib iou}
plot <- ggplot(na.omit(modif), aes(x = iou_ajust)) +
  geom_histogram(aes(y = after_stat(density)), binwidth = 0.005, fill = "skyblue", color = "black", alpha = 0.7) +
  geom_segment(x = quantiles[1], xend = quantiles[1], y = 0, yend = 9, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[2], xend = quantiles[2], y = 0, yend = 12, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[3], xend = quantiles[3], y = 0, yend = 15, color = "blue", linetype = "dashed", linewidth = 0.6) +
  geom_segment(x = quantiles[4], xend = quantiles[4], y = 0, yend = 19, color = "blue", linetype = "dashed", linewidth = 0.6) +
  annotate("text", x = quantiles[1], y = 10, label = paste0("1% Quantile: ", round(quantiles[1], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[2], y = 13, label = paste0("3% Quantile: ", round(quantiles[2], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[3], y = 16, label = paste0("5% Quantile: ", round(quantiles[3], 2)), color = "blue", vjust = -1.5) +
  annotate("text", x = quantiles[4], y = 20, label = paste0("10% Quantile: ", round(quantiles[4], 2)), color = "blue", vjust = -1.5) +
  labs(title = "Histogramme de la variable iou_ajust avec quantiles",
       x = "iou_ajust",
       y = "Fréquence") +
  theme_bw()

# ggsave("Distribution_iou.png", plot = plot, width = 12, height = 8, dpi = 300)
```

# Focus des parcelles ayant changé de communes

## Cas des parcelles dans le cas d'une fusion de communes

```{r ajout/supp -> focus fusion commune}

dbExecute(conn, "
  CREATE TEMP TABLE com_abs_apres AS
  SELECT *,
         SUBSTR(idu, 1, 2) || com_abs || '000' || SUBSTR(idu, 9, 14) AS idu_avant
  FROM ajout
  WHERE com_abs != '000';
")

dbExecute(conn, "
  CREATE TEMP TABLE com_abs_avant AS
  SELECT *
  FROM supp
  WHERE idu IN (SELECT idu_avant FROM com_abs_apres);
")

dbExecute(conn, "
  DELETE FROM com_abs_apres
  WHERE idu_avant NOT IN (SELECT idu FROM com_abs_avant);
")

# Parcelles n'ayant pas été modifiées mise à part le nom de commune
```

```{r}
com_abs_apres <- st_read(conn, query = "SELECT * FROM com_abs_apres;")
com_abs_avant <- st_read(conn, query = "SELECT * FROM com_abs_avant;")

```


```{r focus parcelle changement de communes}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", alpha.regions = 0.5) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", alpha.regions = 0.5) +
  mapview(com_abs_apres_bis, layer.name = "Parcelles abs_bis (état 2024)", col.regions = "purple", alpha.regions = 0.5) +
  mapview(com_abs_avant, layer.name = "Parcelles abs (état 2023)", col.regions = "lightgreen", alpha.regions = 0.5) +
  mapview(df_abs, layer.name = "Parcelles df_abs (état 2024)", col.regions = "purple", alpha.regions = 0.5)

# mapshot(map, url = "parcelles_abs.html")
```

# Focus parcelles avec changement "majeur" lié à un changement impactant l'identifiant des parcelles

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r ajout/supp geometry egal}
# Parcelles ajoutées n'ayant pas été modifiées
dbExecute(conn, "
  CREATE TEMP TABLE ajout_identique AS
  SELECT ajout.*
  FROM ajout
  JOIN supp ON ST_Equals(ajout.geometry, supp.geometry)
")

# Parcelles supprimées n'ayant pas été modifiées
dbExecute(conn, "
  CREATE TEMP TABLE supp_identique AS
  SELECT supp.*
  FROM supp 
  JOIN ajout ON ST_Equals(supp.geometry, ajout.geometry)
")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (SELECT idu FROM ajout_identique);
")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (SELECT idu FROM supp_identique);
")

dbExecute(conn, "DROP TABLE IF EXISTS ajout_identique, supp_identique;")
```

```{r}
ajout <- st_read(conn, query = "SELECT * FROM ajout;")
supp <- st_read(conn, query = "SELECT * FROM supp;")
```

## Reconnaissances des cas de fusion (peu fréquent) ou subdivision (plus courant)

```{r ajout/supp iou -> fusion/subdivision}

dbSendQuery(conn, "
  CREATE TEMP TABLE supp_iou AS
  SELECT
      supp.*,
      (calcul_iou_intersec(supp.geometry, 'ajout')).*
  FROM
      supp;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE ajout_iou AS
  SELECT
      ajout.*,
      (calcul_iou_intersec(ajout.geometry, 'supp')).*
  FROM
      ajout;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE fusion AS
  SELECT *
  FROM ajout_iou
  WHERE iou > 0.99 AND LENGTH(participants) != 14;
")

dbSendQuery(conn, "
  CREATE TEMP TABLE subdiv AS
  SELECT *
  FROM supp_iou
  WHERE iou > 0.99 AND LENGTH(participants) != 14;
")

dbExecute(conn, "
  DELETE FROM ajout_iou
  WHERE idu IN (SELECT unnest(string_to_array(participants, ',\\s*')) FROM subdiv)
    OR idu IN (SELECT idu FROM fusion)
    OR (iou > 0.99 OR iou IS NOT NULL);
")

dbExecute(conn, "
  DELETE FROM supp_iou
  WHERE idu IN (SELECT unnest(string_to_array(participants, ',\\s*')) FROM fusion)
    OR idu IN (SELECT idu FROM subdiv)
    OR (iou > 0.99 OR iou IS NOT NULL);
")

```

```{r}
ajout <- st_read(conn, query = "SELECT * FROM ajout_iou;")
supp <- st_read(conn, query = "SELECT * FROM supp_iou;")

subdiv <- st_read(conn, query = "SELECT * FROM subdiv;")
fusion <- st_read(conn, query = "SELECT * FROM fusion;")
```


## Reconnaissances des cas de multi-subdivision (ex : 2 -> 3) ou modification de contours

```{r ajout/supp iou_multi -> multi-subdivision et contours}

dbSendQuery(conn, "
  CREATE TEMP TABLE supp_iou_multi AS
  SELECT
      supp_iou.*,
      (calcul_iou_multi(supp_iou.geometry, 'supp, 'ajout')).*
  FROM
      supp_iou;
")


dbSendQuery(conn, "
  CREATE TEMP TABLE multi_subdiv AS
  SELECT *
  FROM supp_iou_multi
  WHERE iou_multi > 0.99 AND LENGTH(participants_apres) != LENGTH(participants_avant);
")

dbSendQuery(conn, "
  CREATE TEMP TABLE contour AS
  SELECT *
  FROM supp_iou_multi
  WHERE (iou_multi > 0.99 AND LENGTH(participants_apres) != LENGTH(participants_avant))
    OR (LENGTH(participants_apres) = 14 & LENGTH(participants_avant) = 14);
")

dbExecute(conn, "
  DELETE FROM ajout_iou
  WHERE idu IN (SELECT unnest(string_to_array(participants_apres, ',\\s*')) FROM multi_subdiv)
    OR (SELECT unnest(string_to_array(participants_apres, ',\\s*')) FROM contour);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi
  WHERE idu IN (SELECT unnest(string_to_array(participants_avant, ',\\s*')) FROM multi_subdiv)
    OR idu IN (SELECT unnest(string_to_array(participant_avants, ',\\s*')) FROM contour);
")

```

```{r}
ajout <- st_read(conn, query = "SELECT * FROM ajout_iou;")
supp <- st_read(conn, query = "SELECT * FROM supp_iou_multi;")

multi_subdiv <- st_read(conn, query = "SELECT * FROM multi_subdiv;")
contour <- st_read(conn, query = "SELECT * FROM contour;")
```

## Reconnaissances des cas de modification de contours plus compliquée

```{r changement forme + ou découpage compliquée}
supp <- supp %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_multi(geometry, supp, ajout))) %>%
  mutate(iou_multi = result$iou,
         participants_avant = result$participants_avant,
         participants_apres= result$participants_apres) %>%
  ungroup() %>%
  select(-result)

# Cas d'une parcelle spécial 850040000F0149
contour <- supp %>% 
  filter((iou_multi > 0.95 & nchar(participants_avant) == nchar(participants_apres)) | nchar(participants_avant) == 14 & nchar(participants_apres) == 14) %>% 
  rbind(contour)

ajout <- ajout %>%
  filter(!idu %in% unlist(str_split(contour$participants_apres, ",\\s*")))

supp <- supp %>%
  filter(!idu %in% unlist(str_split(contour$participants_avant, ",\\s*")))

contour_transfo <- supp %>% 
  filter(iou_multi > 0.95)

ajout <- ajout %>%
  filter(!idu %in% unlist(str_split(contour_transfo$participants_apres, ",\\s*")))

supp <- supp %>%
  filter(!idu %in% unlist(str_split(contour_transfo$participants_avant, ",\\s*")))
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation, modification de contour avec translation

```{r ajout/supp iou_ajust -> translation, contour + translation}

ajout <- ajout %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_intersec_translate(geometry, supp))) %>%
  mutate(iou_ajust = result$iou_ajust,
         idu_translate = result$idu_translate) %>%
  ungroup() %>%
  select(-result)

translation <- ajout %>% 
  filter(iou_ajust > 0.99) %>% 
  select(-iou,-participants) %>% 
  rbind(translation)

contour_translation <- ajout %>% 
  filter(iou_ajust > 0.95 & iou_ajust < 0.99) %>% 
  select(-iou,-participants) %>% 
  rbind(contour_translation)

ajout <- ajout %>%
  filter(!idu %in% translation$idu) %>% 
  filter(!idu %in% contour_translation$idu)

supp <- supp %>%
  filter(!idu %in% translation$idu_translate)%>% 
  filter(!idu %in% contour_translation$idu_translate)
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation avec modification de contour et avec fusion

```{r ajout/supp iou_ajust -> contour_fusion_translation}
supp <- supp %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_multi_translate(geometry, supp, ajout))) %>%
  mutate(iou_multi_translate = result$iou,
         participants_avant_multi_translate = result$participants_avant,
         participants_apres_multi_translate = result$participants_apres) %>%
  ungroup() %>%
  select(-result)

contour_fusion_translation <- supp %>% 
  filter(iou_multi_translate > 0.95)

ajout <- ajout %>%
  filter(!idu %in% contour_fusion_translation$participants_apres_multi_translate)

supp <- supp %>%
  filter(!idu %in% contour_fusion_translation$participants_avant_multi_translate)
```

## Recalcul de l'IoU pour détecter les parcelles maintenant isolées -> Véritable ajout ou suppression

```{r}
supp <- supp %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_intersec(geometry, ajout))) %>%
  mutate(iou = result$iou,
         participants = result$participants) %>%
  ungroup() %>%
  select(-result)

ajout <- ajout %>%
  rowwise() %>%
  mutate(result = list(calcul_iou_intersec(geometry, supp))) %>%
  mutate(iou = result$iou,
         participants = result$participants) %>%
  ungroup() %>%
  select(-result)

vrai_ajout <- ajout %>%
  filter(is.na(iou))

vrai_supp <- supp %>%
  filter(is.na(iou))

ajout <- ajout %>%
  filter(!is.na(iou))

supp <- supp %>%
  filter(!is.na(iou))
```

# Visualisation finale sur une carte du département

```{r mapview typologie parcelles}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", 
               alpha.regions = 0.5, homebutton = F) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(translation,
          layer.name = "Parcelles translatées (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ins_parc_23 %>%
            filter(idu %in% translation$idu_translate), 
          layer.name = "Parcelles translatées (état 2023)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(fusion, layer.name = "Parcelles fusionnéees (état 2024)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(supp_tot %>%
            filter(idu %in% unlist(str_split(fusion$participants, ",\\s*"))),  
          layer.name = "Parcelles avant fusion (état 2023)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(subdiv$participants, ",\\s*"))),  
          layer.name = "Parcelles subdivisées (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(subdiv,  layer.name = "Parcelles avant subdivision (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(multi_subdiv$participants_apres, ",\\s*"))),
          layer.name = "Parcelles après multi-subdivision (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(multi_subdiv,  
          layer.name = "Parcelles avant multi-subdivision (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(contour$participants_apres, ",\\s*"))),  
          layer.name = "Parcelles après évolution forme (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(contour,
          layer.name = "Parcelles avant évolution forme (état 2023)",
          col.regions = "purple", alpha.regions = 0.5, homebutton = F) +
  mapview(contour_apres,  
          layer.name = "Parcelles après évolution forme (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ins_parc_23 %>%
            filter(idu %in% contour_apres$idu),  
          layer.name = "Parcelles avant évolution forme (état 2023)", 
          col.regions = "purple", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(contour_transfo$participants_apres, ",\\s*"))),  
          layer.name = "Parcelles ayant transfo + évolution forme (état 2024)",
          alpha.regions = 0.5, homebutton = F) +
  mapview(contour_transfo,
          layer.name = "Parcelles ayant transfo + évolution forme (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(contour_translation,  
          layer.name = "Parcelles ayant translatées + évolution forme (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ins_parc_23 %>%
            filter(idu %in% contour_translation$idu_translate),
          layer.name = "Parcelles ayant translatées + évolution forme (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(contour_fusion_translation,  
          layer.name = "Parcelles ayant translatées + évolution forme + fusion (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% contour_fusion_translation$participants_apres_multi_translate),
          layer.name = "Parcelles ayant translatées + évolution forme + fusion (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(com_abs_apres,  layer.name = "Parcelles après fusion de communes (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(com_abs_avant,  layer.name = "Parcelles avant fusion de communes (état 2023)", 
          col.regions = "purple", alpha.regions = 0.5, homebutton = F) +
  mapview(vrai_ajout, layer.name = "Parcelles véritablement ajoutées", 
          col.regions = "green", alpha.regions = 0.5, homebutton = F) +
  mapview(vrai_supp, layer.name = "Parcelles véritablement supprimées",
          col.regions = "red", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout, z = c("iou_ajust"), layer.name = "Parcelles restantes (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(supp, z = c("iou_multi"), layer.name = "Parcelles restantes (état 2023)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(modif_apres, z = c("iou_ajust"), 
          layer.name = "Parcelles modifiées restantes (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(modif_avant, z = c("iou_ajust"), 
          layer.name = "Parcelles modifiées restantes (état 2023)", 
          alpha.regions = 0.5, homebutton = F)

mapshot(map, url = "parcelles_iou_inside_bordure_85.html")
```

# Tableau de comparaison de superficie entre les deux années

```{r evolution superficie}
evol_sup <- modif %>% 
  mutate(superficie_apres = st_area(geometry_apres),
         superficie_avant = st_area(geometry_avant)) %>% 
  group_by(code_com) %>% 
  summarise(modif_superficie_apres = round(sum(superficie_apres),2),
            modif_superficie_avant = round(sum(superficie_avant),2),
            modif_evolution_superficie = modif_superficie_apres - modif_superficie_avant)

ajout_sup <- ajout %>% 
  mutate(superficie = st_area(geometry)) %>% 
  group_by(code_com) %>% 
  summarise(superficie_ajoute = round(sum(superficie),2)) %>% 
  st_drop_geometry()

supp_sup <- supp %>% 
  mutate(superficie = st_area(geometry)) %>% 
  group_by(code_com) %>% 
  summarise(superficie_supprime = round(sum(superficie),2)) %>% 
  st_drop_geometry()

evol_sup <- evol_sup %>% 
  full_join(ajout_sup, by = "code_com") %>% 
  full_join(supp_sup, by = "code_com") %>% 
  mutate(across(everything(), ~ replace_na(.x, units::set_units(0, m*m)))) %>% 
  mutate(tot_evolution_superficie = round(modif_evolution_superficie + superficie_ajoute - superficie_supprime,2))
```

