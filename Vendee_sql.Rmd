---
title: "Vendée_sql 2024-2023"
output: html_document
date: "2024-06-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

# Import package + fonction utilisés après

```{r package message=FALSE, warning=FALSE}
library(sf)
library(dplyr)
library(mapview)
library(DBI)
library(ggplot2)
library(webshot)
# webshot::install_phantomjs()
source(file = "connexion_db.R")
conn <- connecter()
DBI::dbListTables(conn)
```

```{r fonction sql}

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou(geometry_avant geometry, geometry_apres geometry)
  RETURNS numeric AS $$
  DECLARE
      intersection geometry;
      aire_intersection numeric;
      geom_union geometry;
      aire_union numeric;
      iou numeric;
  BEGIN
      -- Vérifier si les géométries ne sont pas vides
      IF NOT ST_IsEmpty(geometry_avant) AND NOT ST_IsEmpty(geometry_apres) THEN
          intersection := ST_Intersection(geometry_avant, geometry_apres);
        
          -- Si l'intersection est vide, IoU = 0
          IF ST_IsEmpty(intersection) THEN
              RETURN 0;
          END IF;
        
          aire_intersection := ST_Area(intersection);
          geom_union := ST_Union(geometry_avant, geometry_apres);
          aire_union := ST_Area(geom_union);
        
          -- Calculer l'IoU
          iou := aire_intersection / aire_union;
          RETURN iou;
      ELSE
          RETURN NULL;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
")

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_ajust(geometry_avant geometry, geometry_apres geometry)
  RETURNS numeric AS $$
  DECLARE
      centroid_apres geometry;
      centroid_avant geometry;
      translation_vector_x double precision;
      translation_vector_y double precision;
      geometry_avant_ajust geometry;
      iou_ajust numeric;
  BEGIN
      -- Vérifier si les géométries ne sont pas vides
      IF NOT ST_IsEmpty(geometry_avant) AND NOT ST_IsEmpty(geometry_apres) THEN
          centroid_apres := ST_Centroid(geometry_apres);
          centroid_avant := ST_Centroid(geometry_avant);
          translation_vector_x := ST_X(centroid_apres) - ST_X(centroid_avant);
          translation_vector_y := ST_Y(centroid_apres) - ST_Y(centroid_avant);
          
          -- Calculer la géométrie avant ajustée en utilisant ST_Translate
          geometry_avant_ajust := ST_Translate(geometry_avant, translation_vector_x, translation_vector_y);
          
          -- Calculer l'IoU ajusté avec la géométrie avant ajustée
          iou_ajust := calcul_iou(geometry_avant_ajust, geometry_apres);
          
          RETURN iou_ajust;
      ELSE
          RETURN NULL;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
")

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_intersec(polygon geometry, ajout_table_name text)
  RETURNS TABLE (iou numeric, participants text) AS $$
  DECLARE
      parcelles_intersectant RECORD;
      nom_participants text := '';
      union_parcelles geometry;
      query_text text;
      first boolean := true;
  BEGIN
      -- Sélectionner les parcelles intersectant avec le polygon
      query_text := '
          SELECT idu
          FROM ' || quote_ident(ajout_table_name) || '
          WHERE ST_Intersects(st_buffer($1, -1), geometry)
      ';
      
      FOR parcelles_intersectant IN EXECUTE query_text USING polygon
      LOOP
          IF first THEN
              nom_participants := parcelles_intersectant.idu::text;
              first := false;  -- Après le premier cas, mettre à jour la variable
          ELSE
              nom_participants := nom_participants || ', ' || parcelles_intersectant.idu::text;
          END IF;
      END LOOP;
      
      -- Si aucun résultat, retourner NULL
      IF nom_participants = '' THEN
          RETURN QUERY SELECT NULL::numeric, NULL::text;
          RETURN;  -- Terminer la fonction immédiatement
      END IF;
      
      -- Calculer l'union des parcelles intersectant
      query_text := '
          SELECT ST_Union(geometry)
          FROM ' || quote_ident(ajout_table_name) || '
          WHERE idu IN (
              SELECT idu
              FROM ' || quote_ident(ajout_table_name) || '
              WHERE ST_Intersects(st_buffer($1, -1), geometry)
          )
      ';

      -- Calculer l'union des parcelles intersectant
      EXECUTE query_text INTO union_parcelles USING polygon;
      
      -- Calculer l'IoU avec l'union des parcelles et le polygon
      RETURN QUERY SELECT calcul_iou(union_parcelles, polygon), nom_participants;
  END;
  $$ LANGUAGE plpgsql;
")

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_multi(polygon geometry, supp_table_name text, ajout_table_name text)
  RETURNS TABLE (iou_multi numeric, participants_avant text, participants_apres text) AS $$
  DECLARE
      n integer := 0;
      k integer := 0;
      nom_participants_avant text;
      polygon_maj geometry;
      iou_intersect RECORD;
      query_sql text;
      
  BEGIN
      -- Initialiser le polygon_maj avec la géométrie de départ
      polygon_maj := polygon;
  
      -- Boucle pour trouver les intersections dans supp
      LOOP
          -- Mettre à jour polygon_maj avec l'union des géométries de supp
          EXECUTE '
            SELECT ST_Union(geometry) 
            FROM ' || quote_ident(supp_table_name) || ' 
            WHERE ST_Intersects(geometry, $1)
        ' INTO polygon_maj USING polygon_maj;
  
          -- Sortir de la boucle si le nombre de parcelles reste le même
          query_sql := '
            SELECT COUNT(*) 
            FROM ' || quote_ident(supp_table_name) || ' 
            WHERE ST_Intersects(geometry, $1)';
        
          EXECUTE query_sql INTO k USING polygon_maj;
          
          EXIT WHEN n = k;
  
          -- Mettre à jour le nombre de parcelles
          n := k;
      END LOOP;
  
      -- Sélectionner les noms des participants avant
      query_sql := '
        SELECT string_agg(idu::text, '', '') 
        FROM ' || quote_ident(supp_table_name) || ' 
        WHERE ST_Intersects(geometry, $1)';
    
      EXECUTE query_sql INTO nom_participants_avant USING polygon_maj;
  
      -- Calculer l'IoU intersection avec ajout
      SELECT * INTO iou_intersect
      FROM calcul_iou_intersec(polygon_maj, ajout_table_name);  -- Utilisez le nom de votre table ajout
  
      -- Retourner les résultats
      RETURN QUERY SELECT iou_intersect.iou, nom_participants_avant, iou_intersect.participants;
  END;
  $$ LANGUAGE plpgsql;
")

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_intersec_translate(polygon geometry, ajout_table text)
  RETURNS TABLE (iou_ajust numeric, idu_translate text) AS $$
  DECLARE
      parcelle RECORD;
      max_iou numeric := NULL;
      iou_value numeric;
      query_text text;
  BEGIN
      -- Construire la requête pour sélectionner les parcelles intersectant avec la zone tampon de polygon
      query_text := '
          SELECT idu, geometry
          FROM ' || quote_ident(ajout_table) || '
          WHERE ST_Intersects(geometry, ST_Buffer($1, -1))
      ';
      
      -- Sélectionner les parcelles intersectant avec la zone tampon de polygon
      FOR parcelle IN EXECUTE query_text USING polygon
      LOOP
          -- Calculer l'IoU entre la parcelle courante et polygon
          BEGIN
              iou_value := calcul_iou(parcelle.geometry, polygon);
          EXCEPTION WHEN others THEN
              iou_value := NULL; -- Ignorer les erreurs de calcul d'IoU
          END;
          
          -- Mettre à jour si on trouve un IoU plus élevé
          IF max_iou IS NULL OR iou_value > max_iou THEN
              max_iou := iou_value;
              idu_translate := parcelle.idu;
          END IF;
      END LOOP;
      
      -- Si aucune parcelle intersecte, retourner NA
      IF max_iou IS NULL THEN
          RETURN QUERY SELECT NULL::numeric, NULL::text;
      END IF;
      
      query_text := '
          SELECT geometry
          FROM ' || quote_ident(ajout_table) || '
          WHERE idu = $1
      ';
      
      -- Calculer l'IoU ajusté avec la meilleure parcelle trouvée
      EXECUTE query_text INTO parcelle.geometry USING idu_translate;
      iou_ajust := calcul_iou_ajust(parcelle.geometry, polygon);
      
      -- Retourner les résultats
      RETURN QUERY SELECT iou_ajust, idu_translate;
  END;
  $$ LANGUAGE plpgsql;
")

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_multi_translate(polygon geometry, supp_table_name text, ajout_table_name text)
  RETURNS TABLE (iou_multi_translate numeric, participants_avant_multi_translate text, participants_apres_multi_translate text) AS $$
  DECLARE
      n integer := 0;
      polygon_maj geometry := polygon;
      nom_participants_avant text := '';
      iou_intersect RECORD;
      query_text text;
      current_n integer := 0;
  BEGIN
      -- Boucle pour mettre à jour polygon_maj avec l'union des géométries dans supp
      LOOP
          -- Construire la requête pour sélectionner les parcelles dans supp qui intersectent avec polygon_maj
          query_text := '
              SELECT ST_Union(geometry)
              FROM ' || quote_ident(supp_table_name) || '
              WHERE ST_Intersects(geometry, $1)
          ';
          EXECUTE query_text INTO polygon_maj USING polygon_maj;
  
          -- Mettre à jour le nombre de parcelles
          query_text := '
              SELECT COUNT(*)
              FROM ' || quote_ident(supp_table_name) || '
              WHERE ST_Intersects(geometry, $1)
          ';
          EXECUTE query_text INTO current_n USING polygon_maj;
  
          -- Condition de sortie : le nombre de parcelles reste le même
          EXIT WHEN n = current_n;
  
          -- Mettre à jour n pour la prochaine itération
          n := current_n;
      END LOOP;
  
      -- Sélectionner les noms des participants avant
      query_text := '
          SELECT string_agg(idu::text, '', '')
          FROM ' || quote_ident(supp_table_name) || '
          WHERE ST_Intersects(geometry, $1)
      ';
      EXECUTE query_text INTO nom_participants_avant USING polygon_maj;
  
      -- Calculer l'IoU intersection ajusté avec ajout
      EXECUTE 'SELECT * FROM calcul_iou_intersec_translate($1, $2)' INTO iou_intersect USING polygon_maj, ajout_table_name;
  
      -- Retourner les résultats
      RETURN QUERY SELECT iou_intersect.iou_ajust AS iou, nom_participants_avant AS participants_avant, iou_intersect.idu_translate AS participants_apres;
  END;
  $$ LANGUAGE plpgsql;
")

```

```{r voir les index}
dbGetQuery(conn, " SELECT 
    tablename, 
    indexname, 
    indexdef 
FROM 
    pg_indexes 
WHERE 
    schemaname LIKE 'pg_temp_%' 
    OR schemaname = 'public';
           ")
```

```{r voir les tables temporaires}
dbGetQuery(conn, " SELECT 
    schemaname AS schema_name,
    tablename AS table_name
FROM 
    pg_tables
WHERE 
    schemaname LIKE 'pg_temp_%'
ORDER BY 
    schemaname, tablename;
           ")
```

```{r supprimer toutes les tables temporaires}

# Exécution de la requête pour obtenir les noms des tables temporaires
tables_temporaires <- dbGetQuery(conn, "
  SELECT 
      tablename
  FROM 
      pg_tables
  WHERE 
      schemaname LIKE 'pg_temp_%';
")

# Générer les commandes de suppression
drop_queries <- lapply(tables_temporaires$tablename, function(table) {
    paste("DROP TABLE IF EXISTS", table, "CASCADE;")
})

# Exécution des commandes de suppression
for (query in drop_queries) {
    dbExecute(conn, query)
}
```

# Importation des parcelles sur l'ensemble du département et des périodes données

```{r ajout/supp_tot sql}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_tot, supp_tot CASCADE;")
dbExecute(conn, "
  CREATE TEMP TABLE ajout_tot AS
  SELECT * 
  FROM parc_85_24
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_85_23 
    WHERE parc_85_24.idu = parc_85_23.idu
  );
")

dbExecute(conn, "
  CREATE TEMP TABLE supp_tot AS
  SELECT * 
  FROM parc_85_23
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_85_24
    WHERE parc_85_23.idu = parc_85_24.idu
  );
")

dbExecute(conn, "CREATE INDEX idx_ajout_tot_geometry ON ajout_tot USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX idx_supp_tot_geometry ON supp_tot USING GIST(geometry);")

```

```{r import commune}
commune <- st_read(conn, query = "SELECT * FROM com_85;")

ajout_tot <- st_read(conn, query = "SELECT * FROM ajout_tot;")
supp_tot <- st_read(conn, query = "SELECT * FROM supp_tot;")
```


# Définition de la bordure dans laquelle je considère que mes parcelles doivent apartenir entièrement

```{r creation inside bordure}
dbExecute(conn, "DROP TABLE IF EXISTS bordure, ins_parc_24, ins_parc_23, ajout, supp CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE bordure AS
  SELECT
      code_insee, nom_com, code_dep,
      ST_Difference(ST_Buffer(geometry, 250), ST_Buffer(geometry, -250)) AS geometry
  FROM
      com_85;
")

dbExecute(conn, "CREATE INDEX idx_bordure_geometry ON bordure USING GIST(geometry);")

dbExecute(conn, "
  CREATE TEMP TABLE ins_parc_24 AS
  SELECT DISTINCT
      parc_85_24.*
  FROM
      parc_85_24
  JOIN
      bordure
  ON
      ST_WITHIN(parc_85_24.geometry, bordure.geometry);
")

dbExecute(conn, "
  CREATE TEMP TABLE ins_parc_23 AS
  SELECT DISTINCT
      parc_85_23.*
  FROM
      parc_85_23
  JOIN
      bordure
  ON
      ST_WITHIN(parc_85_23.geometry, bordure.geometry);
")

dbExecute(conn, "
  CREATE TEMP TABLE ajout AS
  SELECT DISTINCT
      ajout_tot.*
  FROM
      ajout_tot
  JOIN
      bordure
  ON
      ST_WITHIN(ajout_tot.geometry, bordure.geometry)
  ORDER BY ajout_tot.nom_com;
")

dbExecute(conn, "
  CREATE TEMP TABLE supp AS
  SELECT DISTINCT
      supp_tot.*
  FROM
      supp_tot
  JOIN
      bordure
  ON
      ST_WITHIN(supp_tot.geometry, bordure.geometry)
  ORDER BY supp_tot.nom_com;
")

dbExecute(conn, "CREATE INDEX idx_ajout_geometry ON ajout USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX idx_supp_geometry ON supp USING GIST(geometry);")
```

```{r creation sans bordure}
dbExecute(conn, "DROP TABLE IF EXISTS bordure, ins_parc_24, ins_parc_23, ajout, supp CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE bordure AS
  SELECT
      code_insee, nom_com, code_dep,
      ST_Difference(ST_Buffer(geometry, 250), ST_Buffer(geometry, -250)) AS geometry
  FROM
      com_85;
")

dbExecute(conn, "CREATE INDEX idx_bordure_geometry ON bordure USING GIST(geometry);")

dbExecute(conn, "
  CREATE TEMP TABLE ins_parc_24 AS
  SELECT DISTINCT
      parc_85_24.*
  FROM
      parc_85_24;
")

dbExecute(conn, "
  CREATE TEMP TABLE ins_parc_23 AS
  SELECT DISTINCT
      parc_85_23.*
  FROM
      parc_85_23;
")

dbExecute(conn, "
  CREATE TEMP TABLE ajout AS
  SELECT DISTINCT
      ajout_tot.*
  FROM
      ajout_tot
  ORDER BY ajout_tot.nom_com;
")

dbExecute(conn, "
  CREATE TEMP TABLE supp AS
  SELECT DISTINCT
      supp_tot.*
  FROM
      supp_tot
  ORDER BY supp_tot.nom_com;
")

dbExecute(conn, "CREATE INDEX idx_ajout_geometry ON ajout USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX idx_supp_geometry ON supp USING GIST(geometry);")
```


```{r bordure sql}
bordure <- st_read(conn, query = "SELECT * FROM bordure;") %>%
  mutate(geometry = st_cast(geometry, "MULTIPOLYGON"))

ins_parc_24 <- st_read(conn, query = "SELECT * FROM ins_parc_24;")
ins_parc_23 <- st_read(conn, query = "SELECT * FROM ins_parc_23;")

dbExecute(conn, "DROP TABLE IF EXISTS bordure;")
```

# Focus sur les parcelles dont je peux comparer l'état sur les deux périodes facilement (cad parcelles ayant conservé leur identifiant)

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r modif geometry egal sql}
dbExecute(conn, "DROP TABLE IF EXISTS identique, modif_apres, modif_avant, modif;")

dbExecute(conn, "
  CREATE TEMP TABLE identique AS
  SELECT ins_parc_24.*
  FROM ins_parc_24
  WHERE NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE ins_parc_24.idu = ajout.idu
  )
  AND EXISTS (
      SELECT 1
      FROM ins_parc_23 
      WHERE ins_parc_24.idu = ins_parc_23.idu
      AND ST_Equals(ins_parc_24.geometry, ins_parc_23.geometry)
  );
")

dbExecute(conn, "
  CREATE TEMP TABLE modif_apres AS
  SELECT ins_parc_24.*
  FROM ins_parc_24
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE ins_parc_24.idu = identique.idu
  )
  AND NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE ins_parc_24.idu = ajout.idu
  )
  ORDER BY ins_parc_24.nom_com;
")

dbExecute(conn, "
  CREATE TEMP TABLE modif_avant AS
  SELECT ins_parc_23.*
  FROM ins_parc_23
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE ins_parc_23.idu = identique.idu
  )
  AND NOT EXISTS (
      SELECT 1
      FROM supp
      WHERE ins_parc_23.idu = supp.idu
  )
  ORDER BY ins_parc_23.nom_com;
")

dbExecute(conn, "
  CREATE TEMP TABLE modif AS
  SELECT
      COALESCE(avant.idu, apres.idu) AS idu,
      apres.geometry AS geometry_apres,
      avant.geometry AS geometry_avant,
      calcul_iou(apres.geometry, avant.geometry) AS iou,
      calcul_iou_ajust(apres.geometry, avant.geometry) AS iou_ajust
  FROM
      modif_avant avant
  FULL JOIN
      modif_apres apres ON avant.idu = apres.idu;
")

dbExecute(conn, "DROP TABLE IF EXISTS identique;")
```

```{r drop iou null sql}
dbExecute(conn, "
  DELETE FROM modif
  WHERE iou > 0.99 OR iou IS NULL;
")
```


```{r quantile}

# 85130000AH0055 et 85130000AH0017 supplémentaire dans sql
#modif <- st_read(conn, query = "SELECT * FROM modif;")

# Elimine les parcelles "sans changement manifeste" plus les parcelles sans iou = parcelles n'étant plus entièrement dans la bordure lors d'un changement d'une année sur l'autre

# quantiles <- quantile(modif$iou_ajust, probs = c(0.01, 0.03, 0.05, 0.1), na.rm = TRUE)
```

## Reconnaissances des cas de translation, modification de contour et les deux à la fois

```{r translation, contour_apres, contour_translation}
dbExecute(conn, "DROP TABLE IF EXISTS modif_apres_iou, modif_avant_iou, 
          translation, contour_apres, contour_translation;")

dbExecute(conn, "
  CREATE TEMP TABLE modif_apres_iou AS
  SELECT modif_apres.*, modif.iou, modif.iou_ajust
  FROM modif
  LEFT JOIN modif_apres ON modif.idu = modif_apres.idu;
")

dbExecute(conn, "
  CREATE TEMP TABLE modif_avant_iou AS
  SELECT modif_avant.*, modif.iou, modif.iou_ajust
  FROM modif
  LEFT JOIN modif_avant ON modif.idu = modif_avant.idu;
")

dbExecute(conn, "
  CREATE TEMP TABLE translation AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         idu AS idu_translate
  FROM modif_apres_iou
  WHERE iou_ajust > 0.99;
")

dbExecute(conn, "
  CREATE TEMP TABLE contour_apres AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         iou AS iou_multi,
         idu AS participants_avant,
         idu AS participants_apres
  FROM modif_apres_iou
  WHERE iou > 0.95 AND iou_ajust < 0.99;
")

dbExecute(conn, "DROP TABLE IF EXISTS contour_translation;")
dbExecute(conn, "
  CREATE TEMP TABLE contour_translation AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         idu AS idu_translate
  FROM modif_apres_iou
  WHERE iou < 0.95 AND iou_ajust > 0.95 AND iou_ajust < 0.99;
")

dbExecute(conn, "
  DELETE FROM modif_apres_iou
  WHERE idu IN (SELECT idu FROM translation)
    OR idu IN (SELECT idu FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbExecute(conn, "
  DELETE FROM modif_avant_iou
  WHERE idu IN (SELECT idu FROM translation)
    OR idu IN (SELECT idu FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")
```

## Cas plus compliqués de détection des mêmes cas

```{r meme cas sql}
dbExecute(conn, "DROP TABLE IF EXISTS modif_apres_iou_multi;")
dbExecute(conn, "
  CREATE TEMP TABLE modif_apres_iou_multi AS
  SELECT modif_apres_iou.*, 
    (calcul_iou_multi(modif_apres_iou.geometry, 'modif_apres_iou' , 'modif_avant_iou')).*
  FROM modif_apres_iou;
")

dbExecute(conn, "
  INSERT INTO contour_apres
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         iou_multi, participants_avant,participants_apres
  FROM modif_apres_iou_multi
  WHERE (iou_multi > 0.95 AND LENGTH(participants_avant) = LENGTH(participants_apres))
     OR (LENGTH(participants_avant) = 14 AND LENGTH(participants_apres) = 14 AND iou > iou_ajust);
")

dbExecute(conn, "
  INSERT INTO contour_translation
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry, 
         idu AS idu_translate
  FROM modif_apres_iou_multi
  WHERE ((LENGTH(participants_avant) = 14 AND LENGTH(participants_apres) = 14 AND iou < iou_ajust))
     OR iou_multi IS NULL;
")

dbExecute(conn, "
  DELETE FROM modif_apres_iou_multi
  WHERE idu IN (SELECT idu FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbExecute(conn, "
  DELETE FROM modif_avant_iou
  WHERE idu IN (SELECT idu FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")
```


```{r modif iou_multi -> translation, modification de contour et les deux à la fois bis}

contour_apres_sql <- st_read(conn, query = "SELECT * FROM contour_apres;")

modif_apres_sql <- st_read(conn, query = "SELECT * FROM modif_apres_iou_multi;")
modif_avant_sql <- st_read(conn, query = "SELECT * FROM modif_avant_iou;")
```

# Focus des parcelles ayant changé de communes

## Cas des parcelles dans le cas d'une fusion de communes

```{r ajout/supp -> focus fusion commune}
dbExecute(conn, "DROP TABLE IF EXISTS com_abs_apres, com_abs_avant;")

dbExecute(conn, "
  CREATE TEMP TABLE com_abs_apres AS
  SELECT *,
         SUBSTR(idu, 1, 2) || com_abs || '000' || SUBSTR(idu, 9, 14) AS idu_avant
  FROM ajout
  WHERE com_abs != '000';
")

dbExecute(conn, "
  CREATE TEMP TABLE com_abs_avant AS
  SELECT *
  FROM supp
  WHERE idu IN (SELECT idu_avant FROM com_abs_apres);
")

dbExecute(conn, "
  DELETE FROM com_abs_apres
  WHERE idu_avant NOT IN (SELECT idu FROM com_abs_avant);
")

# Parcelles n'ayant pas été modifiées mise à part le nom de commune
```

```{r parcelle changeant de communes}
com_abs_apres_sql <- st_read(conn, query = "SELECT * FROM com_abs_apres;")
com_abs_avant_sql <- st_read(conn, query = "SELECT * FROM com_abs_avant;")
```

# Focus parcelles avec changement "majeur" lié à un changement impactant l'identifiant des parcelles

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r ajout/supp geometry egal}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_identique, supp_identique CASCADE;")

# Parcelles ajoutées n'ayant pas été modifiées
dbExecute(conn, "
  CREATE TEMP TABLE ajout_identique AS
  SELECT ajout.*
  FROM ajout
  JOIN supp ON ST_Equals(ajout.geometry, supp.geometry)
")

# Parcelles supprimées n'ayant pas été modifiées
dbExecute(conn, "
  CREATE TEMP TABLE supp_identique AS
  SELECT supp.*
  FROM supp 
  JOIN ajout ON ST_Equals(supp.geometry, ajout.geometry)
")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (SELECT idu FROM ajout_identique);
")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (SELECT idu FROM supp_identique);
")

dbExecute(conn, "DROP TABLE IF EXISTS ajout_identique, supp_identique CASCADE;")
```

## Reconnaissances des cas de fusion (peu fréquent) ou subdivision (plus courant)

```{r ajout/supp iou -> fusion/subdivision}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_iou, supp_iou, fusion, subdiv CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou AS
  SELECT
      supp.*,
      (calcul_iou_intersec(supp.geometry, 'ajout')).*
  FROM
      supp;
")

dbExecute(conn, "
  CREATE TEMP TABLE ajout_iou AS
  SELECT
      ajout.*,
      (calcul_iou_intersec(ajout.geometry, 'supp')).*
  FROM
      ajout;
")

dbExecute(conn, "
  CREATE TEMP TABLE fusion AS
  SELECT *
  FROM ajout_iou
  WHERE iou > 0.99 AND LENGTH(participants) != 14;
")

dbExecute(conn, "
  CREATE TEMP TABLE subdiv AS
  SELECT *
  FROM supp_iou
  WHERE iou > 0.99 AND LENGTH(participants) != 14;
")

dbExecute(conn, "
  DELETE FROM ajout_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants, ',\\s*')) FROM subdiv)
   OR idu IN (SELECT idu FROM fusion)
   OR iou > 0.99;
")

dbExecute(conn, "
  DELETE FROM supp_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants, ',\\s*')) FROM fusion)
    OR idu IN (SELECT idu FROM subdiv)
    OR iou > 0.99;
")

```

```{r fusion/subdivision}
subdiv_sql <- st_read(conn, query = "SELECT * FROM subdiv;")
fusion_sql <- st_read(conn, query = "SELECT * FROM fusion;")
```


## Reconnaissances des cas de multi-subdivision (ex : 2 -> 3) ou modification de contours

```{r ajout/supp iou_multi -> multi-subdivision et contours}
dbExecute(conn, "DROP TABLE IF EXISTS supp_iou_multi, multi_subdiv, contour CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou_multi AS
  SELECT
      supp_iou.*,
      (calcul_iou_multi(supp_iou.geometry, 'supp_iou', 'ajout_iou')).*
  FROM
      supp_iou;
")

dbExecute(conn, "
  CREATE TEMP TABLE multi_subdiv AS
  SELECT *
  FROM supp_iou_multi
  WHERE iou_multi > 0.99 AND LENGTH(participants_apres) != LENGTH(participants_avant);
")

dbExecute(conn, "
  CREATE TEMP TABLE contour AS
  SELECT *
  FROM supp_iou_multi
  WHERE (iou_multi > 0.95 AND LENGTH(participants_apres) = LENGTH(participants_avant))
    OR (LENGTH(participants_apres) = 14 AND LENGTH(participants_avant) = 14);
")

dbExecute(conn, "
  DELETE FROM ajout_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM multi_subdiv)
    OR idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM multi_subdiv)
    OR idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour);
")

```

```{r multisubdiv sql}
multi_subdiv_sql <- st_read(conn, query = "SELECT * FROM multi_subdiv;")
```

## Reconnaissances des cas de modification de contours plus compliquée
# a revoir c est trop long
```{r changement forme + ou découpage compliquée}
dbExecute(conn, "DROP TABLE IF EXISTS supp_iou_multi_bis, contour_transfo CASCADE;")
dbExecute(conn, "
  CREATE TEMP TABLE supp_iou_multi_bis AS
  SELECT
      idu, numero, feuille, section, code_dep, nom_com, code_com, 
      com_abs, code_arr, contenance, geometry, iou, participants,
      (calcul_iou_multi(supp_iou_multi.geometry, 'supp_iou_multi', 'ajout_iou')).*
  FROM
      supp_iou_multi;
")

# Cas d'une parcelle spécial 850040000F0149
dbExecute(conn, "
  INSERT INTO contour
  SELECT *
  FROM supp_iou_multi_bis
  WHERE (LENGTH(participants_avant) = 14 AND LENGTH(participants_apres) = 14)
     OR (iou_multi > 0.95 AND LENGTH(participants_avant) = LENGTH(participants_apres));
")

dbExecute(conn, "
  DELETE FROM ajout_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi_bis
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour);
")

dbExecute(conn, "
  CREATE TEMP TABLE contour_transfo AS
  SELECT *
  FROM supp_iou_multi_bis
  WHERE iou_multi > 0.95;
")

dbExecute(conn, "
  DELETE FROM ajout_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour_transfo);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi_bis
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour_transfo);
")

```

```{r contour avec transfo ou non}
contour_transfo_sql <- st_read(conn, query = "SELECT * FROM contour_transfo;")
contour_sql <- st_read(conn, query = "SELECT * FROM contour;")
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation, modification de contour avec translation

####### A PARTIR D'ICI C'est plus vérifié
```{r ajout/supp iou_ajust -> translation, contour + translation}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_iou_translate CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE ajout_iou_translate AS
  SELECT DISTINCT
      ajout_iou.*,
      (calcul_iou_intersec_translate(ajout_iou.geometry, 'supp_iou_multi')).*
  FROM
      ajout_iou;
")

dbExecute(conn, "
  INSERT INTO translation
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry, idu_translate
  FROM ajout_iou_translate
  WHERE iou_ajust > 0.99;
")

dbExecute(conn, "
  INSERT INTO contour_translation
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry, idu_translate
  FROM ajout_iou_translate
  WHERE (iou_ajust > 0.95 AND iou_ajust < 0.99);
")

dbExecute(conn, "
  DELETE FROM ajout_iou_translate
  WHERE idu IN (SELECT idu FROM translation)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi_bis
  WHERE idu IN (SELECT idu_translate FROM translation)
    OR idu IN (SELECT idu_translate FROM contour_translation);
")

```

```{r contour translation ou translation seule}
contour_translation_sql <- st_read(conn, query = "SELECT * FROM contour_translation;")
translation_sql <- st_read(conn, query = "SELECT * FROM translation;")
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation avec modification de contour et avec fusion

```{r ajout/supp iou_ajust -> contour_fusion_translation}
dbExecute(conn, "DROP TABLE IF EXISTS supp_iou_multi_translate, contour_fusion_translation CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou_multi_translate AS
  SELECT 
      supp_iou_multi_bis.*,
      (calcul_iou_multi_translate(supp_iou_multi_bis.geometry, 'supp_iou_multi_bis', 'ajout_iou_translate')).*
  FROM
      supp_iou_multi_bis;
")

dbExecute(conn, "
  CREATE TEMP TABLE contour_fusion_translation AS
  SELECT *
  FROM supp_iou_multi_translate
  WHERE iou_multi_translate > 0.95;
")

dbExecute(conn, "
  DELETE FROM ajout_iou_translate
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres_multi_translate, ',\\s*')) FROM contour_fusion_translation);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi_translate
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant_multi_translate, ',\\s*')) FROM contour_fusion_translation);
")

```

```{r contour_fusion_translation}
contour_fusion_translation_sql <- st_read(conn, query = "SELECT * FROM contour_fusion_translation;")
```

## Recalcul de l'IoU pour détecter les parcelles maintenant isolées -> Véritable ajout ou suppression

```{r le reste}
dbExecute(conn, "DROP TABLE IF EXISTS supp_iou_restant, ajout_iou_restant, 
          vrai_ajout, vrai_supp CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou_restant AS
  SELECT
      idu, numero, feuille, section, code_dep, nom_com, code_com, 
      com_abs, code_arr, contenance, geometry, iou_multi, participants_avant, participants_apres, 
      iou_multi_translate, participants_avant_multi_translate, participants_apres_multi_translate,
      (calcul_iou_intersec(supp_iou_multi_translate.geometry, 'ajout_iou_translate')).* 
  FROM
      supp_iou_multi_translate;
")

dbExecute(conn, "
  CREATE TEMP TABLE ajout_iou_restant AS
  SELECT
      idu, numero, feuille, section, code_dep, nom_com, code_com, 
      com_abs, code_arr, contenance, geometry, iou_ajust, idu_translate,
      (calcul_iou_intersec(ajout_iou_translate.geometry, 'supp_iou_multi_translate')).*
  FROM
      ajout_iou_translate;
")

dbExecute(conn, "
  CREATE TEMP TABLE vrai_ajout AS
  SELECT *
  FROM ajout_iou_restant
  WHERE iou IS NULL;
")

dbExecute(conn, "
  CREATE TEMP TABLE vrai_supp AS
  SELECT *
  FROM supp_iou_restant
  WHERE iou IS NULL;
")

dbExecute(conn, "
  DELETE FROM ajout_iou_restant
  WHERE idu IN (SELECT idu FROM vrai_ajout);
")

dbExecute(conn, "
  DELETE FROM supp_iou_restant
  WHERE idu IN (SELECT idu FROM vrai_supp);
")
```


```{r le reste}
ajout_sql <- st_read(conn, query = "SELECT * FROM ajout_iou_restant;")
supp_sql <- st_read(conn, query = "SELECT * FROM supp_iou_restant;")

vrai_ajout_sql <- st_read(conn, query = "SELECT * FROM vrai_ajout;")
vrai_supp_sql <- st_read(conn, query = "SELECT * FROM vrai_supp;")
```

# Visualisation finale sur une carte du département

```{r mapview typologie parcelles, eval=FALSE, include=FALSE}
map <- mapview(commune, layer.name = "Communes", col.regions = "white", 
               alpha.regions = 0.5, homebutton = F) +
  mapview(bordure, layer.name = "Bordures étendues", col.regions = "lightblue", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(translation_sql,
          layer.name = "Parcelles translatées (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ins_parc_23 %>%
            filter(idu %in% translation_sql$idu_translate), 
          layer.name = "Parcelles translatées (état 2023)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(fusion_sql, layer.name = "Parcelles fusionnéees (état 2024)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(supp_tot %>%
            filter(idu %in% unlist(str_split(fusion_sql$participants, ",\\s*"))),  
          layer.name = "Parcelles avant fusion (état 2023)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(subdiv_sql$participants, ",\\s*"))),  
          layer.name = "Parcelles subdivisées (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(subdiv_sql,  layer.name = "Parcelles avant subdivision (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(multi_subdiv_sql$participants_apres, ",\\s*"))),
          layer.name = "Parcelles après multi-subdivision (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(multi_subdiv_sql,  
          layer.name = "Parcelles avant multi-subdivision (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(contour_sql$participants_apres, ",\\s*"))),  
          layer.name = "Parcelles après évolution forme (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(contour_sql,
          layer.name = "Parcelles avant évolution forme (état 2023)",
          col.regions = "purple", alpha.regions = 0.5, homebutton = F) +
  mapview(contour_apres_sql,  
          layer.name = "Parcelles après évolution forme (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ins_parc_23 %>%
            filter(idu %in% contour_apres_sql$idu),  
          layer.name = "Parcelles avant évolution forme (état 2023)", 
          col.regions = "purple", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% unlist(str_split(contour_transfo_sql$participants_apres, ",\\s*"))),  
          layer.name = "Parcelles ayant transfo + évolution forme (état 2024)",
          alpha.regions = 0.5, homebutton = F) +
  mapview(contour_transfo_sql,
          layer.name = "Parcelles ayant transfo + évolution forme (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(contour_translation_sql,  
          layer.name = "Parcelles ayant translatées + évolution forme (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ins_parc_23 %>%
            filter(idu %in% contour_translation_sql$idu_translate),
          layer.name = "Parcelles ayant translatées + évolution forme (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(contour_fusion_translation_sql,  
          layer.name = "Parcelles ayant translatées + évolution forme + fusion (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_tot %>%
            filter(idu %in% contour_fusion_translation_sql$participants_apres_multi_translate),
          layer.name = "Parcelles ayant translatées + évolution forme + fusion (état 2023)", 
          col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
  mapview(com_abs_apres_sql,  layer.name = "Parcelles après fusion de communes (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(com_abs_avant_sql,  layer.name = "Parcelles avant fusion de communes (état 2023)", 
          col.regions = "purple", alpha.regions = 0.5, homebutton = F) +
  mapview(vrai_ajout_sql, layer.name = "Parcelles véritablement ajoutées", 
          col.regions = "green", alpha.regions = 0.5, homebutton = F) +
  mapview(vrai_supp_sql, layer.name = "Parcelles véritablement supprimées",
          col.regions = "red", alpha.regions = 0.5, homebutton = F) +
  mapview(ajout_sql, z = c("iou_ajust"), layer.name = "Parcelles restantes (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(supp_sql, z = c("iou_multi"), layer.name = "Parcelles restantes (état 2023)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(modif_apres_sql, z = c("iou_ajust"), 
          layer.name = "Parcelles modifiées restantes (état 2024)", 
          alpha.regions = 0.5, homebutton = F) +
  mapview(modif_avant_sql, z = c("iou_ajust"), 
          layer.name = "Parcelles modifiées restantes (état 2023)", 
          alpha.regions = 0.5, homebutton = F)

mapshot(map, url = "parcelles_iou_85_sql.html")
```

