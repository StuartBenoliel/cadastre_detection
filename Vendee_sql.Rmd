---
title: "Vendée_sql 2024-2023"
output: html_document
date: "2024-06-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

# Import package + fonction utilisés après

```{r package message=FALSE, warning=FALSE}
library(sf)
library(dplyr)
library(mapview)
library(DBI)
library(ggplot2)
library(webshot)
library(stringr)
# webshot::install_phantomjs()
source(file = "connexion_db.R")
conn <- connecter()
DBI::dbListTables(conn)
dbExecute(conn, "SET client_min_messages TO NOTICE;")

indic_bordure <- F
num_departement <- 85
temps_apres <- 23
temps_avant <- 22
```

```{r fonction sql}

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou(geometry_avant geometry, geometry_apres geometry)
  RETURNS numeric AS $$
  DECLARE
      intersection geometry;
      aire_intersection numeric;
      geom_union geometry;
      aire_union numeric;
      iou numeric;
  BEGIN
      -- Vérifier si les géométries ne sont pas vides
      IF NOT ST_IsEmpty(geometry_avant) AND NOT ST_IsEmpty(geometry_apres) THEN
          intersection := ST_Intersection(geometry_avant, geometry_apres);
        
          -- Si l'intersection est vide, IoU = 0
          IF ST_IsEmpty(intersection) THEN
              RETURN 0;
          END IF;
        
          aire_intersection := ST_Area(intersection);
          geom_union := ST_Union(geometry_avant, geometry_apres);
          aire_union := ST_Area(geom_union);
        
          -- Calculer l'IoU
          iou := aire_intersection / aire_union;
          RETURN iou;
      ELSE
          RETURN NULL;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
")

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_ajust(geometry_avant geometry, geometry_apres geometry)
  RETURNS numeric AS $$
  DECLARE
      centroid_apres geometry;
      centroid_avant geometry;
      translation_vector_x double precision;
      translation_vector_y double precision;
      geometry_avant_ajust geometry;
      iou_ajust numeric;
  BEGIN
      -- Vérifier si les géométries ne sont pas vides
      IF NOT ST_IsEmpty(geometry_avant) AND NOT ST_IsEmpty(geometry_apres) THEN
          centroid_apres := ST_Centroid(geometry_apres);
          centroid_avant := ST_Centroid(geometry_avant);
          translation_vector_x := ST_X(centroid_apres) - ST_X(centroid_avant);
          translation_vector_y := ST_Y(centroid_apres) - ST_Y(centroid_avant);
          
          -- Calculer la géométrie avant ajustée en utilisant ST_Translate
          geometry_avant_ajust := ST_Translate(geometry_avant, translation_vector_x, translation_vector_y);
          
          -- Calculer l'IoU ajusté avec la géométrie avant ajustée
          iou_ajust := calcul_iou(geometry_avant_ajust, geometry_apres);
          
          RETURN iou_ajust;
      ELSE
          RETURN NULL;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
")

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_intersec(polygon geometry, ajout_table_name text)
  RETURNS TABLE (iou numeric, participants text) AS $$
  DECLARE
      parcelles_intersectant RECORD;
      nom_participants text := '';
      union_parcelles geometry;
      query_sql text;
      first boolean := true;
  BEGIN
      -- Sélectionner les parcelles intersectant avec le polygon
      query_sql := '
          SELECT idu
          FROM ' || quote_ident(ajout_table_name) || '
          WHERE ST_Intersects(st_buffer($1, -0.1), geometry)
      ';
      
      FOR parcelles_intersectant IN EXECUTE query_sql USING polygon
      LOOP
          IF first THEN
              nom_participants := parcelles_intersectant.idu::text;
              first := false;  -- Après le premier cas, mettre à jour la variable
          ELSE
              nom_participants := nom_participants || ', ' || parcelles_intersectant.idu::text;
          END IF;
      END LOOP;
      
      -- Si aucun résultat, retourner NULL
      IF nom_participants = '' THEN
          RETURN QUERY SELECT NULL::numeric, NULL::text;
          RETURN;  -- Terminer la fonction immédiatement
      END IF;
      
      -- Calculer l'union des parcelles intersectant
      query_sql := '
          SELECT ST_Union(geometry)
          FROM ' || quote_ident(ajout_table_name) || '
          WHERE idu IN (
              SELECT idu
              FROM ' || quote_ident(ajout_table_name) || '
              WHERE ST_Intersects(st_buffer($1, -1), geometry)
          )
      ';

      -- Calculer l'union des parcelles intersectant
      EXECUTE query_sql INTO union_parcelles USING polygon;
      
      -- Calculer l'IoU avec l'union des parcelles et le polygon
      RETURN QUERY SELECT calcul_iou(union_parcelles, polygon), nom_participants;
  END;
  $$ LANGUAGE plpgsql;
")

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_multi(idu text, polygon geometry, supp_table_name text, ajout_table_name text)
  RETURNS TABLE (iou_multi numeric, participants_avant text, participants_apres text) AS $$
  DECLARE
      n integer := 0;
      k integer := 0;
      nom_participants_avant text;
      polygon_maj geometry := polygon;
      iou_intersect RECORD;
      query_sql text;
  BEGIN
      -- Vérifier si les résultats sont déjà calculés pour ce idu dans le cache
      
      BEGIN
        SELECT multi_calcul_cache.iou_multi, multi_calcul_cache.participants_avant, multi_calcul_cache.participants_apres
        INTO iou_multi, participants_avant, participants_apres
        FROM multi_calcul_cache
        WHERE EXISTS (
            SELECT 1
            FROM unnest(regexp_split_to_array(multi_calcul_cache.participants_avant, ',\\s*')) AS participant
            WHERE participant = idu
        );
        -- Retourner les résultats trouvés dans le cache
        
      END;
      
      -- Si les résultats ne sont pas trouvés dans le cache, exécuter le calcul
      IF NOT FOUND THEN
  
          -- Boucle pour trouver les intersections dans supp
          LOOP
              -- Mettre à jour polygon_maj avec l'union des géométries de supp
              EXECUTE '
                  SELECT ST_Union(geometry) 
                  FROM ' || quote_ident(supp_table_name) || ' 
                  WHERE ST_Intersects(geometry, $1)
              ' INTO polygon_maj USING polygon_maj;
  
              -- Sortir de la boucle si le nombre de parcelles reste le même
              query_sql := '
                  SELECT COUNT(*) 
                  FROM ' || quote_ident(supp_table_name) || ' 
                  WHERE ST_Intersects(geometry, $1)';
              
              EXECUTE query_sql INTO k USING polygon_maj;
              
              EXIT WHEN n = k;
  
              -- Mettre à jour le nombre de parcelles
              n := k;
          END LOOP;
  
          -- Sélectionner les noms des participants avant
          query_sql := '
              SELECT string_agg(idu::text, '', '') 
              FROM ' || quote_ident(supp_table_name) || ' 
              WHERE ST_Intersects(geometry, $1)';
          
          EXECUTE query_sql INTO nom_participants_avant USING polygon_maj;
  
          -- Calculer l'IoU intersection avec ajout
          SELECT * INTO iou_intersect
          FROM calcul_iou_intersec(polygon_maj, ajout_table_name);  -- Utilisez le nom de votre table ajout
  
          -- Insérer les résultats dans le cache
          INSERT INTO multi_calcul_cache (participants_avant, participants_apres, iou_multi)
          VALUES (nom_participants_avant, iou_intersect.participants, iou_intersect.iou);
          
          
          -- Récupérer les résultats pour la sortie
          RETURN QUERY SELECT iou_intersect.iou, nom_participants_avant, iou_intersect.participants;
      ELSE 
          RETURN QUERY SELECT iou_multi, participants_avant, participants_apres;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
") 

# Version sans boucle for
dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_multi_2(polygon geometry, supp_table_name text, ajout_table_name text)
  RETURNS TABLE (iou_multi numeric, participants_avant text, participants_apres text) AS $$
  DECLARE
      polygon_maj geometry;
      nom_participants_avant text;
      iou_intersect RECORD;
      query_sql text;
  BEGIN
      -- Étape 1: Union de tous les polygones
      EXECUTE '
          SELECT ST_Union(geometry) 
          FROM ' || quote_ident(supp_table_name) || ' 
          WHERE ST_Intersects(geometry, $1)
      ' INTO polygon_maj USING polygon;
  
      -- Trouver les polygones individuels qui intersectent le polygon_maj
      query_sql := '
          SELECT string_agg(idu::text, '', '') 
          FROM ' || quote_ident(supp_table_name) || ' 
          WHERE ST_Intersects(geometry, $1)
      ';
  
      -- Exécuter la requête pour récupérer les noms des participants avant
      EXECUTE query_sql INTO nom_participants_avant USING polygon_maj;
  
      -- Calculer l'IoU intersection avec ajout
      SELECT * INTO iou_intersect
      FROM calcul_iou_intersec(polygon_maj, ajout_table_name);  -- Utilisez le nom de votre table ajout
  
      -- Retourner les résultats
      RETURN QUERY SELECT iou_intersect.iou, nom_participants_avant, iou_intersect.participants;
  END;
  $$ LANGUAGE plpgsql;
")

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_convex(supp_table_name text, ajout_table_name text, p_avant text, p_apres text)
  RETURNS numeric AS $$
  DECLARE
      parcelles_avant geometry;
      parcelles_apres geometry;
      iou_convex numeric;
      query_sql text;
  BEGIN
      -- Obtenir les géométries convexes avant
      query_sql := '
          SELECT ST_ConvexHull(ST_Union(geometry))
          FROM ' || quote_ident(supp_table_name) || ' 
          WHERE idu IN (SELECT unnest(string_to_array($1, '', '')))
      ';
      EXECUTE query_sql INTO parcelles_avant USING p_avant;

      -- Obtenir les géométries après
      query_sql := '
          SELECT ST_ConvexHull(ST_Union(geometry))
          FROM ' || quote_ident(ajout_table_name) || ' 
          WHERE idu IN (SELECT unnest(string_to_array($1, '', '')))
      ';
      EXECUTE query_sql INTO parcelles_apres USING p_apres;

      -- Calculer l'IoU
      IF NOT ST_IsEmpty(parcelles_avant) AND NOT ST_IsEmpty(parcelles_apres) THEN
          iou_convex := calcul_iou(parcelles_avant, parcelles_apres);
          RETURN iou_convex;
      ELSE
          RETURN NULL;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
")

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_intersec_translate(polygon geometry, ajout_table_name text)
  RETURNS TABLE (iou_ajust numeric, idu_translate text) AS $$
  DECLARE
      parcelle RECORD;
      max_iou numeric := NULL;
      iou_value numeric;
      query_sql text;
  BEGIN
      -- Construire la requête pour sélectionner les parcelles intersectant avec la zone tampon de polygon
      query_sql := '
          SELECT idu, geometry
          FROM ' || quote_ident(ajout_table_name) || '
          WHERE ST_Intersects(geometry, ST_Buffer($1, -0.1))
      ';
      
      -- Sélectionner les parcelles intersectant avec la zone tampon de polygon
      FOR parcelle IN EXECUTE query_sql USING polygon
      LOOP
          -- Calculer l'IoU entre la parcelle courante et polygon
          BEGIN
              iou_value := calcul_iou(parcelle.geometry, polygon);
          EXCEPTION WHEN others THEN
              iou_value := NULL; -- Ignorer les erreurs de calcul d'IoU
          END;
          
          -- Mettre à jour si on trouve un IoU plus élevé
          IF max_iou IS NULL OR iou_value > max_iou THEN
              max_iou := iou_value;
              idu_translate := parcelle.idu;
          END IF;
      END LOOP;
      
      -- Si aucune parcelle intersecte, retourner NA
      IF max_iou IS NULL THEN
          RETURN QUERY SELECT NULL::numeric, NULL::text;
      END IF;
      
      query_sql := '
          SELECT geometry
          FROM ' || quote_ident(ajout_table_name) || '
          WHERE idu = $1
      ';
      
      -- Calculer l'IoU ajusté avec la meilleure parcelle trouvée
      EXECUTE query_sql INTO parcelle.geometry USING idu_translate;
      iou_ajust := calcul_iou_ajust(parcelle.geometry, polygon);
      
      -- Retourner les résultats
      RETURN QUERY SELECT iou_ajust, idu_translate;
  END;
  $$ LANGUAGE plpgsql;
")

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_multi_translate(idu text, polygon geometry, supp_table_name text, ajout_table_name text)
  RETURNS TABLE (iou_multi_translate numeric, participants_avant_multi_translate text, participants_apres_multi_translate text) AS $$
  DECLARE
      n integer := 0;
      k integer := 0;
      nom_participants_avant text;
      polygon_maj geometry := polygon;
      iou_intersect RECORD;
      query_sql text;
  BEGIN
      -- Vérifier si les résultats sont déjà calculés pour ce idu dans le cache
      
      BEGIN
        SELECT multi_translate_calcul_cache.iou_multi_translate, 
              multi_translate_calcul_cache.participants_avant_multi_translate, 
              multi_translate_calcul_cache.participants_apres_multi_translate
        INTO iou_multi_translate, participants_avant_multi_translate, participants_apres_multi_translate
        FROM multi_translate_calcul_cache
        WHERE EXISTS (
            SELECT 1
            FROM unnest(regexp_split_to_array(multi_translate_calcul_cache.participants_avant_multi_translate, ',\\s*')) AS participant
            WHERE participant = idu
        );
        -- Retourner les résultats trouvés dans le cache
        
      END;
      
      -- Si les résultats ne sont pas trouvés dans le cache, exécuter le calcul
      IF NOT FOUND THEN
  
          -- Boucle pour trouver les intersections dans supp
          LOOP
              -- Mettre à jour polygon_maj avec l'union des géométries de supp
              EXECUTE '
                  SELECT ST_Union(geometry) 
                  FROM ' || quote_ident(supp_table_name) || ' 
                  WHERE ST_Intersects(geometry, $1)
              ' INTO polygon_maj USING polygon_maj;
  
              -- Sortir de la boucle si le nombre de parcelles reste le même
              query_sql := '
                  SELECT COUNT(*) 
                  FROM ' || quote_ident(supp_table_name) || ' 
                  WHERE ST_Intersects(geometry, $1)';
              
              EXECUTE query_sql INTO k USING polygon_maj;
              
              EXIT WHEN n = k;
  
              -- Mettre à jour le nombre de parcelles
              n := k;
          END LOOP;
  
          -- Sélectionner les noms des participants avant
          query_sql := '
              SELECT string_agg(idu::text, '', '') 
              FROM ' || quote_ident(supp_table_name) || ' 
              WHERE ST_Intersects(geometry, $1)';
          
          EXECUTE query_sql INTO nom_participants_avant USING polygon_maj;
  
          -- Calculer l'IoU intersection ajusté avec ajout
          EXECUTE 'SELECT * FROM calcul_iou_intersec_translate($1, $2)' INTO iou_intersect USING polygon_maj, ajout_table_name;
  
          -- Insérer les résultats dans le cache
          INSERT INTO multi_calcul_cache (participants_avant, participants_apres, iou_multi)
          VALUES (nom_participants_avant, iou_intersect.participants, iou_intersect.iou);
          
          
          -- Retourner les résultats
      RETURN QUERY SELECT iou_intersect.iou_ajust AS iou, nom_participants_avant AS participants_avant, iou_intersect.idu_translate AS participants_apres;
      ELSE 
          RETURN QUERY SELECT iou_multi_translate, participants_avant_multi_translate, participants_apres_multi_translate;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
") 

dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_multi_translate_2(polygon geometry, supp_table_name text, ajout_table_name text)
  RETURNS TABLE (iou_multi_translate numeric, participants_avant_multi_translate text, participants_apres_multi_translate text) AS $$
  DECLARE
      polygon_maj geometry := polygon;
      nom_participants_avant text := '';
      iou_intersect RECORD;
      query_sql text;
  BEGIN
      -- Étape 1: Union de tous les polygones
      EXECUTE '
          SELECT ST_Union(geometry) 
          FROM ' || quote_ident(supp_table_name) || ' 
          WHERE ST_Intersects(geometry, $1)
      ' INTO polygon_maj USING polygon;
  
      -- Trouver les polygones individuels qui intersectent le polygon_maj
      query_sql := '
          SELECT string_agg(idu::text, '', '') 
          FROM ' || quote_ident(supp_table_name) || ' 
          WHERE ST_Intersects(geometry, $1)
      ';
  
      -- Exécuter la requête pour récupérer les noms des participants avant
      EXECUTE query_sql INTO nom_participants_avant USING polygon_maj;
  
      -- Calculer l'IoU intersection ajusté avec ajout
      EXECUTE 'SELECT * FROM calcul_iou_intersec_translate($1, $2)' INTO iou_intersect USING polygon_maj, ajout_table_name;
  
      -- Retourner les résultats
      RETURN QUERY SELECT iou_intersect.iou_ajust AS iou, nom_participants_avant AS participants_avant, iou_intersect.idu_translate AS participants_apres;
  END;
  $$ LANGUAGE plpgsql;
")

```

```{r supprimer toutes les tables temporaires}

# Exécution de la requête pour obtenir les noms des tables temporaires
tables_temporaires <- dbGetQuery(conn, "
  SELECT 
      tablename
  FROM 
      pg_tables
  WHERE 
      schemaname LIKE 'pg_temp_%';
")

# Générer les commandes de suppression
drop_queries <- lapply(tables_temporaires$tablename, function(table) {
  paste("DROP TABLE IF EXISTS", table, "CASCADE;")
})

# Exécution des commandes de suppression
for (query in drop_queries) {
  dbExecute(conn, query)
}
rm(tables_temporaires, drop_queries)

dbExecute(conn, "
  CREATE TEMP TABLE multi_calcul_cache (
      participants_avant text PRIMARY KEY,
      participants_apres text,
      iou_multi numeric
  );
")

dbExecute(conn, "
  CREATE TEMP TABLE multi_translate_calcul_cache (
      participants_avant_translate text PRIMARY KEY,
      participants_apres_translate text,
      iou_multi_translate numeric
  );
")

dbExecute(conn, "CREATE INDEX ON multi_calcul_cache (participants_avant);")
dbExecute(conn, "CREATE INDEX ON multi_translate_calcul_cache (participants_avant_translate);")
```

```{r voir les index}
dbGetQuery(conn, " SELECT 
    tablename, 
    indexname, 
    indexdef 
FROM 
    pg_indexes 
WHERE 
    schemaname LIKE 'pg_temp_%' 
    OR schemaname = 'public';
           ")
```

```{r voir les tables temporaires}
dbGetQuery(conn, " SELECT 
    schemaname AS schema_name,
    tablename AS table_name
FROM 
    pg_tables
WHERE 
    schemaname LIKE 'pg_temp_%'
ORDER BY 
    schemaname, tablename;
           ")
```

# Importation des parcelles sur l'ensemble du département et des périodes données

```{r ajout/supp_tot sql}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_tot, supp_tot CASCADE;")

query <- paste0("
  CREATE TEMP TABLE ajout_tot AS
  SELECT * 
  FROM parc_",
  num_departement,
  "_",
  temps_apres, " parc_apres
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_",
  num_departement,
  "_",
  temps_avant," parc_avant
    WHERE parc_apres.idu = parc_avant.idu
  );
")

dbExecute(conn, query)

query <- paste0("
  CREATE TEMP TABLE supp_tot AS
  SELECT * 
  FROM parc_",
  num_departement,
  "_",
  temps_avant, " parc_avant
  WHERE NOT EXISTS (
    SELECT 1
    FROM parc_",
  num_departement,
  "_",
  temps_apres," parc_apres
    WHERE parc_avant.idu = parc_apres.idu
  );
")

dbExecute(conn, query)

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ajout_tot_geometry ON ajout_tot USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_tot_geometry ON supp_tot USING GIST(geometry);")

```


```{r import commune}
commune <- st_read(conn, query = paste0("SELECT * FROM com_", num_departement, ";"))
ajout_tot <- st_read(conn, query = "SELECT * FROM ajout_tot;")
supp_tot <- st_read(conn, query = "SELECT * FROM supp_tot;")
```

# Définition de la bordure dans laquelle je considère que mes parcelles doivent apartenir entièrement

```{r creation bordure et avec ou sans}
dbExecute(conn, "DROP TABLE IF EXISTS bordure, ins_parc_apres, ins_parc_avant, ajout, supp CASCADE;")

query <- paste0("
  CREATE TEMP TABLE bordure AS
  SELECT
      code_insee, nom_com, code_dep,
      ST_Difference(ST_Buffer(geometry, 250), ST_Buffer(geometry, -250)) AS geometry
  FROM
      com_", num_departement, ";"
)

dbExecute(conn, query)

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_bordure_geometry ON bordure USING GIST(geometry);")

query <- paste0("
  CREATE TEMP TABLE ins_parc_apres AS
  SELECT DISTINCT
      parc_apres.*
  FROM
      parc_",
  num_departement,
  "_",
  temps_apres, 
  " parc_apres", 
  ifelse(indic_bordure, "
  JOIN
      bordure
  ON
      ST_WITHIN(parc_apres.geometry, bordure.geometry);", ";"))

dbExecute(conn, query)

query <- paste0("
  CREATE TEMP TABLE ins_parc_avant AS
  SELECT DISTINCT
      parc_avant.*
  FROM
      parc_",
  num_departement,
  "_",
  temps_avant, 
  " parc_avant", 
  ifelse(indic_bordure, "
  JOIN
      bordure
  ON
      ST_WITHIN(parc_avant.geometry, bordure.geometry);", ";"))

dbExecute(conn, query)

query <- paste0("
  CREATE TEMP TABLE ajout AS
  SELECT DISTINCT
      ajout_tot.*
  FROM
      ajout_tot", 
  ifelse(indic_bordure, "
  JOIN
      bordure
  ON
      ST_WITHIN(ajout_tot.geometry, bordure.geometry)
  ORDER BY ajout_tot.nom_com;", ";"))

dbExecute(conn, query)

query <- paste0("
  CREATE TEMP TABLE supp AS
  SELECT DISTINCT
      supp_tot.*
  FROM
      supp_tot", 
  ifelse(indic_bordure, "
  JOIN
      bordure
  ON
      ST_WITHIN(supp_tot.geometry, bordure.geometry)
  ORDER BY supp_tot.nom_com;", ";"))

dbExecute(conn, query)

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ins_parc_apres_geometry ON ins_parc_apres USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ins_parc_avant_geometry ON ins_parc_avant USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ajout_geometry ON ajout USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_geometry ON supp USING GIST(geometry);")
```


```{r bordure sql}
bordure <- st_read(conn, query = "SELECT * FROM bordure;") %>%
  mutate(geometry = st_cast(geometry, "MULTIPOLYGON"))

ins_parc_apres <- st_read(conn, query = "SELECT * FROM ins_parc_apres;")
ins_parc_avant <- st_read(conn, query = "SELECT * FROM ins_parc_avant;")

dbExecute(conn, "DROP TABLE IF EXISTS bordure;")
```

# Focus sur les parcelles dont je peux comparer l'état sur les deux périodes facilement (cad parcelles ayant conservé leur identifiant)

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r modif geometry egal sql}
dbExecute(conn, "DROP TABLE IF EXISTS identique, modif_apres, modif_avant, modif;")

dbExecute(conn, "
  CREATE TEMP TABLE identique AS
  SELECT ins_parc_apres.*
  FROM ins_parc_apres
  WHERE NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE ins_parc_apres.idu = ajout.idu
  )
  AND EXISTS (
      SELECT 1
      FROM ins_parc_avant 
      WHERE ins_parc_apres.idu = ins_parc_avant.idu
      AND ST_Equals(
          ST_SnapToGrid(ins_parc_apres.geometry, 0.0001), 
          ST_SnapToGrid(ins_parc_avant.geometry, 0.0001)
      )
  );
")


dbExecute(conn, "
  CREATE TEMP TABLE modif_apres AS
  SELECT ins_parc_apres.*
  FROM ins_parc_apres
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE ins_parc_apres.idu = identique.idu
  )
  AND NOT EXISTS (
      SELECT 1
      FROM ajout
      WHERE ins_parc_apres.idu = ajout.idu
  );
")

dbExecute(conn, "
  CREATE TEMP TABLE modif_avant AS
  SELECT ins_parc_avant.*
  FROM ins_parc_avant
  WHERE NOT EXISTS (
      SELECT 1
      FROM identique
      WHERE ins_parc_avant.idu = identique.idu
  )
  AND NOT EXISTS (
      SELECT 1
      FROM supp
      WHERE ins_parc_avant.idu = supp.idu
  );
")

dbExecute(conn, "
  CREATE TEMP TABLE modif AS
  SELECT
      COALESCE(avant.idu, apres.idu) AS idu,
      apres.geometry AS geometry_apres,
      avant.geometry AS geometry_avant,
      calcul_iou(apres.geometry, avant.geometry) AS iou,
      calcul_iou_ajust(apres.geometry, avant.geometry) AS iou_ajust
  FROM
      modif_avant avant
  FULL JOIN
      modif_apres apres ON avant.idu = apres.idu;
")

dbExecute(conn, "DROP TABLE IF EXISTS identique;")
```

```{r drop iou null sql}
dbExecute(conn, "
  DELETE FROM modif
  WHERE iou > 0.99 OR iou IS NULL;
")
```


```{r quantile}

# 85130000AH0055 et 85130000AH0017 supplémentaire dans sql
# modif <- st_read(conn, query = "SELECT * FROM modif;")

# Elimine les parcelles "sans changement manifeste" plus les parcelles sans iou = parcelles n'étant plus entièrement dans la bordure lors d'un changement d'une année sur l'autre

# quantiles <- quantile(modif$iou_ajust, probs = c(0.01, 0.03, 0.05, 0.1), na.rm = TRUE)
```

## Reconnaissances des cas de translation, modification de contour et les deux à la fois

```{r translation, contour_apres, contour_translation}
dbExecute(conn, "DROP TABLE IF EXISTS modif_apres_iou, modif_avant_iou, 
          translation, contour_apres, contour_translation;")

dbExecute(conn, "
  CREATE TEMP TABLE modif_apres_iou AS
  SELECT modif_apres.*, modif.iou, modif.iou_ajust
  FROM modif
  LEFT JOIN modif_apres ON modif.idu = modif_apres.idu;
")

dbExecute(conn, "
  CREATE TEMP TABLE modif_avant_iou AS
  SELECT modif_avant.*, modif.iou, modif.iou_ajust
  FROM modif
  LEFT JOIN modif_avant ON modif.idu = modif_avant.idu;
")

dbExecute(conn, "
  CREATE TEMP TABLE translation AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         idu AS idu_translate
  FROM modif_apres_iou
  WHERE iou_ajust > 0.99;
")

dbExecute(conn, "
  CREATE TEMP TABLE contour_apres AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         iou AS iou_multi,
         idu AS participants_avant,
         idu AS participants_apres
  FROM modif_apres_iou
  WHERE iou > 0.95 AND iou_ajust < 0.99;
")

dbExecute(conn, "
  CREATE TEMP TABLE contour_translation AS
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         idu AS idu_translate
  FROM modif_apres_iou
  WHERE iou < 0.95 AND iou_ajust > 0.95 AND iou_ajust < 0.99;
")

dbExecute(conn, "
  DELETE FROM modif_apres_iou
  WHERE idu IN (SELECT idu FROM translation)
    OR idu IN (SELECT idu FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbExecute(conn, "
  DELETE FROM modif_avant_iou
  WHERE idu IN (SELECT idu FROM translation)
    OR idu IN (SELECT idu FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")
```

```{r modif iou_ajust -> translation}
translation_sql <- st_read(conn, query = "SELECT * FROM translation;")
contour_translation_sql <- st_read(conn, query = "SELECT * FROM contour_translation;")
contour_apres_sql <- st_read(conn, query = "SELECT * FROM contour_apres;")
modif_apres_sql <- st_read(conn, query = "SELECT * FROM modif_apres_iou;")
```

## Cas plus compliqués de détection des mêmes cas

```{r meme cas sql}
# NE PAS RELANCER
dbExecute(conn, "DROP TABLE IF EXISTS modif_apres_iou_multi;")
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache;")

dbExecute(conn, "
  CREATE TEMP TABLE modif_apres_iou_multi AS
  SELECT modif_apres_iou.*, 
    (calcul_iou_multi(modif_apres_iou.idu, modif_apres_iou.geometry, 'modif_apres_iou' , 'modif_avant_iou')).*
  FROM modif_apres_iou;
")

dbExecute(conn, "
  INSERT INTO contour_apres
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         iou_multi, participants_avant,participants_apres
  FROM modif_apres_iou_multi
  WHERE (iou_multi > 0.95 AND LENGTH(participants_avant) = LENGTH(participants_apres))
     OR (LENGTH(participants_avant) = 14 AND LENGTH(participants_apres) = 14 AND iou > iou_ajust);
")

dbExecute(conn, "
  INSERT INTO contour_translation
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry, 
         idu AS idu_translate
  FROM modif_apres_iou_multi
  WHERE ((LENGTH(participants_avant) = 14 AND LENGTH(participants_apres) = 14 AND iou < iou_ajust))
     OR iou_multi IS NULL;
")

dbExecute(conn, "
  DELETE FROM modif_apres_iou_multi
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbExecute(conn, "
  DELETE FROM modif_avant_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour_apres)
    OR idu IN (SELECT idu FROM contour_translation);
")
```


```{r modif iou_multi -> translation, modification de contour et les deux à la fois bis}
contour_translation_sql <- st_read(conn, query = "SELECT * FROM contour_translation;")
contour_apres_sql <- st_read(conn, query = "SELECT * FROM contour_apres;")
modif_apres_sql <- st_read(conn, query = "SELECT * FROM modif_apres_iou_multi;")
```

```{r enveloppe convexe}
# NE PAS RELANCER
dbExecute(conn, "DROP TABLE IF EXISTS modif_apres_iou_convex;")

dbExecute(conn, "
  CREATE TEMP TABLE modif_apres_iou_convex AS
  SELECT modif_apres_iou_multi.*, 
    calcul_iou_convex('modif_avant_iou' , 'modif_apres_iou_multi', participants_avant, participants_apres) AS iou_convex
  FROM modif_apres_iou_multi;
")

dbExecute(conn, "
  INSERT INTO contour_apres
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry,
         iou_convex AS io_multi, participants_avant, participants_apres
  FROM modif_apres_iou_convex
  WHERE iou_convex > 0.99 AND LENGTH(participants_avant) = LENGTH(participants_apres);
")

dbExecute(conn, "
  DELETE FROM modif_apres_iou_convex
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour_apres);
")

dbExecute(conn, "
  DELETE FROM modif_avant_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour_apres);
")
```

```{r convex}
contour_apres_sql <- st_read(conn, query = "SELECT * FROM contour_apres;")
modif_apres_sql <- st_read(conn, query = "SELECT * FROM modif_apres_iou_convex;")
modif_avant_sql <- st_read(conn, query = "SELECT * FROM modif_avant_iou;")
```

```{r mapview typologie parcelles modifiées, eval=FALSE, include=FALSE}

map <- mapview(bordure, 
               layer.name = "Bordures étendues", col.regions = "lightblue", 
               alpha.regions = 0.5, homebutton = F,
               map.types = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldImagery"))

if (nrow(translation_sql) > 0) {
  map <- map + mapview(translation_sql,
                       layer.name = "Parcelles translatées (état 2024)", 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ins_parc_avant %>%
              filter(idu %in% translation_sql$idu_translate), 
            layer.name = "Parcelles translatées (état 2023)", 
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_apres_sql) > 0) {
  map <- map + mapview(contour_apres_sql,  
                       layer.name = "Parcelles contours (état 2024)", 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ins_parc_avant %>%
              filter(idu %in% contour_apres_sql$idu),  
            layer.name = "Parcelles contours (état 2023)", 
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_translation_sql) > 0) {
  map <- map + mapview(contour_translation_sql,  
                       layer.name = "Parcelles translatées + contours (état 2024)", 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ins_parc_avant %>%
              filter(idu %in% contour_translation_sql$idu_translate),
            layer.name = "Parcelles translatées + contours (état 2023)", 
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
}
if (nrow(modif_apres_sql) > 0) {
  map <- map + mapview(modif_apres_sql, 
                       z = c("iou_ajust"), 
                       layer.name = "Parcelles modifiées restantes (état 2024)", 
                       alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(modif_avant_sql) > 0) {
  map <- map + mapview(modif_avant_sql, 
                       z = c("iou_ajust"), 
                       layer.name = "Parcelles modifiées restantes (état 2023)", 
                       alpha.regions = 0.5, homebutton = F)
}
mapshot(map, url = "parcelles_modifiées_85_sql_22_21.html")
```

# Focus des parcelles ayant changé de communes

## Cas des parcelles dans le cas d'une fusion de communes

```{r ajout/supp -> focus fusion commune}
dbExecute(conn, "DROP TABLE IF EXISTS com_abs_apres, com_abs_avant;")

dbExecute(conn, "
  CREATE TEMP TABLE com_abs_apres AS
  SELECT *,
         SUBSTR(idu, 1, 2) || com_abs || '000' || SUBSTR(idu, 9, 14) AS idu_avant
  FROM ajout
  WHERE com_abs != '000';
")

dbExecute(conn, "
  CREATE TEMP TABLE com_abs_avant AS
  SELECT *
  FROM supp
  WHERE idu IN (SELECT idu_avant FROM com_abs_apres);
")

dbExecute(conn, "
  DELETE FROM com_abs_apres
  WHERE idu_avant NOT IN (SELECT idu FROM com_abs_avant);
")

# Parcelles n'ayant pas été modifiées mise à part le nom de commune
```

```{r parcelle changeant de communes}
com_abs_apres_sql <- st_read(conn, query = "SELECT * FROM com_abs_apres;")
com_abs_avant_sql <- st_read(conn, query = "
                             SELECT com_abs_avant.*, com_abs_apres.nom_com AS nom_com_apres
                             FROM com_abs_avant
                             LEFT JOIN com_abs_apres 
                             ON com_abs_avant.idu = com_abs_apres.idu_avant;")
```

# Focus parcelles avec changement "majeur" lié à un changement impactant l'identifiant des parcelles

## Elimination des parcelles IDENTIQUES en tout point du polygone (méthode de base pour enlever les cas reconnaissables facilement)

```{r ajout/supp geometry egal}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_simp, supp_simp, ajout_identique, supp_identique CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE ajout_simp AS
  SELECT idu, ST_SnapToGrid(ajout.geometry, 0.0001) AS geometry
  FROM ajout;
")

dbExecute(conn, "
  CREATE TEMP TABLE supp_simp AS
  SELECT idu, ST_SnapToGrid(supp.geometry, 0.0001) AS geometry
  FROM supp;
")

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ajout_simp_geometry ON ajout_simp USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_simp_geometry ON supp_simp USING GIST(geometry);")

# Parcelles ajoutées n'ayant pas été modifiées
dbExecute(conn, "
  CREATE TEMP TABLE ajout_identique AS
  SELECT ajout_simp.*
  FROM ajout_simp
  JOIN supp_simp ON ST_Equals(ajout_simp.geometry, supp_simp.geometry);
")

# Parcelles supprimées n'ayant pas été modifiées
dbExecute(conn, "
  CREATE TEMP TABLE supp_identique AS
  SELECT supp_simp.*
  FROM supp_simp
  JOIN ajout_simp ON ST_Equals(supp_simp.geometry, ajout_simp.geometry);
")

dbExecute(conn, "
  DELETE FROM ajout
  WHERE idu IN (SELECT idu FROM ajout_identique);
")

dbExecute(conn, "
  DELETE FROM supp
  WHERE idu IN (SELECT idu FROM supp_identique);
")

dbExecute(conn, "DROP TABLE IF EXISTS ajout_simp,supp_simp, ajout_identique, supp_identique CASCADE;")
```

## Reconnaissances des cas de fusion (peu fréquent) ou subdivision (plus courant)

```{r ajout/supp iou -> fusion/subdivision}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_iou, supp_iou, fusion, subdiv CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou AS
  SELECT
      supp.*,
      (calcul_iou_intersec(supp.geometry, 'ajout')).*
  FROM
      supp;
")

dbExecute(conn, "
  CREATE TEMP TABLE ajout_iou AS
  SELECT
      ajout.*,
      (calcul_iou_intersec(ajout.geometry, 'supp')).*
  FROM
      ajout;
")

dbExecute(conn, "
  CREATE TEMP TABLE fusion AS
  SELECT *
  FROM ajout_iou
  WHERE iou > 0.99 AND LENGTH(participants) != 14;
")

dbExecute(conn, "
  CREATE TEMP TABLE subdiv AS
  SELECT *
  FROM supp_iou
  WHERE iou > 0.99 AND LENGTH(participants) != 14;
")

dbExecute(conn, "
  DELETE FROM ajout_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants, ',\\s*')) FROM subdiv)
   OR idu IN (SELECT idu FROM fusion)
   OR iou > 0.99;
")

dbExecute(conn, "
  DELETE FROM supp_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants, ',\\s*')) FROM fusion)
    OR idu IN (SELECT idu FROM subdiv)
    OR iou > 0.99;
")

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ajout_iou_geometry ON ajout_iou USING GIST(geometry);")
dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_iou_geometry ON supp_iou USING GIST(geometry);")
```

```{r fusion/subdivision}
subdiv_sql <- st_read(conn, query = "SELECT * FROM subdiv;")
fusion_sql <- st_read(conn, query = "SELECT * FROM fusion;")
```


## Reconnaissances des cas de multi-subdivision (ex : 2 -> 3) ou modification de contours

```{r ajout/supp iou_multi -> multi-subdivision et contours}
dbExecute(conn, "DROP TABLE IF EXISTS supp_iou_multi, multi_subdiv, contour CASCADE;")
dbExecute(conn, "TRUNCATE TABLE multi_calcul_cache;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou_multi AS
  SELECT
      supp_iou.*,
      (calcul_iou_multi(supp_iou.idu, supp_iou.geometry, 'supp_iou', 'ajout_iou')).*
  FROM
      supp_iou;
")

dbExecute(conn, "
  CREATE TEMP TABLE multi_subdiv AS
  SELECT *
  FROM supp_iou_multi
  WHERE iou_multi > 0.99 AND LENGTH(participants_apres) != LENGTH(participants_avant);
")

dbExecute(conn, "
  CREATE TEMP TABLE contour AS
  SELECT *
  FROM supp_iou_multi
  WHERE (iou_multi > 0.95 AND LENGTH(participants_apres) = LENGTH(participants_avant))
    OR (LENGTH(participants_apres) = 14 AND LENGTH(participants_avant) = 14);
")

dbExecute(conn, "
  CREATE TEMP TABLE contour_transfo AS
  SELECT *
  FROM supp_iou_multi
  WHERE (iou_multi > 0.95 AND LENGTH(participants_apres) != LENGTH(participants_avant)
   AND iou_multi < 0.99);
")

dbExecute(conn, "
  DELETE FROM ajout_iou
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM multi_subdiv)
    OR idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour)
    OR idu IN (SELECT unnest(regexp_split_to_array(participants_apres, ',\\s*')) FROM contour_transfo);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM multi_subdiv)
    OR idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour)
    OR idu IN (SELECT unnest(regexp_split_to_array(participants_avant, ',\\s*')) FROM contour_transfo);
")

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_iou_multi_geometry ON supp_iou_multi USING GIST(geometry);")
```

```{r multisubdiv sql}
multi_subdiv_sql <- st_read(conn, query = "SELECT * FROM multi_subdiv;")
contour_transfo_sql <- st_read(conn, query = "SELECT * FROM contour_transfo;")
contour_sql <- st_read(conn, query = "SELECT * FROM contour;")
```

## Reconnaissances des cas de modification de contours plus compliquée
# a revoir c est trop long

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation, modification de contour avec translation

####### A PARTIR D'ICI C'est plus vérifié
```{r ajout/supp iou_ajust -> translation, contour + translation}
dbExecute(conn, "DROP TABLE IF EXISTS ajout_iou_translate CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE ajout_iou_translate AS
  SELECT DISTINCT
      ajout_iou.*,
      (calcul_iou_intersec_translate(ajout_iou.geometry, 'supp_iou_multi')).*
  FROM
      ajout_iou;
")

dbExecute(conn, "
  INSERT INTO translation
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry, idu_translate
  FROM ajout_iou_translate
  WHERE iou_ajust > 0.99;
")

dbExecute(conn, "
  INSERT INTO contour_translation
  SELECT idu, numero, feuille, section, code_dep, nom_com, code_com, com_abs, 
         code_arr, contenance, iou_ajust, geometry, idu_translate
  FROM ajout_iou_translate
  WHERE (iou_ajust > 0.95 AND iou_ajust < 0.99);
")

dbExecute(conn, "
  DELETE FROM ajout_iou_translate
  WHERE idu IN (SELECT idu FROM translation)
    OR idu IN (SELECT idu FROM contour_translation);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi
  WHERE idu IN (SELECT idu_translate FROM translation)
    OR idu IN (SELECT idu_translate FROM contour_translation);
")

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_ajout_iou_translate_geometry ON ajout_iou_translate USING GIST(geometry);")
```

```{r contour translation ou translation seule}
contour_translation_sql <- st_read(conn, query = "SELECT * FROM contour_translation;")
translation_sql <- st_read(conn, query = "SELECT * FROM translation;")
```

## (Cas particulier du remaniement du PC d'une commune) Reconnaissances des cas de translation avec modification de contour et avec fusion

```{r ajout/supp iou_ajust -> contour_fusion_translation}
dbExecute(conn, "DROP TABLE IF EXISTS supp_iou_multi_translate, contour_fusion_translation CASCADE;")
dbExecute(conn, "TRUNCATE TABLE multi_translate_calcul_cache;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou_multi_translate AS
  SELECT 
      supp_iou_multi.*,
      (calcul_iou_multi_translate(supp_iou_multi.geometry, 'supp_iou_multi', 'ajout_iou_translate')).*
  FROM
      supp_iou_multi;
")
"RAISE NOTICE 'Avant la vérification NOT FOUND, idu: %', idu;"
dbExecute(conn, "
  CREATE OR REPLACE FUNCTION calcul_iou_multi_translate(idu text, polygon geometry, supp_table_name text, ajout_table_name text)
  RETURNS TABLE (iou_multi_translate numeric, participants_avant_multi_translate text, participants_apres_multi_translate text) AS $$
  DECLARE
      n integer := 0;
      k integer := 0;
      nom_participants_avant text;
      polygon_maj geometry := polygon;
      iou_intersect RECORD;
      query_sql text;
  BEGIN
      -- Vérifier si les résultats sont déjà calculés pour ce idu dans le cache
      
      BEGIN
        SELECT multi_translate_calcul_cache.iou_multi_translate, 
              multi_translate_calcul_cache.participants_avant_multi_translate, 
              multi_translate_calcul_cache.participants_apres_multi_translate
        INTO iou_multi_translate, participants_avant_multi_translate, participants_apres_multi_translate
        FROM multi_translate_calcul_cache
        WHERE EXISTS (
            SELECT 1
            FROM unnest(regexp_split_to_array(multi_translate_calcul_cache.participants_avant_multi_translate, ',\\s*')) AS participant
            WHERE participant = idu
        );
        -- Retourner les résultats trouvés dans le cache
        
      END;
      
      -- Si les résultats ne sont pas trouvés dans le cache, exécuter le calcul
      IF NOT FOUND THEN
  
          -- Boucle pour trouver les intersections dans supp
          LOOP
              -- Mettre à jour polygon_maj avec l'union des géométries de supp
              EXECUTE '
                  SELECT ST_Union(geometry) 
                  FROM ' || quote_ident(supp_table_name) || ' 
                  WHERE ST_Intersects(geometry, $1)
              ' INTO polygon_maj USING polygon_maj;
  
              -- Sortir de la boucle si le nombre de parcelles reste le même
              query_sql := '
                  SELECT COUNT(*) 
                  FROM ' || quote_ident(supp_table_name) || ' 
                  WHERE ST_Intersects(geometry, $1)';
              
              EXECUTE query_sql INTO k USING polygon_maj;
              
              EXIT WHEN n = k;
  
              -- Mettre à jour le nombre de parcelles
              n := k;
          END LOOP;
  
          -- Sélectionner les noms des participants avant
          query_sql := '
              SELECT string_agg(idu::text, '', '') 
              FROM ' || quote_ident(supp_table_name) || ' 
              WHERE ST_Intersects(geometry, $1)';
          
          EXECUTE query_sql INTO nom_participants_avant USING polygon_maj;
  
          -- Calculer l'IoU intersection ajusté avec ajout
          EXECUTE 'SELECT * FROM calcul_iou_intersec_translate($1, $2)' INTO iou_intersect USING polygon_maj, ajout_table_name;
  
          -- Insérer les résultats dans le cache
          INSERT INTO multi_calcul_cache (participants_avant, participants_apres, iou_multi)
          VALUES (nom_participants_avant, iou_intersect.participants, iou_intersect.iou);
          
          
          -- Retourner les résultats
      RETURN QUERY SELECT iou_intersect.iou_ajust AS iou, nom_participants_avant AS participants_avant, iou_intersect.idu_translate AS participants_apres;
      ELSE 
          RETURN QUERY SELECT iou_multi_translate, participants_avant_multi_translate, participants_apres_multi_translate;
      END IF;
  END;
  $$ LANGUAGE plpgsql;
") 

dbExecute(conn, "
  CREATE TEMP TABLE contour_fusion_translation AS
  SELECT *
  FROM supp_iou_multi_translate
  WHERE iou_multi_translate > 0.95;
")

dbExecute(conn, "
  DELETE FROM ajout_iou_translate
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_apres_multi_translate, ',\\s*')) FROM contour_fusion_translation);
")

dbExecute(conn, "
  DELETE FROM supp_iou_multi_translate
  WHERE idu IN (SELECT unnest(regexp_split_to_array(participants_avant_multi_translate, ',\\s*')) FROM contour_fusion_translation);
")

dbExecute(conn, "CREATE INDEX IF NOT EXISTS idx_supp_iou_multi_translate_geometry ON supp_iou_multi_translate USING GIST(geometry);")
```

```{r contour_fusion_translation}
contour_fusion_translation_sql <- st_read(conn, query = "SELECT * FROM contour_fusion_translation;")
```

## Recalcul de l'IoU pour détecter les parcelles maintenant isolées -> Véritable ajout ou suppression

```{r le reste}
dbExecute(conn, "DROP TABLE IF EXISTS supp_iou_restant, ajout_iou_restant, 
          vrai_ajout, vrai_supp CASCADE;")

dbExecute(conn, "
  CREATE TEMP TABLE supp_iou_restant AS
  SELECT
      idu, numero, feuille, section, code_dep, nom_com, code_com, 
      com_abs, code_arr, contenance, geometry, iou_multi, participants_avant, participants_apres, 
      iou_multi_translate, participants_avant_multi_translate, participants_apres_multi_translate,
      (calcul_iou_intersec(supp_iou_multi_translate.geometry, 'ajout_iou_translate')).* 
  FROM
      supp_iou_multi_translate;
")

dbExecute(conn, "
  CREATE TEMP TABLE ajout_iou_restant AS
  SELECT
      idu, numero, feuille, section, code_dep, nom_com, code_com, 
      com_abs, code_arr, contenance, geometry, iou_ajust, idu_translate,
      (calcul_iou_intersec(ajout_iou_translate.geometry, 'supp_iou_multi_translate')).*
  FROM
      ajout_iou_translate;
")

dbExecute(conn, "
  CREATE TEMP TABLE vrai_ajout AS
  SELECT *
  FROM ajout_iou_restant
  WHERE iou IS NULL;
")

dbExecute(conn, "
  CREATE TEMP TABLE vrai_supp AS
  SELECT *
  FROM supp_iou_restant
  WHERE iou IS NULL;
")

dbExecute(conn, "
  DELETE FROM ajout_iou_restant
  WHERE idu IN (SELECT idu FROM vrai_ajout);
")

dbExecute(conn, "
  DELETE FROM supp_iou_restant
  WHERE idu IN (SELECT idu FROM vrai_supp);
")
```


```{r le reste}
ajout_sql <- st_read(conn, query = "SELECT * FROM ajout_iou_restant;")
supp_sql <- st_read(conn, query = "SELECT * FROM supp_iou_restant;")

vrai_ajout_sql <- st_read(conn, query = "SELECT * FROM vrai_ajout;")
vrai_supp_sql <- st_read(conn, query = "SELECT * FROM vrai_supp;")
```

# Visualisation finale sur une carte du département

```{r mapview typologie parcelles, eval=FALSE, include=FALSE}

map <- mapview(bordure, 
               layer.name = "Bordures étendues", col.regions = "lightblue", 
               alpha.regions = 0.5, homebutton = F,
               map.types = c("CartoDB.Positron", "OpenStreetMap", "Esri.WorldImagery"))

if (nrow(translation_sql) > 0) {
  map <- map + mapview(translation_sql,
                       layer.name = "Parcelles translatées (état 2024)", 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ins_parc_avant %>%
              filter(idu %in% translation_sql$idu_translate), 
            layer.name = "Parcelles translatées (état 2023)", 
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(fusion_sql) > 0) {
  map <- map + mapview(fusion_sql, 
                       layer.name = "Parcelles fusionnéees (état 2024)", 
                       col.regions = "orange", alpha.regions = 0.5, homebutton = F) +
    mapview(supp_tot %>%
              filter(idu %in% unlist(str_split(fusion_sql$participants, ",\\s*"))),  
            layer.name = "Parcelles fusionnéees (état 2023)", 
            alpha.regions = 0.5, homebutton = F)
}
if (nrow(subdiv_sql) > 0) {
  map <- map + mapview(ajout_tot %>%
                         filter(idu %in% unlist(str_split(subdiv_sql$participants, ",\\s*"))),  
                       layer.name = "Parcelles subdivisées (état 2024)", 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(subdiv_sql,  
            layer.name = "Parcelles subdivisées (état 2023)", 
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
}
if (nrow(multi_subdiv_sql) > 0) {
  map <- map + mapview(ajout_tot %>%
                         filter(idu %in% unlist(str_split(multi_subdiv_sql$participants_apres, ",\\s*"))),
                       layer.name = "Parcelles multi-subdivision (état 2024)", 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(multi_subdiv_sql,  
            layer.name = "Parcelles multi-subdivision (état 2023)", 
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(contour_sql) > 0) {
  map <- map + mapview(ajout_tot %>%
                         filter(idu %in% unlist(str_split(contour_sql$participants_apres, ",\\s*"))),  
                       layer.name = "Parcelles contours (état 2024)", 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(contour_sql,
            layer.name = "Parcelles contours (état 2023)",
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_apres_sql) > 0) {
  map <- map + mapview(contour_apres_sql,  
                       layer.name = "Parcelles contours (état 2024)", 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ins_parc_avant %>%
              filter(idu %in% contour_apres_sql$idu),  
            layer.name = "Parcelles contours (état 2023)", 
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_transfo_sql) > 0) {
  map <- map + mapview(ajout_tot %>%
                         filter(idu %in% unlist(str_split(contour_transfo_sql$participants_apres, ",\\s*"))),  
                       layer.name = "Parcelles ayant transfo + contours (état 2024)",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(contour_transfo_sql,
            layer.name = "Parcelles ayant transfo + contours (état 2023)", 
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_translation_sql) > 0) {
  map <- map + mapview(contour_translation_sql,  
                       layer.name = "Parcelles translatées + contours (état 2024)", 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ins_parc_avant %>%
              filter(idu %in% contour_translation_sql$idu_translate),
            layer.name = "Parcelles translatées + contours (état 2023)", 
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
}
if (nrow(contour_fusion_translation_sql) > 0) {
  map <- map + mapview(contour_fusion_translation_sql,  
                       layer.name = "Parcelles translatées + contours + fusion (état 2024)", 
                       alpha.regions = 0.5, homebutton = F) +
    mapview(ajout_tot %>%
              filter(idu %in% contour_fusion_translation_sql$participants_apres_multi_translate),
            layer.name = "Parcelles translatées + contours + fusion (état 2023)", 
            col.regions = "orange", alpha.regions = 0.5, homebutton = F)
}
if (nrow(com_abs_apres_sql) > 0) {
  map <- map + mapview(com_abs_apres_sql,  
                       layer.name = "Parcelles fusion de communes (état 2024)", 
                       col.regions = "pink",
                       alpha.regions = 0.5, homebutton = F) +
    mapview(com_abs_avant_sql,  
            layer.name = "Parcelles fusion de communes (état 2023)", 
            col.regions = "pink", alpha.regions = 0.5, homebutton = F)
}
if (nrow(vrai_ajout_sql) > 0) {
  map <- map + mapview(vrai_ajout_sql, 
                       layer.name = "Parcelles véritablement ajoutées", 
                       col.regions = "green", alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(vrai_supp_sql) > 0) {
  map <- map + mapview(vrai_supp_sql,
                       layer.name = "Parcelles véritablement supprimées",
                       col.regions = "red", alpha.regions = 0.5, homebutton = F) 
}
if (nrow(ajout_sql) > 0) {
  map <- map + mapview(ajout_sql,
                       z = c("iou_ajust"), layer.name = "Parcelles restantes (état 2024)", 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(supp_sql) > 0) {
  map <- map + mapview(supp_sql, 
                       z = c("iou_multi"), layer.name = "Parcelles restantes (état 2023)", 
                       alpha.regions = 0.5, homebutton = F)
}
if (nrow(modif_apres_sql) > 0) {
  map <- map + mapview(modif_apres_sql, 
                       z = c("iou_ajust"), 
                       layer.name = "Parcelles modifiées restantes (état 2024)", 
                       alpha.regions = 0.5, homebutton = F)
  
}
if (nrow(modif_avant_sql) > 0) {
  map <- map + mapview(modif_avant_sql, 
                       z = c("iou_ajust"), 
                       layer.name = "Parcelles modifiées restantes (état 2023)", 
                       alpha.regions = 0.5, homebutton = F)
}
mapshot(map, url = "parcelles_iou_85_23-22_sql.html")
```
